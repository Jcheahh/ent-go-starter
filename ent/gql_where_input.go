// Code generated by ent, DO NOT EDIT.

package ent

import (
	"entdemo/ent/bankaccount"
	"entdemo/ent/blogpost"
	"entdemo/ent/category"
	"entdemo/ent/chat"
	"entdemo/ent/commissionstructureschema"
	"entdemo/ent/contentblock"
	"entdemo/ent/emailcampaign"
	"entdemo/ent/group"
	"entdemo/ent/groupbuy"
	"entdemo/ent/herocontent"
	"entdemo/ent/image"
	"entdemo/ent/linkvisit"
	"entdemo/ent/marketingcampaign"
	"entdemo/ent/notification"
	"entdemo/ent/paymentmethod"
	"entdemo/ent/predicate"
	"entdemo/ent/primarycontent"
	"entdemo/ent/product"
	"entdemo/ent/productattribute"
	"entdemo/ent/productpageview"
	"entdemo/ent/productvariation"
	"entdemo/ent/referrallink"
	"entdemo/ent/refundtransactions"
	"entdemo/ent/review"
	"entdemo/ent/rewardtype"
	"entdemo/ent/shippingaddress"
	"entdemo/ent/shop"
	"entdemo/ent/tag"
	"entdemo/ent/transaction"
	"entdemo/ent/user"
	"entdemo/ent/userbuyer"
	"entdemo/ent/userinfluencer"
	"entdemo/ent/userseller"
	"entdemo/ent/viewanalytics"
	"errors"
	"fmt"
)

// BankAccountWhereInput represents a where input for filtering BankAccount queries.
type BankAccountWhereInput struct {
	Predicates []predicate.BankAccount  `json:"-"`
	Not        *BankAccountWhereInput   `json:"not,omitempty"`
	Or         []*BankAccountWhereInput `json:"or,omitempty"`
	And        []*BankAccountWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "xid" field predicates.
	Xid      *int  `json:"xid,omitempty"`
	XidNEQ   *int  `json:"xidNEQ,omitempty"`
	XidIn    []int `json:"xidIn,omitempty"`
	XidNotIn []int `json:"xidNotIn,omitempty"`
	XidGT    *int  `json:"xidGT,omitempty"`
	XidGTE   *int  `json:"xidGTE,omitempty"`
	XidLT    *int  `json:"xidLT,omitempty"`
	XidLTE   *int  `json:"xidLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BankAccountWhereInput) AddPredicates(predicates ...predicate.BankAccount) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BankAccountWhereInput filter on the BankAccountQuery builder.
func (i *BankAccountWhereInput) Filter(q *BankAccountQuery) (*BankAccountQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBankAccountWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBankAccountWhereInput is returned in case the BankAccountWhereInput is empty.
var ErrEmptyBankAccountWhereInput = errors.New("ent: empty predicate BankAccountWhereInput")

// P returns a predicate for filtering bankaccounts.
// An error is returned if the input is empty or invalid.
func (i *BankAccountWhereInput) P() (predicate.BankAccount, error) {
	var predicates []predicate.BankAccount
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bankaccount.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BankAccount, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bankaccount.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BankAccount, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bankaccount.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bankaccount.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bankaccount.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bankaccount.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bankaccount.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bankaccount.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bankaccount.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bankaccount.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bankaccount.IDLTE(*i.IDLTE))
	}
	if i.Xid != nil {
		predicates = append(predicates, bankaccount.XidEQ(*i.Xid))
	}
	if i.XidNEQ != nil {
		predicates = append(predicates, bankaccount.XidNEQ(*i.XidNEQ))
	}
	if len(i.XidIn) > 0 {
		predicates = append(predicates, bankaccount.XidIn(i.XidIn...))
	}
	if len(i.XidNotIn) > 0 {
		predicates = append(predicates, bankaccount.XidNotIn(i.XidNotIn...))
	}
	if i.XidGT != nil {
		predicates = append(predicates, bankaccount.XidGT(*i.XidGT))
	}
	if i.XidGTE != nil {
		predicates = append(predicates, bankaccount.XidGTE(*i.XidGTE))
	}
	if i.XidLT != nil {
		predicates = append(predicates, bankaccount.XidLT(*i.XidLT))
	}
	if i.XidLTE != nil {
		predicates = append(predicates, bankaccount.XidLTE(*i.XidLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBankAccountWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bankaccount.And(predicates...), nil
	}
}

// BlogPostWhereInput represents a where input for filtering BlogPost queries.
type BlogPostWhereInput struct {
	Predicates []predicate.BlogPost  `json:"-"`
	Not        *BlogPostWhereInput   `json:"not,omitempty"`
	Or         []*BlogPostWhereInput `json:"or,omitempty"`
	And        []*BlogPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "author" edge predicates.
	HasAuthor     *bool                   `json:"hasAuthor,omitempty"`
	HasAuthorWith []*UserSellerWhereInput `json:"hasAuthorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BlogPostWhereInput) AddPredicates(predicates ...predicate.BlogPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BlogPostWhereInput filter on the BlogPostQuery builder.
func (i *BlogPostWhereInput) Filter(q *BlogPostQuery) (*BlogPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBlogPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBlogPostWhereInput is returned in case the BlogPostWhereInput is empty.
var ErrEmptyBlogPostWhereInput = errors.New("ent: empty predicate BlogPostWhereInput")

// P returns a predicate for filtering blogposts.
// An error is returned if the input is empty or invalid.
func (i *BlogPostWhereInput) P() (predicate.BlogPost, error) {
	var predicates []predicate.BlogPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, blogpost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BlogPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, blogpost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BlogPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, blogpost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, blogpost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, blogpost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, blogpost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, blogpost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, blogpost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, blogpost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, blogpost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, blogpost.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, blogpost.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, blogpost.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, blogpost.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, blogpost.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, blogpost.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, blogpost.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, blogpost.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, blogpost.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, blogpost.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, blogpost.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, blogpost.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, blogpost.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, blogpost.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, blogpost.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, blogpost.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, blogpost.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, blogpost.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, blogpost.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, blogpost.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, blogpost.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, blogpost.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, blogpost.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, blogpost.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, blogpost.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, blogpost.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, blogpost.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, blogpost.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, blogpost.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, blogpost.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, blogpost.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, blogpost.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, blogpost.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, blogpost.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, blogpost.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, blogpost.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, blogpost.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, blogpost.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, blogpost.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, blogpost.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, blogpost.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, blogpost.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, blogpost.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, blogpost.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, blogpost.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, blogpost.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, blogpost.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, blogpost.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, blogpost.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, blogpost.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, blogpost.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, blogpost.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, blogpost.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	if i.HasAuthor != nil {
		p := blogpost.HasAuthor()
		if !*i.HasAuthor {
			p = blogpost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorWith) > 0 {
		with := make([]predicate.UserSeller, 0, len(i.HasAuthorWith))
		for _, w := range i.HasAuthorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, blogpost.HasAuthorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBlogPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return blogpost.And(predicates...), nil
	}
}

// CategoryWhereInput represents a where input for filtering Category queries.
type CategoryWhereInput struct {
	Predicates []predicate.Category  `json:"-"`
	Not        *CategoryWhereInput   `json:"not,omitempty"`
	Or         []*CategoryWhereInput `json:"or,omitempty"`
	And        []*CategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CategoryWhereInput) AddPredicates(predicates ...predicate.Category) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CategoryWhereInput filter on the CategoryQuery builder.
func (i *CategoryWhereInput) Filter(q *CategoryQuery) (*CategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCategoryWhereInput is returned in case the CategoryWhereInput is empty.
var ErrEmptyCategoryWhereInput = errors.New("ent: empty predicate CategoryWhereInput")

// P returns a predicate for filtering categories.
// An error is returned if the input is empty or invalid.
func (i *CategoryWhereInput) P() (predicate.Category, error) {
	var predicates []predicate.Category
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, category.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Category, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, category.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Category, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, category.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, category.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, category.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, category.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, category.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, category.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, category.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, category.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, category.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, category.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, category.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, category.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, category.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, category.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, category.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, category.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, category.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, category.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, category.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, category.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, category.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, category.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, category.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, category.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, category.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, category.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, category.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, category.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, category.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, category.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, category.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, category.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, category.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, category.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, category.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasProducts != nil {
		p := category.HasProducts()
		if !*i.HasProducts {
			p = category.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, category.HasProductsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return category.And(predicates...), nil
	}
}

// ChatWhereInput represents a where input for filtering Chat queries.
type ChatWhereInput struct {
	Predicates []predicate.Chat  `json:"-"`
	Not        *ChatWhereInput   `json:"not,omitempty"`
	Or         []*ChatWhereInput `json:"or,omitempty"`
	And        []*ChatWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "xid" field predicates.
	Xid      *int  `json:"xid,omitempty"`
	XidNEQ   *int  `json:"xidNEQ,omitempty"`
	XidIn    []int `json:"xidIn,omitempty"`
	XidNotIn []int `json:"xidNotIn,omitempty"`
	XidGT    *int  `json:"xidGT,omitempty"`
	XidGTE   *int  `json:"xidGTE,omitempty"`
	XidLT    *int  `json:"xidLT,omitempty"`
	XidLTE   *int  `json:"xidLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChatWhereInput) AddPredicates(predicates ...predicate.Chat) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChatWhereInput filter on the ChatQuery builder.
func (i *ChatWhereInput) Filter(q *ChatQuery) (*ChatQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChatWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChatWhereInput is returned in case the ChatWhereInput is empty.
var ErrEmptyChatWhereInput = errors.New("ent: empty predicate ChatWhereInput")

// P returns a predicate for filtering chats.
// An error is returned if the input is empty or invalid.
func (i *ChatWhereInput) P() (predicate.Chat, error) {
	var predicates []predicate.Chat
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, chat.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Chat, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, chat.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Chat, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, chat.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, chat.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, chat.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, chat.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, chat.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, chat.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, chat.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, chat.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, chat.IDLTE(*i.IDLTE))
	}
	if i.Xid != nil {
		predicates = append(predicates, chat.XidEQ(*i.Xid))
	}
	if i.XidNEQ != nil {
		predicates = append(predicates, chat.XidNEQ(*i.XidNEQ))
	}
	if len(i.XidIn) > 0 {
		predicates = append(predicates, chat.XidIn(i.XidIn...))
	}
	if len(i.XidNotIn) > 0 {
		predicates = append(predicates, chat.XidNotIn(i.XidNotIn...))
	}
	if i.XidGT != nil {
		predicates = append(predicates, chat.XidGT(*i.XidGT))
	}
	if i.XidGTE != nil {
		predicates = append(predicates, chat.XidGTE(*i.XidGTE))
	}
	if i.XidLT != nil {
		predicates = append(predicates, chat.XidLT(*i.XidLT))
	}
	if i.XidLTE != nil {
		predicates = append(predicates, chat.XidLTE(*i.XidLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChatWhereInput
	case 1:
		return predicates[0], nil
	default:
		return chat.And(predicates...), nil
	}
}

// CommissionStructureSchemaWhereInput represents a where input for filtering CommissionStructureSchema queries.
type CommissionStructureSchemaWhereInput struct {
	Predicates []predicate.CommissionStructureSchema  `json:"-"`
	Not        *CommissionStructureSchemaWhereInput   `json:"not,omitempty"`
	Or         []*CommissionStructureSchemaWhereInput `json:"or,omitempty"`
	And        []*CommissionStructureSchemaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "commissionValue" field predicates.
	CommissionValue             *string  `json:"commissionvalue,omitempty"`
	CommissionValueNEQ          *string  `json:"commissionvalueNEQ,omitempty"`
	CommissionValueIn           []string `json:"commissionvalueIn,omitempty"`
	CommissionValueNotIn        []string `json:"commissionvalueNotIn,omitempty"`
	CommissionValueGT           *string  `json:"commissionvalueGT,omitempty"`
	CommissionValueGTE          *string  `json:"commissionvalueGTE,omitempty"`
	CommissionValueLT           *string  `json:"commissionvalueLT,omitempty"`
	CommissionValueLTE          *string  `json:"commissionvalueLTE,omitempty"`
	CommissionValueContains     *string  `json:"commissionvalueContains,omitempty"`
	CommissionValueHasPrefix    *string  `json:"commissionvalueHasPrefix,omitempty"`
	CommissionValueHasSuffix    *string  `json:"commissionvalueHasSuffix,omitempty"`
	CommissionValueEqualFold    *string  `json:"commissionvalueEqualFold,omitempty"`
	CommissionValueContainsFold *string  `json:"commissionvalueContainsFold,omitempty"`

	// "commissionPercentage" field predicates.
	CommissionPercentage             *string  `json:"commissionpercentage,omitempty"`
	CommissionPercentageNEQ          *string  `json:"commissionpercentageNEQ,omitempty"`
	CommissionPercentageIn           []string `json:"commissionpercentageIn,omitempty"`
	CommissionPercentageNotIn        []string `json:"commissionpercentageNotIn,omitempty"`
	CommissionPercentageGT           *string  `json:"commissionpercentageGT,omitempty"`
	CommissionPercentageGTE          *string  `json:"commissionpercentageGTE,omitempty"`
	CommissionPercentageLT           *string  `json:"commissionpercentageLT,omitempty"`
	CommissionPercentageLTE          *string  `json:"commissionpercentageLTE,omitempty"`
	CommissionPercentageContains     *string  `json:"commissionpercentageContains,omitempty"`
	CommissionPercentageHasPrefix    *string  `json:"commissionpercentageHasPrefix,omitempty"`
	CommissionPercentageHasSuffix    *string  `json:"commissionpercentageHasSuffix,omitempty"`
	CommissionPercentageEqualFold    *string  `json:"commissionpercentageEqualFold,omitempty"`
	CommissionPercentageContainsFold *string  `json:"commissionpercentageContainsFold,omitempty"`

	// "productSeller" edge predicates.
	HasProductSeller     *bool                   `json:"hasProductSeller,omitempty"`
	HasProductSellerWith []*UserSellerWhereInput `json:"hasProductSellerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CommissionStructureSchemaWhereInput) AddPredicates(predicates ...predicate.CommissionStructureSchema) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CommissionStructureSchemaWhereInput filter on the CommissionStructureSchemaQuery builder.
func (i *CommissionStructureSchemaWhereInput) Filter(q *CommissionStructureSchemaQuery) (*CommissionStructureSchemaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCommissionStructureSchemaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCommissionStructureSchemaWhereInput is returned in case the CommissionStructureSchemaWhereInput is empty.
var ErrEmptyCommissionStructureSchemaWhereInput = errors.New("ent: empty predicate CommissionStructureSchemaWhereInput")

// P returns a predicate for filtering commissionstructureschemas.
// An error is returned if the input is empty or invalid.
func (i *CommissionStructureSchemaWhereInput) P() (predicate.CommissionStructureSchema, error) {
	var predicates []predicate.CommissionStructureSchema
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, commissionstructureschema.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CommissionStructureSchema, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, commissionstructureschema.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CommissionStructureSchema, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, commissionstructureschema.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, commissionstructureschema.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, commissionstructureschema.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, commissionstructureschema.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, commissionstructureschema.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, commissionstructureschema.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, commissionstructureschema.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, commissionstructureschema.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, commissionstructureschema.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, commissionstructureschema.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, commissionstructureschema.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, commissionstructureschema.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, commissionstructureschema.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, commissionstructureschema.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, commissionstructureschema.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, commissionstructureschema.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, commissionstructureschema.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, commissionstructureschema.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, commissionstructureschema.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, commissionstructureschema.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, commissionstructureschema.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, commissionstructureschema.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, commissionstructureschema.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, commissionstructureschema.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, commissionstructureschema.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.CommissionValue != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueEQ(*i.CommissionValue))
	}
	if i.CommissionValueNEQ != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueNEQ(*i.CommissionValueNEQ))
	}
	if len(i.CommissionValueIn) > 0 {
		predicates = append(predicates, commissionstructureschema.CommissionValueIn(i.CommissionValueIn...))
	}
	if len(i.CommissionValueNotIn) > 0 {
		predicates = append(predicates, commissionstructureschema.CommissionValueNotIn(i.CommissionValueNotIn...))
	}
	if i.CommissionValueGT != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueGT(*i.CommissionValueGT))
	}
	if i.CommissionValueGTE != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueGTE(*i.CommissionValueGTE))
	}
	if i.CommissionValueLT != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueLT(*i.CommissionValueLT))
	}
	if i.CommissionValueLTE != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueLTE(*i.CommissionValueLTE))
	}
	if i.CommissionValueContains != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueContains(*i.CommissionValueContains))
	}
	if i.CommissionValueHasPrefix != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueHasPrefix(*i.CommissionValueHasPrefix))
	}
	if i.CommissionValueHasSuffix != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueHasSuffix(*i.CommissionValueHasSuffix))
	}
	if i.CommissionValueEqualFold != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueEqualFold(*i.CommissionValueEqualFold))
	}
	if i.CommissionValueContainsFold != nil {
		predicates = append(predicates, commissionstructureschema.CommissionValueContainsFold(*i.CommissionValueContainsFold))
	}
	if i.CommissionPercentage != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageEQ(*i.CommissionPercentage))
	}
	if i.CommissionPercentageNEQ != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageNEQ(*i.CommissionPercentageNEQ))
	}
	if len(i.CommissionPercentageIn) > 0 {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageIn(i.CommissionPercentageIn...))
	}
	if len(i.CommissionPercentageNotIn) > 0 {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageNotIn(i.CommissionPercentageNotIn...))
	}
	if i.CommissionPercentageGT != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageGT(*i.CommissionPercentageGT))
	}
	if i.CommissionPercentageGTE != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageGTE(*i.CommissionPercentageGTE))
	}
	if i.CommissionPercentageLT != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageLT(*i.CommissionPercentageLT))
	}
	if i.CommissionPercentageLTE != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageLTE(*i.CommissionPercentageLTE))
	}
	if i.CommissionPercentageContains != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageContains(*i.CommissionPercentageContains))
	}
	if i.CommissionPercentageHasPrefix != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageHasPrefix(*i.CommissionPercentageHasPrefix))
	}
	if i.CommissionPercentageHasSuffix != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageHasSuffix(*i.CommissionPercentageHasSuffix))
	}
	if i.CommissionPercentageEqualFold != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageEqualFold(*i.CommissionPercentageEqualFold))
	}
	if i.CommissionPercentageContainsFold != nil {
		predicates = append(predicates, commissionstructureschema.CommissionPercentageContainsFold(*i.CommissionPercentageContainsFold))
	}

	if i.HasProductSeller != nil {
		p := commissionstructureschema.HasProductSeller()
		if !*i.HasProductSeller {
			p = commissionstructureschema.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductSellerWith) > 0 {
		with := make([]predicate.UserSeller, 0, len(i.HasProductSellerWith))
		for _, w := range i.HasProductSellerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductSellerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, commissionstructureschema.HasProductSellerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCommissionStructureSchemaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return commissionstructureschema.And(predicates...), nil
	}
}

// ContentBlockWhereInput represents a where input for filtering ContentBlock queries.
type ContentBlockWhereInput struct {
	Predicates []predicate.ContentBlock  `json:"-"`
	Not        *ContentBlockWhereInput   `json:"not,omitempty"`
	Or         []*ContentBlockWhereInput `json:"or,omitempty"`
	And        []*ContentBlockWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "primaryMessage" field predicates.
	PrimaryMessage             *string  `json:"primarymessage,omitempty"`
	PrimaryMessageNEQ          *string  `json:"primarymessageNEQ,omitempty"`
	PrimaryMessageIn           []string `json:"primarymessageIn,omitempty"`
	PrimaryMessageNotIn        []string `json:"primarymessageNotIn,omitempty"`
	PrimaryMessageGT           *string  `json:"primarymessageGT,omitempty"`
	PrimaryMessageGTE          *string  `json:"primarymessageGTE,omitempty"`
	PrimaryMessageLT           *string  `json:"primarymessageLT,omitempty"`
	PrimaryMessageLTE          *string  `json:"primarymessageLTE,omitempty"`
	PrimaryMessageContains     *string  `json:"primarymessageContains,omitempty"`
	PrimaryMessageHasPrefix    *string  `json:"primarymessageHasPrefix,omitempty"`
	PrimaryMessageHasSuffix    *string  `json:"primarymessageHasSuffix,omitempty"`
	PrimaryMessageEqualFold    *string  `json:"primarymessageEqualFold,omitempty"`
	PrimaryMessageContainsFold *string  `json:"primarymessageContainsFold,omitempty"`

	// "secondaryMessage" field predicates.
	SecondaryMessage             *string  `json:"secondarymessage,omitempty"`
	SecondaryMessageNEQ          *string  `json:"secondarymessageNEQ,omitempty"`
	SecondaryMessageIn           []string `json:"secondarymessageIn,omitempty"`
	SecondaryMessageNotIn        []string `json:"secondarymessageNotIn,omitempty"`
	SecondaryMessageGT           *string  `json:"secondarymessageGT,omitempty"`
	SecondaryMessageGTE          *string  `json:"secondarymessageGTE,omitempty"`
	SecondaryMessageLT           *string  `json:"secondarymessageLT,omitempty"`
	SecondaryMessageLTE          *string  `json:"secondarymessageLTE,omitempty"`
	SecondaryMessageContains     *string  `json:"secondarymessageContains,omitempty"`
	SecondaryMessageHasPrefix    *string  `json:"secondarymessageHasPrefix,omitempty"`
	SecondaryMessageHasSuffix    *string  `json:"secondarymessageHasSuffix,omitempty"`
	SecondaryMessageEqualFold    *string  `json:"secondarymessageEqualFold,omitempty"`
	SecondaryMessageContainsFold *string  `json:"secondarymessageContainsFold,omitempty"`

	// "image" edge predicates.
	HasImage     *bool              `json:"hasImage,omitempty"`
	HasImageWith []*ImageWhereInput `json:"hasImageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContentBlockWhereInput) AddPredicates(predicates ...predicate.ContentBlock) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContentBlockWhereInput filter on the ContentBlockQuery builder.
func (i *ContentBlockWhereInput) Filter(q *ContentBlockQuery) (*ContentBlockQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContentBlockWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContentBlockWhereInput is returned in case the ContentBlockWhereInput is empty.
var ErrEmptyContentBlockWhereInput = errors.New("ent: empty predicate ContentBlockWhereInput")

// P returns a predicate for filtering contentblocks.
// An error is returned if the input is empty or invalid.
func (i *ContentBlockWhereInput) P() (predicate.ContentBlock, error) {
	var predicates []predicate.ContentBlock
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contentblock.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ContentBlock, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contentblock.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ContentBlock, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contentblock.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contentblock.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contentblock.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contentblock.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contentblock.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contentblock.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contentblock.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contentblock.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contentblock.IDLTE(*i.IDLTE))
	}
	if i.PrimaryMessage != nil {
		predicates = append(predicates, contentblock.PrimaryMessageEQ(*i.PrimaryMessage))
	}
	if i.PrimaryMessageNEQ != nil {
		predicates = append(predicates, contentblock.PrimaryMessageNEQ(*i.PrimaryMessageNEQ))
	}
	if len(i.PrimaryMessageIn) > 0 {
		predicates = append(predicates, contentblock.PrimaryMessageIn(i.PrimaryMessageIn...))
	}
	if len(i.PrimaryMessageNotIn) > 0 {
		predicates = append(predicates, contentblock.PrimaryMessageNotIn(i.PrimaryMessageNotIn...))
	}
	if i.PrimaryMessageGT != nil {
		predicates = append(predicates, contentblock.PrimaryMessageGT(*i.PrimaryMessageGT))
	}
	if i.PrimaryMessageGTE != nil {
		predicates = append(predicates, contentblock.PrimaryMessageGTE(*i.PrimaryMessageGTE))
	}
	if i.PrimaryMessageLT != nil {
		predicates = append(predicates, contentblock.PrimaryMessageLT(*i.PrimaryMessageLT))
	}
	if i.PrimaryMessageLTE != nil {
		predicates = append(predicates, contentblock.PrimaryMessageLTE(*i.PrimaryMessageLTE))
	}
	if i.PrimaryMessageContains != nil {
		predicates = append(predicates, contentblock.PrimaryMessageContains(*i.PrimaryMessageContains))
	}
	if i.PrimaryMessageHasPrefix != nil {
		predicates = append(predicates, contentblock.PrimaryMessageHasPrefix(*i.PrimaryMessageHasPrefix))
	}
	if i.PrimaryMessageHasSuffix != nil {
		predicates = append(predicates, contentblock.PrimaryMessageHasSuffix(*i.PrimaryMessageHasSuffix))
	}
	if i.PrimaryMessageEqualFold != nil {
		predicates = append(predicates, contentblock.PrimaryMessageEqualFold(*i.PrimaryMessageEqualFold))
	}
	if i.PrimaryMessageContainsFold != nil {
		predicates = append(predicates, contentblock.PrimaryMessageContainsFold(*i.PrimaryMessageContainsFold))
	}
	if i.SecondaryMessage != nil {
		predicates = append(predicates, contentblock.SecondaryMessageEQ(*i.SecondaryMessage))
	}
	if i.SecondaryMessageNEQ != nil {
		predicates = append(predicates, contentblock.SecondaryMessageNEQ(*i.SecondaryMessageNEQ))
	}
	if len(i.SecondaryMessageIn) > 0 {
		predicates = append(predicates, contentblock.SecondaryMessageIn(i.SecondaryMessageIn...))
	}
	if len(i.SecondaryMessageNotIn) > 0 {
		predicates = append(predicates, contentblock.SecondaryMessageNotIn(i.SecondaryMessageNotIn...))
	}
	if i.SecondaryMessageGT != nil {
		predicates = append(predicates, contentblock.SecondaryMessageGT(*i.SecondaryMessageGT))
	}
	if i.SecondaryMessageGTE != nil {
		predicates = append(predicates, contentblock.SecondaryMessageGTE(*i.SecondaryMessageGTE))
	}
	if i.SecondaryMessageLT != nil {
		predicates = append(predicates, contentblock.SecondaryMessageLT(*i.SecondaryMessageLT))
	}
	if i.SecondaryMessageLTE != nil {
		predicates = append(predicates, contentblock.SecondaryMessageLTE(*i.SecondaryMessageLTE))
	}
	if i.SecondaryMessageContains != nil {
		predicates = append(predicates, contentblock.SecondaryMessageContains(*i.SecondaryMessageContains))
	}
	if i.SecondaryMessageHasPrefix != nil {
		predicates = append(predicates, contentblock.SecondaryMessageHasPrefix(*i.SecondaryMessageHasPrefix))
	}
	if i.SecondaryMessageHasSuffix != nil {
		predicates = append(predicates, contentblock.SecondaryMessageHasSuffix(*i.SecondaryMessageHasSuffix))
	}
	if i.SecondaryMessageEqualFold != nil {
		predicates = append(predicates, contentblock.SecondaryMessageEqualFold(*i.SecondaryMessageEqualFold))
	}
	if i.SecondaryMessageContainsFold != nil {
		predicates = append(predicates, contentblock.SecondaryMessageContainsFold(*i.SecondaryMessageContainsFold))
	}

	if i.HasImage != nil {
		p := contentblock.HasImage()
		if !*i.HasImage {
			p = contentblock.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImageWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasImageWith))
		for _, w := range i.HasImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contentblock.HasImageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContentBlockWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contentblock.And(predicates...), nil
	}
}

// EmailCampaignWhereInput represents a where input for filtering EmailCampaign queries.
type EmailCampaignWhereInput struct {
	Predicates []predicate.EmailCampaign  `json:"-"`
	Not        *EmailCampaignWhereInput   `json:"not,omitempty"`
	Or         []*EmailCampaignWhereInput `json:"or,omitempty"`
	And        []*EmailCampaignWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "xid" field predicates.
	Xid      *int  `json:"xid,omitempty"`
	XidNEQ   *int  `json:"xidNEQ,omitempty"`
	XidIn    []int `json:"xidIn,omitempty"`
	XidNotIn []int `json:"xidNotIn,omitempty"`
	XidGT    *int  `json:"xidGT,omitempty"`
	XidGTE   *int  `json:"xidGTE,omitempty"`
	XidLT    *int  `json:"xidLT,omitempty"`
	XidLTE   *int  `json:"xidLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmailCampaignWhereInput) AddPredicates(predicates ...predicate.EmailCampaign) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmailCampaignWhereInput filter on the EmailCampaignQuery builder.
func (i *EmailCampaignWhereInput) Filter(q *EmailCampaignQuery) (*EmailCampaignQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmailCampaignWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmailCampaignWhereInput is returned in case the EmailCampaignWhereInput is empty.
var ErrEmptyEmailCampaignWhereInput = errors.New("ent: empty predicate EmailCampaignWhereInput")

// P returns a predicate for filtering emailcampaigns.
// An error is returned if the input is empty or invalid.
func (i *EmailCampaignWhereInput) P() (predicate.EmailCampaign, error) {
	var predicates []predicate.EmailCampaign
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, emailcampaign.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EmailCampaign, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, emailcampaign.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EmailCampaign, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, emailcampaign.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, emailcampaign.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, emailcampaign.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, emailcampaign.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, emailcampaign.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, emailcampaign.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, emailcampaign.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, emailcampaign.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, emailcampaign.IDLTE(*i.IDLTE))
	}
	if i.Xid != nil {
		predicates = append(predicates, emailcampaign.XidEQ(*i.Xid))
	}
	if i.XidNEQ != nil {
		predicates = append(predicates, emailcampaign.XidNEQ(*i.XidNEQ))
	}
	if len(i.XidIn) > 0 {
		predicates = append(predicates, emailcampaign.XidIn(i.XidIn...))
	}
	if len(i.XidNotIn) > 0 {
		predicates = append(predicates, emailcampaign.XidNotIn(i.XidNotIn...))
	}
	if i.XidGT != nil {
		predicates = append(predicates, emailcampaign.XidGT(*i.XidGT))
	}
	if i.XidGTE != nil {
		predicates = append(predicates, emailcampaign.XidGTE(*i.XidGTE))
	}
	if i.XidLT != nil {
		predicates = append(predicates, emailcampaign.XidLT(*i.XidLT))
	}
	if i.XidLTE != nil {
		predicates = append(predicates, emailcampaign.XidLTE(*i.XidLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmailCampaignWhereInput
	case 1:
		return predicates[0], nil
	default:
		return emailcampaign.And(predicates...), nil
	}
}

// GroupWhereInput represents a where input for filtering Group queries.
type GroupWhereInput struct {
	Predicates []predicate.Group  `json:"-"`
	Not        *GroupWhereInput   `json:"not,omitempty"`
	Or         []*GroupWhereInput `json:"or,omitempty"`
	And        []*GroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupWhereInput) AddPredicates(predicates ...predicate.Group) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupWhereInput filter on the GroupQuery builder.
func (i *GroupWhereInput) Filter(q *GroupQuery) (*GroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupWhereInput is returned in case the GroupWhereInput is empty.
var ErrEmptyGroupWhereInput = errors.New("ent: empty predicate GroupWhereInput")

// P returns a predicate for filtering groups.
// An error is returned if the input is empty or invalid.
func (i *GroupWhereInput) P() (predicate.Group, error) {
	var predicates []predicate.Group
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, group.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Group, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, group.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Group, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, group.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, group.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, group.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, group.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, group.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, group.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, group.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, group.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, group.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, group.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, group.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, group.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, group.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, group.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, group.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, group.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, group.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, group.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, group.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, group.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, group.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, group.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return group.And(predicates...), nil
	}
}

// GroupBuyWhereInput represents a where input for filtering GroupBuy queries.
type GroupBuyWhereInput struct {
	Predicates []predicate.GroupBuy  `json:"-"`
	Not        *GroupBuyWhereInput   `json:"not,omitempty"`
	Or         []*GroupBuyWhereInput `json:"or,omitempty"`
	And        []*GroupBuyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "productPrice" field predicates.
	ProductPrice      *int  `json:"productprice,omitempty"`
	ProductPriceNEQ   *int  `json:"productpriceNEQ,omitempty"`
	ProductPriceIn    []int `json:"productpriceIn,omitempty"`
	ProductPriceNotIn []int `json:"productpriceNotIn,omitempty"`
	ProductPriceGT    *int  `json:"productpriceGT,omitempty"`
	ProductPriceGTE   *int  `json:"productpriceGTE,omitempty"`
	ProductPriceLT    *int  `json:"productpriceLT,omitempty"`
	ProductPriceLTE   *int  `json:"productpriceLTE,omitempty"`

	// "moq" field predicates.
	Moq      *int  `json:"moq,omitempty"`
	MoqNEQ   *int  `json:"moqNEQ,omitempty"`
	MoqIn    []int `json:"moqIn,omitempty"`
	MoqNotIn []int `json:"moqNotIn,omitempty"`
	MoqGT    *int  `json:"moqGT,omitempty"`
	MoqGTE   *int  `json:"moqGTE,omitempty"`
	MoqLT    *int  `json:"moqLT,omitempty"`
	MoqLTE   *int  `json:"moqLTE,omitempty"`

	// "startDate" field predicates.
	StartDate             *string  `json:"startdate,omitempty"`
	StartDateNEQ          *string  `json:"startdateNEQ,omitempty"`
	StartDateIn           []string `json:"startdateIn,omitempty"`
	StartDateNotIn        []string `json:"startdateNotIn,omitempty"`
	StartDateGT           *string  `json:"startdateGT,omitempty"`
	StartDateGTE          *string  `json:"startdateGTE,omitempty"`
	StartDateLT           *string  `json:"startdateLT,omitempty"`
	StartDateLTE          *string  `json:"startdateLTE,omitempty"`
	StartDateContains     *string  `json:"startdateContains,omitempty"`
	StartDateHasPrefix    *string  `json:"startdateHasPrefix,omitempty"`
	StartDateHasSuffix    *string  `json:"startdateHasSuffix,omitempty"`
	StartDateEqualFold    *string  `json:"startdateEqualFold,omitempty"`
	StartDateContainsFold *string  `json:"startdateContainsFold,omitempty"`

	// "endDate" field predicates.
	EndDate             *string  `json:"enddate,omitempty"`
	EndDateNEQ          *string  `json:"enddateNEQ,omitempty"`
	EndDateIn           []string `json:"enddateIn,omitempty"`
	EndDateNotIn        []string `json:"enddateNotIn,omitempty"`
	EndDateGT           *string  `json:"enddateGT,omitempty"`
	EndDateGTE          *string  `json:"enddateGTE,omitempty"`
	EndDateLT           *string  `json:"enddateLT,omitempty"`
	EndDateLTE          *string  `json:"enddateLTE,omitempty"`
	EndDateContains     *string  `json:"enddateContains,omitempty"`
	EndDateHasPrefix    *string  `json:"enddateHasPrefix,omitempty"`
	EndDateHasSuffix    *string  `json:"enddateHasSuffix,omitempty"`
	EndDateEqualFold    *string  `json:"enddateEqualFold,omitempty"`
	EndDateContainsFold *string  `json:"enddateContainsFold,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "transaction" edge predicates.
	HasTransaction     *bool                    `json:"hasTransaction,omitempty"`
	HasTransactionWith []*TransactionWhereInput `json:"hasTransactionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupBuyWhereInput) AddPredicates(predicates ...predicate.GroupBuy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupBuyWhereInput filter on the GroupBuyQuery builder.
func (i *GroupBuyWhereInput) Filter(q *GroupBuyQuery) (*GroupBuyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupBuyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupBuyWhereInput is returned in case the GroupBuyWhereInput is empty.
var ErrEmptyGroupBuyWhereInput = errors.New("ent: empty predicate GroupBuyWhereInput")

// P returns a predicate for filtering groupbuys.
// An error is returned if the input is empty or invalid.
func (i *GroupBuyWhereInput) P() (predicate.GroupBuy, error) {
	var predicates []predicate.GroupBuy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupbuy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupBuy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupbuy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupBuy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupbuy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupbuy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupbuy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupbuy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupbuy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupbuy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupbuy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupbuy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupbuy.IDLTE(*i.IDLTE))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, groupbuy.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, groupbuy.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, groupbuy.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, groupbuy.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, groupbuy.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, groupbuy.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, groupbuy.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, groupbuy.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, groupbuy.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, groupbuy.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, groupbuy.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, groupbuy.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, groupbuy.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.ProductPrice != nil {
		predicates = append(predicates, groupbuy.ProductPriceEQ(*i.ProductPrice))
	}
	if i.ProductPriceNEQ != nil {
		predicates = append(predicates, groupbuy.ProductPriceNEQ(*i.ProductPriceNEQ))
	}
	if len(i.ProductPriceIn) > 0 {
		predicates = append(predicates, groupbuy.ProductPriceIn(i.ProductPriceIn...))
	}
	if len(i.ProductPriceNotIn) > 0 {
		predicates = append(predicates, groupbuy.ProductPriceNotIn(i.ProductPriceNotIn...))
	}
	if i.ProductPriceGT != nil {
		predicates = append(predicates, groupbuy.ProductPriceGT(*i.ProductPriceGT))
	}
	if i.ProductPriceGTE != nil {
		predicates = append(predicates, groupbuy.ProductPriceGTE(*i.ProductPriceGTE))
	}
	if i.ProductPriceLT != nil {
		predicates = append(predicates, groupbuy.ProductPriceLT(*i.ProductPriceLT))
	}
	if i.ProductPriceLTE != nil {
		predicates = append(predicates, groupbuy.ProductPriceLTE(*i.ProductPriceLTE))
	}
	if i.Moq != nil {
		predicates = append(predicates, groupbuy.MoqEQ(*i.Moq))
	}
	if i.MoqNEQ != nil {
		predicates = append(predicates, groupbuy.MoqNEQ(*i.MoqNEQ))
	}
	if len(i.MoqIn) > 0 {
		predicates = append(predicates, groupbuy.MoqIn(i.MoqIn...))
	}
	if len(i.MoqNotIn) > 0 {
		predicates = append(predicates, groupbuy.MoqNotIn(i.MoqNotIn...))
	}
	if i.MoqGT != nil {
		predicates = append(predicates, groupbuy.MoqGT(*i.MoqGT))
	}
	if i.MoqGTE != nil {
		predicates = append(predicates, groupbuy.MoqGTE(*i.MoqGTE))
	}
	if i.MoqLT != nil {
		predicates = append(predicates, groupbuy.MoqLT(*i.MoqLT))
	}
	if i.MoqLTE != nil {
		predicates = append(predicates, groupbuy.MoqLTE(*i.MoqLTE))
	}
	if i.StartDate != nil {
		predicates = append(predicates, groupbuy.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, groupbuy.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, groupbuy.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, groupbuy.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, groupbuy.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, groupbuy.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, groupbuy.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, groupbuy.StartDateLTE(*i.StartDateLTE))
	}
	if i.StartDateContains != nil {
		predicates = append(predicates, groupbuy.StartDateContains(*i.StartDateContains))
	}
	if i.StartDateHasPrefix != nil {
		predicates = append(predicates, groupbuy.StartDateHasPrefix(*i.StartDateHasPrefix))
	}
	if i.StartDateHasSuffix != nil {
		predicates = append(predicates, groupbuy.StartDateHasSuffix(*i.StartDateHasSuffix))
	}
	if i.StartDateEqualFold != nil {
		predicates = append(predicates, groupbuy.StartDateEqualFold(*i.StartDateEqualFold))
	}
	if i.StartDateContainsFold != nil {
		predicates = append(predicates, groupbuy.StartDateContainsFold(*i.StartDateContainsFold))
	}
	if i.EndDate != nil {
		predicates = append(predicates, groupbuy.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, groupbuy.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, groupbuy.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, groupbuy.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, groupbuy.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, groupbuy.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, groupbuy.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, groupbuy.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateContains != nil {
		predicates = append(predicates, groupbuy.EndDateContains(*i.EndDateContains))
	}
	if i.EndDateHasPrefix != nil {
		predicates = append(predicates, groupbuy.EndDateHasPrefix(*i.EndDateHasPrefix))
	}
	if i.EndDateHasSuffix != nil {
		predicates = append(predicates, groupbuy.EndDateHasSuffix(*i.EndDateHasSuffix))
	}
	if i.EndDateEqualFold != nil {
		predicates = append(predicates, groupbuy.EndDateEqualFold(*i.EndDateEqualFold))
	}
	if i.EndDateContainsFold != nil {
		predicates = append(predicates, groupbuy.EndDateContainsFold(*i.EndDateContainsFold))
	}

	if i.HasProduct != nil {
		p := groupbuy.HasProduct()
		if !*i.HasProduct {
			p = groupbuy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupbuy.HasProductWith(with...))
	}
	if i.HasTransaction != nil {
		p := groupbuy.HasTransaction()
		if !*i.HasTransaction {
			p = groupbuy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionWith))
		for _, w := range i.HasTransactionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, groupbuy.HasTransactionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupBuyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupbuy.And(predicates...), nil
	}
}

// HeroContentWhereInput represents a where input for filtering HeroContent queries.
type HeroContentWhereInput struct {
	Predicates []predicate.HeroContent  `json:"-"`
	Not        *HeroContentWhereInput   `json:"not,omitempty"`
	Or         []*HeroContentWhereInput `json:"or,omitempty"`
	And        []*HeroContentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "primaryMessage" field predicates.
	PrimaryMessage             *string  `json:"primarymessage,omitempty"`
	PrimaryMessageNEQ          *string  `json:"primarymessageNEQ,omitempty"`
	PrimaryMessageIn           []string `json:"primarymessageIn,omitempty"`
	PrimaryMessageNotIn        []string `json:"primarymessageNotIn,omitempty"`
	PrimaryMessageGT           *string  `json:"primarymessageGT,omitempty"`
	PrimaryMessageGTE          *string  `json:"primarymessageGTE,omitempty"`
	PrimaryMessageLT           *string  `json:"primarymessageLT,omitempty"`
	PrimaryMessageLTE          *string  `json:"primarymessageLTE,omitempty"`
	PrimaryMessageContains     *string  `json:"primarymessageContains,omitempty"`
	PrimaryMessageHasPrefix    *string  `json:"primarymessageHasPrefix,omitempty"`
	PrimaryMessageHasSuffix    *string  `json:"primarymessageHasSuffix,omitempty"`
	PrimaryMessageEqualFold    *string  `json:"primarymessageEqualFold,omitempty"`
	PrimaryMessageContainsFold *string  `json:"primarymessageContainsFold,omitempty"`

	// "secondaryMessage" field predicates.
	SecondaryMessage             *string  `json:"secondarymessage,omitempty"`
	SecondaryMessageNEQ          *string  `json:"secondarymessageNEQ,omitempty"`
	SecondaryMessageIn           []string `json:"secondarymessageIn,omitempty"`
	SecondaryMessageNotIn        []string `json:"secondarymessageNotIn,omitempty"`
	SecondaryMessageGT           *string  `json:"secondarymessageGT,omitempty"`
	SecondaryMessageGTE          *string  `json:"secondarymessageGTE,omitempty"`
	SecondaryMessageLT           *string  `json:"secondarymessageLT,omitempty"`
	SecondaryMessageLTE          *string  `json:"secondarymessageLTE,omitempty"`
	SecondaryMessageContains     *string  `json:"secondarymessageContains,omitempty"`
	SecondaryMessageHasPrefix    *string  `json:"secondarymessageHasPrefix,omitempty"`
	SecondaryMessageHasSuffix    *string  `json:"secondarymessageHasSuffix,omitempty"`
	SecondaryMessageEqualFold    *string  `json:"secondarymessageEqualFold,omitempty"`
	SecondaryMessageContainsFold *string  `json:"secondarymessageContainsFold,omitempty"`

	// "image" edge predicates.
	HasImage     *bool              `json:"hasImage,omitempty"`
	HasImageWith []*ImageWhereInput `json:"hasImageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HeroContentWhereInput) AddPredicates(predicates ...predicate.HeroContent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HeroContentWhereInput filter on the HeroContentQuery builder.
func (i *HeroContentWhereInput) Filter(q *HeroContentQuery) (*HeroContentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHeroContentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHeroContentWhereInput is returned in case the HeroContentWhereInput is empty.
var ErrEmptyHeroContentWhereInput = errors.New("ent: empty predicate HeroContentWhereInput")

// P returns a predicate for filtering herocontents.
// An error is returned if the input is empty or invalid.
func (i *HeroContentWhereInput) P() (predicate.HeroContent, error) {
	var predicates []predicate.HeroContent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, herocontent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HeroContent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, herocontent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HeroContent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, herocontent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, herocontent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, herocontent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, herocontent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, herocontent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, herocontent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, herocontent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, herocontent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, herocontent.IDLTE(*i.IDLTE))
	}
	if i.PrimaryMessage != nil {
		predicates = append(predicates, herocontent.PrimaryMessageEQ(*i.PrimaryMessage))
	}
	if i.PrimaryMessageNEQ != nil {
		predicates = append(predicates, herocontent.PrimaryMessageNEQ(*i.PrimaryMessageNEQ))
	}
	if len(i.PrimaryMessageIn) > 0 {
		predicates = append(predicates, herocontent.PrimaryMessageIn(i.PrimaryMessageIn...))
	}
	if len(i.PrimaryMessageNotIn) > 0 {
		predicates = append(predicates, herocontent.PrimaryMessageNotIn(i.PrimaryMessageNotIn...))
	}
	if i.PrimaryMessageGT != nil {
		predicates = append(predicates, herocontent.PrimaryMessageGT(*i.PrimaryMessageGT))
	}
	if i.PrimaryMessageGTE != nil {
		predicates = append(predicates, herocontent.PrimaryMessageGTE(*i.PrimaryMessageGTE))
	}
	if i.PrimaryMessageLT != nil {
		predicates = append(predicates, herocontent.PrimaryMessageLT(*i.PrimaryMessageLT))
	}
	if i.PrimaryMessageLTE != nil {
		predicates = append(predicates, herocontent.PrimaryMessageLTE(*i.PrimaryMessageLTE))
	}
	if i.PrimaryMessageContains != nil {
		predicates = append(predicates, herocontent.PrimaryMessageContains(*i.PrimaryMessageContains))
	}
	if i.PrimaryMessageHasPrefix != nil {
		predicates = append(predicates, herocontent.PrimaryMessageHasPrefix(*i.PrimaryMessageHasPrefix))
	}
	if i.PrimaryMessageHasSuffix != nil {
		predicates = append(predicates, herocontent.PrimaryMessageHasSuffix(*i.PrimaryMessageHasSuffix))
	}
	if i.PrimaryMessageEqualFold != nil {
		predicates = append(predicates, herocontent.PrimaryMessageEqualFold(*i.PrimaryMessageEqualFold))
	}
	if i.PrimaryMessageContainsFold != nil {
		predicates = append(predicates, herocontent.PrimaryMessageContainsFold(*i.PrimaryMessageContainsFold))
	}
	if i.SecondaryMessage != nil {
		predicates = append(predicates, herocontent.SecondaryMessageEQ(*i.SecondaryMessage))
	}
	if i.SecondaryMessageNEQ != nil {
		predicates = append(predicates, herocontent.SecondaryMessageNEQ(*i.SecondaryMessageNEQ))
	}
	if len(i.SecondaryMessageIn) > 0 {
		predicates = append(predicates, herocontent.SecondaryMessageIn(i.SecondaryMessageIn...))
	}
	if len(i.SecondaryMessageNotIn) > 0 {
		predicates = append(predicates, herocontent.SecondaryMessageNotIn(i.SecondaryMessageNotIn...))
	}
	if i.SecondaryMessageGT != nil {
		predicates = append(predicates, herocontent.SecondaryMessageGT(*i.SecondaryMessageGT))
	}
	if i.SecondaryMessageGTE != nil {
		predicates = append(predicates, herocontent.SecondaryMessageGTE(*i.SecondaryMessageGTE))
	}
	if i.SecondaryMessageLT != nil {
		predicates = append(predicates, herocontent.SecondaryMessageLT(*i.SecondaryMessageLT))
	}
	if i.SecondaryMessageLTE != nil {
		predicates = append(predicates, herocontent.SecondaryMessageLTE(*i.SecondaryMessageLTE))
	}
	if i.SecondaryMessageContains != nil {
		predicates = append(predicates, herocontent.SecondaryMessageContains(*i.SecondaryMessageContains))
	}
	if i.SecondaryMessageHasPrefix != nil {
		predicates = append(predicates, herocontent.SecondaryMessageHasPrefix(*i.SecondaryMessageHasPrefix))
	}
	if i.SecondaryMessageHasSuffix != nil {
		predicates = append(predicates, herocontent.SecondaryMessageHasSuffix(*i.SecondaryMessageHasSuffix))
	}
	if i.SecondaryMessageEqualFold != nil {
		predicates = append(predicates, herocontent.SecondaryMessageEqualFold(*i.SecondaryMessageEqualFold))
	}
	if i.SecondaryMessageContainsFold != nil {
		predicates = append(predicates, herocontent.SecondaryMessageContainsFold(*i.SecondaryMessageContainsFold))
	}

	if i.HasImage != nil {
		p := herocontent.HasImage()
		if !*i.HasImage {
			p = herocontent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImageWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasImageWith))
		for _, w := range i.HasImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, herocontent.HasImageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHeroContentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return herocontent.And(predicates...), nil
	}
}

// ImageWhereInput represents a where input for filtering Image queries.
type ImageWhereInput struct {
	Predicates []predicate.Image  `json:"-"`
	Not        *ImageWhereInput   `json:"not,omitempty"`
	Or         []*ImageWhereInput `json:"or,omitempty"`
	And        []*ImageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ImageWhereInput) AddPredicates(predicates ...predicate.Image) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ImageWhereInput filter on the ImageQuery builder.
func (i *ImageWhereInput) Filter(q *ImageQuery) (*ImageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyImageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyImageWhereInput is returned in case the ImageWhereInput is empty.
var ErrEmptyImageWhereInput = errors.New("ent: empty predicate ImageWhereInput")

// P returns a predicate for filtering images.
// An error is returned if the input is empty or invalid.
func (i *ImageWhereInput) P() (predicate.Image, error) {
	var predicates []predicate.Image
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, image.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Image, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, image.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Image, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, image.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, image.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, image.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, image.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, image.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, image.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, image.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, image.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, image.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, image.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, image.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, image.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, image.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, image.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, image.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, image.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, image.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, image.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, image.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, image.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, image.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, image.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, image.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, image.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, image.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, image.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, image.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, image.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, image.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, image.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, image.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, image.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, image.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, image.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, image.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, image.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, image.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, image.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, image.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, image.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, image.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, image.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, image.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, image.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, image.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, image.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, image.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, image.URLContainsFold(*i.URLContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyImageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return image.And(predicates...), nil
	}
}

// LinkVisitWhereInput represents a where input for filtering LinkVisit queries.
type LinkVisitWhereInput struct {
	Predicates []predicate.LinkVisit  `json:"-"`
	Not        *LinkVisitWhereInput   `json:"not,omitempty"`
	Or         []*LinkVisitWhereInput `json:"or,omitempty"`
	And        []*LinkVisitWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "ipAddress" field predicates.
	IpAddress             *string  `json:"ipaddress,omitempty"`
	IpAddressNEQ          *string  `json:"ipaddressNEQ,omitempty"`
	IpAddressIn           []string `json:"ipaddressIn,omitempty"`
	IpAddressNotIn        []string `json:"ipaddressNotIn,omitempty"`
	IpAddressGT           *string  `json:"ipaddressGT,omitempty"`
	IpAddressGTE          *string  `json:"ipaddressGTE,omitempty"`
	IpAddressLT           *string  `json:"ipaddressLT,omitempty"`
	IpAddressLTE          *string  `json:"ipaddressLTE,omitempty"`
	IpAddressContains     *string  `json:"ipaddressContains,omitempty"`
	IpAddressHasPrefix    *string  `json:"ipaddressHasPrefix,omitempty"`
	IpAddressHasSuffix    *string  `json:"ipaddressHasSuffix,omitempty"`
	IpAddressEqualFold    *string  `json:"ipaddressEqualFold,omitempty"`
	IpAddressContainsFold *string  `json:"ipaddressContainsFold,omitempty"`

	// "saleValue" field predicates.
	SaleValue      *int  `json:"salevalue,omitempty"`
	SaleValueNEQ   *int  `json:"salevalueNEQ,omitempty"`
	SaleValueIn    []int `json:"salevalueIn,omitempty"`
	SaleValueNotIn []int `json:"salevalueNotIn,omitempty"`
	SaleValueGT    *int  `json:"salevalueGT,omitempty"`
	SaleValueGTE   *int  `json:"salevalueGTE,omitempty"`
	SaleValueLT    *int  `json:"salevalueLT,omitempty"`
	SaleValueLTE   *int  `json:"salevalueLTE,omitempty"`

	// "commissionEarned" field predicates.
	CommissionEarned      *int  `json:"commissionearned,omitempty"`
	CommissionEarnedNEQ   *int  `json:"commissionearnedNEQ,omitempty"`
	CommissionEarnedIn    []int `json:"commissionearnedIn,omitempty"`
	CommissionEarnedNotIn []int `json:"commissionearnedNotIn,omitempty"`
	CommissionEarnedGT    *int  `json:"commissionearnedGT,omitempty"`
	CommissionEarnedGTE   *int  `json:"commissionearnedGTE,omitempty"`
	CommissionEarnedLT    *int  `json:"commissionearnedLT,omitempty"`
	CommissionEarnedLTE   *int  `json:"commissionearnedLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LinkVisitWhereInput) AddPredicates(predicates ...predicate.LinkVisit) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LinkVisitWhereInput filter on the LinkVisitQuery builder.
func (i *LinkVisitWhereInput) Filter(q *LinkVisitQuery) (*LinkVisitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLinkVisitWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLinkVisitWhereInput is returned in case the LinkVisitWhereInput is empty.
var ErrEmptyLinkVisitWhereInput = errors.New("ent: empty predicate LinkVisitWhereInput")

// P returns a predicate for filtering linkvisits.
// An error is returned if the input is empty or invalid.
func (i *LinkVisitWhereInput) P() (predicate.LinkVisit, error) {
	var predicates []predicate.LinkVisit
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, linkvisit.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.LinkVisit, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, linkvisit.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.LinkVisit, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, linkvisit.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, linkvisit.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, linkvisit.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, linkvisit.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, linkvisit.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, linkvisit.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, linkvisit.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, linkvisit.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, linkvisit.IDLTE(*i.IDLTE))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, linkvisit.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, linkvisit.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, linkvisit.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, linkvisit.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, linkvisit.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, linkvisit.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, linkvisit.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, linkvisit.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, linkvisit.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, linkvisit.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, linkvisit.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, linkvisit.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, linkvisit.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.IpAddress != nil {
		predicates = append(predicates, linkvisit.IpAddressEQ(*i.IpAddress))
	}
	if i.IpAddressNEQ != nil {
		predicates = append(predicates, linkvisit.IpAddressNEQ(*i.IpAddressNEQ))
	}
	if len(i.IpAddressIn) > 0 {
		predicates = append(predicates, linkvisit.IpAddressIn(i.IpAddressIn...))
	}
	if len(i.IpAddressNotIn) > 0 {
		predicates = append(predicates, linkvisit.IpAddressNotIn(i.IpAddressNotIn...))
	}
	if i.IpAddressGT != nil {
		predicates = append(predicates, linkvisit.IpAddressGT(*i.IpAddressGT))
	}
	if i.IpAddressGTE != nil {
		predicates = append(predicates, linkvisit.IpAddressGTE(*i.IpAddressGTE))
	}
	if i.IpAddressLT != nil {
		predicates = append(predicates, linkvisit.IpAddressLT(*i.IpAddressLT))
	}
	if i.IpAddressLTE != nil {
		predicates = append(predicates, linkvisit.IpAddressLTE(*i.IpAddressLTE))
	}
	if i.IpAddressContains != nil {
		predicates = append(predicates, linkvisit.IpAddressContains(*i.IpAddressContains))
	}
	if i.IpAddressHasPrefix != nil {
		predicates = append(predicates, linkvisit.IpAddressHasPrefix(*i.IpAddressHasPrefix))
	}
	if i.IpAddressHasSuffix != nil {
		predicates = append(predicates, linkvisit.IpAddressHasSuffix(*i.IpAddressHasSuffix))
	}
	if i.IpAddressEqualFold != nil {
		predicates = append(predicates, linkvisit.IpAddressEqualFold(*i.IpAddressEqualFold))
	}
	if i.IpAddressContainsFold != nil {
		predicates = append(predicates, linkvisit.IpAddressContainsFold(*i.IpAddressContainsFold))
	}
	if i.SaleValue != nil {
		predicates = append(predicates, linkvisit.SaleValueEQ(*i.SaleValue))
	}
	if i.SaleValueNEQ != nil {
		predicates = append(predicates, linkvisit.SaleValueNEQ(*i.SaleValueNEQ))
	}
	if len(i.SaleValueIn) > 0 {
		predicates = append(predicates, linkvisit.SaleValueIn(i.SaleValueIn...))
	}
	if len(i.SaleValueNotIn) > 0 {
		predicates = append(predicates, linkvisit.SaleValueNotIn(i.SaleValueNotIn...))
	}
	if i.SaleValueGT != nil {
		predicates = append(predicates, linkvisit.SaleValueGT(*i.SaleValueGT))
	}
	if i.SaleValueGTE != nil {
		predicates = append(predicates, linkvisit.SaleValueGTE(*i.SaleValueGTE))
	}
	if i.SaleValueLT != nil {
		predicates = append(predicates, linkvisit.SaleValueLT(*i.SaleValueLT))
	}
	if i.SaleValueLTE != nil {
		predicates = append(predicates, linkvisit.SaleValueLTE(*i.SaleValueLTE))
	}
	if i.CommissionEarned != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedEQ(*i.CommissionEarned))
	}
	if i.CommissionEarnedNEQ != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedNEQ(*i.CommissionEarnedNEQ))
	}
	if len(i.CommissionEarnedIn) > 0 {
		predicates = append(predicates, linkvisit.CommissionEarnedIn(i.CommissionEarnedIn...))
	}
	if len(i.CommissionEarnedNotIn) > 0 {
		predicates = append(predicates, linkvisit.CommissionEarnedNotIn(i.CommissionEarnedNotIn...))
	}
	if i.CommissionEarnedGT != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedGT(*i.CommissionEarnedGT))
	}
	if i.CommissionEarnedGTE != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedGTE(*i.CommissionEarnedGTE))
	}
	if i.CommissionEarnedLT != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedLT(*i.CommissionEarnedLT))
	}
	if i.CommissionEarnedLTE != nil {
		predicates = append(predicates, linkvisit.CommissionEarnedLTE(*i.CommissionEarnedLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLinkVisitWhereInput
	case 1:
		return predicates[0], nil
	default:
		return linkvisit.And(predicates...), nil
	}
}

// MarketingCampaignWhereInput represents a where input for filtering MarketingCampaign queries.
type MarketingCampaignWhereInput struct {
	Predicates []predicate.MarketingCampaign  `json:"-"`
	Not        *MarketingCampaignWhereInput   `json:"not,omitempty"`
	Or         []*MarketingCampaignWhereInput `json:"or,omitempty"`
	And        []*MarketingCampaignWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "consumerPurchaseValue" field predicates.
	ConsumerPurchaseValue             *string  `json:"consumerpurchasevalue,omitempty"`
	ConsumerPurchaseValueNEQ          *string  `json:"consumerpurchasevalueNEQ,omitempty"`
	ConsumerPurchaseValueIn           []string `json:"consumerpurchasevalueIn,omitempty"`
	ConsumerPurchaseValueNotIn        []string `json:"consumerpurchasevalueNotIn,omitempty"`
	ConsumerPurchaseValueGT           *string  `json:"consumerpurchasevalueGT,omitempty"`
	ConsumerPurchaseValueGTE          *string  `json:"consumerpurchasevalueGTE,omitempty"`
	ConsumerPurchaseValueLT           *string  `json:"consumerpurchasevalueLT,omitempty"`
	ConsumerPurchaseValueLTE          *string  `json:"consumerpurchasevalueLTE,omitempty"`
	ConsumerPurchaseValueContains     *string  `json:"consumerpurchasevalueContains,omitempty"`
	ConsumerPurchaseValueHasPrefix    *string  `json:"consumerpurchasevalueHasPrefix,omitempty"`
	ConsumerPurchaseValueHasSuffix    *string  `json:"consumerpurchasevalueHasSuffix,omitempty"`
	ConsumerPurchaseValueEqualFold    *string  `json:"consumerpurchasevalueEqualFold,omitempty"`
	ConsumerPurchaseValueContainsFold *string  `json:"consumerpurchasevalueContainsFold,omitempty"`

	// "customerApplicationLogic" field predicates.
	CustomerApplicationLogic             *string  `json:"customerapplicationlogic,omitempty"`
	CustomerApplicationLogicNEQ          *string  `json:"customerapplicationlogicNEQ,omitempty"`
	CustomerApplicationLogicIn           []string `json:"customerapplicationlogicIn,omitempty"`
	CustomerApplicationLogicNotIn        []string `json:"customerapplicationlogicNotIn,omitempty"`
	CustomerApplicationLogicGT           *string  `json:"customerapplicationlogicGT,omitempty"`
	CustomerApplicationLogicGTE          *string  `json:"customerapplicationlogicGTE,omitempty"`
	CustomerApplicationLogicLT           *string  `json:"customerapplicationlogicLT,omitempty"`
	CustomerApplicationLogicLTE          *string  `json:"customerapplicationlogicLTE,omitempty"`
	CustomerApplicationLogicContains     *string  `json:"customerapplicationlogicContains,omitempty"`
	CustomerApplicationLogicHasPrefix    *string  `json:"customerapplicationlogicHasPrefix,omitempty"`
	CustomerApplicationLogicHasSuffix    *string  `json:"customerapplicationlogicHasSuffix,omitempty"`
	CustomerApplicationLogicEqualFold    *string  `json:"customerapplicationlogicEqualFold,omitempty"`
	CustomerApplicationLogicContainsFold *string  `json:"customerapplicationlogicContainsFold,omitempty"`

	// "initialisationLogic" field predicates.
	InitialisationLogic             *string  `json:"initialisationlogic,omitempty"`
	InitialisationLogicNEQ          *string  `json:"initialisationlogicNEQ,omitempty"`
	InitialisationLogicIn           []string `json:"initialisationlogicIn,omitempty"`
	InitialisationLogicNotIn        []string `json:"initialisationlogicNotIn,omitempty"`
	InitialisationLogicGT           *string  `json:"initialisationlogicGT,omitempty"`
	InitialisationLogicGTE          *string  `json:"initialisationlogicGTE,omitempty"`
	InitialisationLogicLT           *string  `json:"initialisationlogicLT,omitempty"`
	InitialisationLogicLTE          *string  `json:"initialisationlogicLTE,omitempty"`
	InitialisationLogicContains     *string  `json:"initialisationlogicContains,omitempty"`
	InitialisationLogicHasPrefix    *string  `json:"initialisationlogicHasPrefix,omitempty"`
	InitialisationLogicHasSuffix    *string  `json:"initialisationlogicHasSuffix,omitempty"`
	InitialisationLogicEqualFold    *string  `json:"initialisationlogicEqualFold,omitempty"`
	InitialisationLogicContainsFold *string  `json:"initialisationlogicContainsFold,omitempty"`

	// "startDate" field predicates.
	StartDate             *string  `json:"startdate,omitempty"`
	StartDateNEQ          *string  `json:"startdateNEQ,omitempty"`
	StartDateIn           []string `json:"startdateIn,omitempty"`
	StartDateNotIn        []string `json:"startdateNotIn,omitempty"`
	StartDateGT           *string  `json:"startdateGT,omitempty"`
	StartDateGTE          *string  `json:"startdateGTE,omitempty"`
	StartDateLT           *string  `json:"startdateLT,omitempty"`
	StartDateLTE          *string  `json:"startdateLTE,omitempty"`
	StartDateContains     *string  `json:"startdateContains,omitempty"`
	StartDateHasPrefix    *string  `json:"startdateHasPrefix,omitempty"`
	StartDateHasSuffix    *string  `json:"startdateHasSuffix,omitempty"`
	StartDateEqualFold    *string  `json:"startdateEqualFold,omitempty"`
	StartDateContainsFold *string  `json:"startdateContainsFold,omitempty"`

	// "endDate" field predicates.
	EndDate             *string  `json:"enddate,omitempty"`
	EndDateNEQ          *string  `json:"enddateNEQ,omitempty"`
	EndDateIn           []string `json:"enddateIn,omitempty"`
	EndDateNotIn        []string `json:"enddateNotIn,omitempty"`
	EndDateGT           *string  `json:"enddateGT,omitempty"`
	EndDateGTE          *string  `json:"enddateGTE,omitempty"`
	EndDateLT           *string  `json:"enddateLT,omitempty"`
	EndDateLTE          *string  `json:"enddateLTE,omitempty"`
	EndDateContains     *string  `json:"enddateContains,omitempty"`
	EndDateHasPrefix    *string  `json:"enddateHasPrefix,omitempty"`
	EndDateHasSuffix    *string  `json:"enddateHasSuffix,omitempty"`
	EndDateEqualFold    *string  `json:"enddateEqualFold,omitempty"`
	EndDateContainsFold *string  `json:"enddateContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "consumerReward" edge predicates.
	HasConsumerReward     *bool                   `json:"hasConsumerReward,omitempty"`
	HasConsumerRewardWith []*RewardTypeWhereInput `json:"hasConsumerRewardWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MarketingCampaignWhereInput) AddPredicates(predicates ...predicate.MarketingCampaign) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MarketingCampaignWhereInput filter on the MarketingCampaignQuery builder.
func (i *MarketingCampaignWhereInput) Filter(q *MarketingCampaignQuery) (*MarketingCampaignQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMarketingCampaignWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMarketingCampaignWhereInput is returned in case the MarketingCampaignWhereInput is empty.
var ErrEmptyMarketingCampaignWhereInput = errors.New("ent: empty predicate MarketingCampaignWhereInput")

// P returns a predicate for filtering marketingcampaigns.
// An error is returned if the input is empty or invalid.
func (i *MarketingCampaignWhereInput) P() (predicate.MarketingCampaign, error) {
	var predicates []predicate.MarketingCampaign
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, marketingcampaign.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MarketingCampaign, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, marketingcampaign.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MarketingCampaign, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, marketingcampaign.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, marketingcampaign.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, marketingcampaign.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, marketingcampaign.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, marketingcampaign.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, marketingcampaign.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, marketingcampaign.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, marketingcampaign.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, marketingcampaign.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, marketingcampaign.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, marketingcampaign.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, marketingcampaign.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, marketingcampaign.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, marketingcampaign.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, marketingcampaign.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, marketingcampaign.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, marketingcampaign.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, marketingcampaign.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, marketingcampaign.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, marketingcampaign.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, marketingcampaign.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, marketingcampaign.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, marketingcampaign.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, marketingcampaign.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, marketingcampaign.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, marketingcampaign.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, marketingcampaign.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, marketingcampaign.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ConsumerPurchaseValue != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueEQ(*i.ConsumerPurchaseValue))
	}
	if i.ConsumerPurchaseValueNEQ != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueNEQ(*i.ConsumerPurchaseValueNEQ))
	}
	if len(i.ConsumerPurchaseValueIn) > 0 {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueIn(i.ConsumerPurchaseValueIn...))
	}
	if len(i.ConsumerPurchaseValueNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueNotIn(i.ConsumerPurchaseValueNotIn...))
	}
	if i.ConsumerPurchaseValueGT != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueGT(*i.ConsumerPurchaseValueGT))
	}
	if i.ConsumerPurchaseValueGTE != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueGTE(*i.ConsumerPurchaseValueGTE))
	}
	if i.ConsumerPurchaseValueLT != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueLT(*i.ConsumerPurchaseValueLT))
	}
	if i.ConsumerPurchaseValueLTE != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueLTE(*i.ConsumerPurchaseValueLTE))
	}
	if i.ConsumerPurchaseValueContains != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueContains(*i.ConsumerPurchaseValueContains))
	}
	if i.ConsumerPurchaseValueHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueHasPrefix(*i.ConsumerPurchaseValueHasPrefix))
	}
	if i.ConsumerPurchaseValueHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueHasSuffix(*i.ConsumerPurchaseValueHasSuffix))
	}
	if i.ConsumerPurchaseValueEqualFold != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueEqualFold(*i.ConsumerPurchaseValueEqualFold))
	}
	if i.ConsumerPurchaseValueContainsFold != nil {
		predicates = append(predicates, marketingcampaign.ConsumerPurchaseValueContainsFold(*i.ConsumerPurchaseValueContainsFold))
	}
	if i.CustomerApplicationLogic != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicEQ(*i.CustomerApplicationLogic))
	}
	if i.CustomerApplicationLogicNEQ != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicNEQ(*i.CustomerApplicationLogicNEQ))
	}
	if len(i.CustomerApplicationLogicIn) > 0 {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicIn(i.CustomerApplicationLogicIn...))
	}
	if len(i.CustomerApplicationLogicNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicNotIn(i.CustomerApplicationLogicNotIn...))
	}
	if i.CustomerApplicationLogicGT != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicGT(*i.CustomerApplicationLogicGT))
	}
	if i.CustomerApplicationLogicGTE != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicGTE(*i.CustomerApplicationLogicGTE))
	}
	if i.CustomerApplicationLogicLT != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicLT(*i.CustomerApplicationLogicLT))
	}
	if i.CustomerApplicationLogicLTE != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicLTE(*i.CustomerApplicationLogicLTE))
	}
	if i.CustomerApplicationLogicContains != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicContains(*i.CustomerApplicationLogicContains))
	}
	if i.CustomerApplicationLogicHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicHasPrefix(*i.CustomerApplicationLogicHasPrefix))
	}
	if i.CustomerApplicationLogicHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicHasSuffix(*i.CustomerApplicationLogicHasSuffix))
	}
	if i.CustomerApplicationLogicEqualFold != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicEqualFold(*i.CustomerApplicationLogicEqualFold))
	}
	if i.CustomerApplicationLogicContainsFold != nil {
		predicates = append(predicates, marketingcampaign.CustomerApplicationLogicContainsFold(*i.CustomerApplicationLogicContainsFold))
	}
	if i.InitialisationLogic != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicEQ(*i.InitialisationLogic))
	}
	if i.InitialisationLogicNEQ != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicNEQ(*i.InitialisationLogicNEQ))
	}
	if len(i.InitialisationLogicIn) > 0 {
		predicates = append(predicates, marketingcampaign.InitialisationLogicIn(i.InitialisationLogicIn...))
	}
	if len(i.InitialisationLogicNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.InitialisationLogicNotIn(i.InitialisationLogicNotIn...))
	}
	if i.InitialisationLogicGT != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicGT(*i.InitialisationLogicGT))
	}
	if i.InitialisationLogicGTE != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicGTE(*i.InitialisationLogicGTE))
	}
	if i.InitialisationLogicLT != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicLT(*i.InitialisationLogicLT))
	}
	if i.InitialisationLogicLTE != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicLTE(*i.InitialisationLogicLTE))
	}
	if i.InitialisationLogicContains != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicContains(*i.InitialisationLogicContains))
	}
	if i.InitialisationLogicHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicHasPrefix(*i.InitialisationLogicHasPrefix))
	}
	if i.InitialisationLogicHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicHasSuffix(*i.InitialisationLogicHasSuffix))
	}
	if i.InitialisationLogicEqualFold != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicEqualFold(*i.InitialisationLogicEqualFold))
	}
	if i.InitialisationLogicContainsFold != nil {
		predicates = append(predicates, marketingcampaign.InitialisationLogicContainsFold(*i.InitialisationLogicContainsFold))
	}
	if i.StartDate != nil {
		predicates = append(predicates, marketingcampaign.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, marketingcampaign.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, marketingcampaign.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, marketingcampaign.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, marketingcampaign.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, marketingcampaign.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, marketingcampaign.StartDateLTE(*i.StartDateLTE))
	}
	if i.StartDateContains != nil {
		predicates = append(predicates, marketingcampaign.StartDateContains(*i.StartDateContains))
	}
	if i.StartDateHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.StartDateHasPrefix(*i.StartDateHasPrefix))
	}
	if i.StartDateHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.StartDateHasSuffix(*i.StartDateHasSuffix))
	}
	if i.StartDateEqualFold != nil {
		predicates = append(predicates, marketingcampaign.StartDateEqualFold(*i.StartDateEqualFold))
	}
	if i.StartDateContainsFold != nil {
		predicates = append(predicates, marketingcampaign.StartDateContainsFold(*i.StartDateContainsFold))
	}
	if i.EndDate != nil {
		predicates = append(predicates, marketingcampaign.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, marketingcampaign.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, marketingcampaign.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, marketingcampaign.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, marketingcampaign.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, marketingcampaign.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, marketingcampaign.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateContains != nil {
		predicates = append(predicates, marketingcampaign.EndDateContains(*i.EndDateContains))
	}
	if i.EndDateHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.EndDateHasPrefix(*i.EndDateHasPrefix))
	}
	if i.EndDateHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.EndDateHasSuffix(*i.EndDateHasSuffix))
	}
	if i.EndDateEqualFold != nil {
		predicates = append(predicates, marketingcampaign.EndDateEqualFold(*i.EndDateEqualFold))
	}
	if i.EndDateContainsFold != nil {
		predicates = append(predicates, marketingcampaign.EndDateContainsFold(*i.EndDateContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, marketingcampaign.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, marketingcampaign.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, marketingcampaign.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, marketingcampaign.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, marketingcampaign.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	if i.HasProduct != nil {
		p := marketingcampaign.HasProduct()
		if !*i.HasProduct {
			p = marketingcampaign.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, marketingcampaign.HasProductWith(with...))
	}
	if i.HasConsumerReward != nil {
		p := marketingcampaign.HasConsumerReward()
		if !*i.HasConsumerReward {
			p = marketingcampaign.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConsumerRewardWith) > 0 {
		with := make([]predicate.RewardType, 0, len(i.HasConsumerRewardWith))
		for _, w := range i.HasConsumerRewardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConsumerRewardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, marketingcampaign.HasConsumerRewardWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMarketingCampaignWhereInput
	case 1:
		return predicates[0], nil
	default:
		return marketingcampaign.And(predicates...), nil
	}
}

// NotificationWhereInput represents a where input for filtering Notification queries.
type NotificationWhereInput struct {
	Predicates []predicate.Notification  `json:"-"`
	Not        *NotificationWhereInput   `json:"not,omitempty"`
	Or         []*NotificationWhereInput `json:"or,omitempty"`
	And        []*NotificationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "read" field predicates.
	Read    *bool `json:"read,omitempty"`
	ReadNEQ *bool `json:"readNEQ,omitempty"`

	// "recipient" edge predicates.
	HasRecipient     *bool             `json:"hasRecipient,omitempty"`
	HasRecipientWith []*UserWhereInput `json:"hasRecipientWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NotificationWhereInput) AddPredicates(predicates ...predicate.Notification) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NotificationWhereInput filter on the NotificationQuery builder.
func (i *NotificationWhereInput) Filter(q *NotificationQuery) (*NotificationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNotificationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNotificationWhereInput is returned in case the NotificationWhereInput is empty.
var ErrEmptyNotificationWhereInput = errors.New("ent: empty predicate NotificationWhereInput")

// P returns a predicate for filtering notifications.
// An error is returned if the input is empty or invalid.
func (i *NotificationWhereInput) P() (predicate.Notification, error) {
	var predicates []predicate.Notification
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, notification.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Notification, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, notification.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Notification, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, notification.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, notification.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, notification.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, notification.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, notification.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, notification.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, notification.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, notification.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, notification.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, notification.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, notification.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, notification.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, notification.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, notification.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, notification.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, notification.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, notification.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, notification.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, notification.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, notification.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, notification.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, notification.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, notification.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, notification.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, notification.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, notification.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, notification.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, notification.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, notification.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, notification.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, notification.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, notification.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, notification.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, notification.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, notification.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, notification.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, notification.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, notification.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, notification.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, notification.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, notification.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, notification.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, notification.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, notification.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, notification.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, notification.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, notification.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, notification.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, notification.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, notification.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, notification.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, notification.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, notification.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, notification.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, notification.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, notification.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, notification.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, notification.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, notification.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, notification.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, notification.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}
	if i.Read != nil {
		predicates = append(predicates, notification.ReadEQ(*i.Read))
	}
	if i.ReadNEQ != nil {
		predicates = append(predicates, notification.ReadNEQ(*i.ReadNEQ))
	}

	if i.HasRecipient != nil {
		p := notification.HasRecipient()
		if !*i.HasRecipient {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasRecipientWith))
		for _, w := range i.HasRecipientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasRecipientWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNotificationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return notification.And(predicates...), nil
	}
}

// PaymentMethodWhereInput represents a where input for filtering PaymentMethod queries.
type PaymentMethodWhereInput struct {
	Predicates []predicate.PaymentMethod  `json:"-"`
	Not        *PaymentMethodWhereInput   `json:"not,omitempty"`
	Or         []*PaymentMethodWhereInput `json:"or,omitempty"`
	And        []*PaymentMethodWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "xid" field predicates.
	Xid      *int  `json:"xid,omitempty"`
	XidNEQ   *int  `json:"xidNEQ,omitempty"`
	XidIn    []int `json:"xidIn,omitempty"`
	XidNotIn []int `json:"xidNotIn,omitempty"`
	XidGT    *int  `json:"xidGT,omitempty"`
	XidGTE   *int  `json:"xidGTE,omitempty"`
	XidLT    *int  `json:"xidLT,omitempty"`
	XidLTE   *int  `json:"xidLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PaymentMethodWhereInput) AddPredicates(predicates ...predicate.PaymentMethod) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PaymentMethodWhereInput filter on the PaymentMethodQuery builder.
func (i *PaymentMethodWhereInput) Filter(q *PaymentMethodQuery) (*PaymentMethodQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPaymentMethodWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPaymentMethodWhereInput is returned in case the PaymentMethodWhereInput is empty.
var ErrEmptyPaymentMethodWhereInput = errors.New("ent: empty predicate PaymentMethodWhereInput")

// P returns a predicate for filtering paymentmethods.
// An error is returned if the input is empty or invalid.
func (i *PaymentMethodWhereInput) P() (predicate.PaymentMethod, error) {
	var predicates []predicate.PaymentMethod
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, paymentmethod.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PaymentMethod, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, paymentmethod.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PaymentMethod, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, paymentmethod.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, paymentmethod.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, paymentmethod.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, paymentmethod.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, paymentmethod.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, paymentmethod.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, paymentmethod.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, paymentmethod.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, paymentmethod.IDLTE(*i.IDLTE))
	}
	if i.Xid != nil {
		predicates = append(predicates, paymentmethod.XidEQ(*i.Xid))
	}
	if i.XidNEQ != nil {
		predicates = append(predicates, paymentmethod.XidNEQ(*i.XidNEQ))
	}
	if len(i.XidIn) > 0 {
		predicates = append(predicates, paymentmethod.XidIn(i.XidIn...))
	}
	if len(i.XidNotIn) > 0 {
		predicates = append(predicates, paymentmethod.XidNotIn(i.XidNotIn...))
	}
	if i.XidGT != nil {
		predicates = append(predicates, paymentmethod.XidGT(*i.XidGT))
	}
	if i.XidGTE != nil {
		predicates = append(predicates, paymentmethod.XidGTE(*i.XidGTE))
	}
	if i.XidLT != nil {
		predicates = append(predicates, paymentmethod.XidLT(*i.XidLT))
	}
	if i.XidLTE != nil {
		predicates = append(predicates, paymentmethod.XidLTE(*i.XidLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPaymentMethodWhereInput
	case 1:
		return predicates[0], nil
	default:
		return paymentmethod.And(predicates...), nil
	}
}

// PrimaryContentWhereInput represents a where input for filtering PrimaryContent queries.
type PrimaryContentWhereInput struct {
	Predicates []predicate.PrimaryContent  `json:"-"`
	Not        *PrimaryContentWhereInput   `json:"not,omitempty"`
	Or         []*PrimaryContentWhereInput `json:"or,omitempty"`
	And        []*PrimaryContentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "placeholder" field predicates.
	Placeholder       *int  `json:"placeholder,omitempty"`
	PlaceholderNEQ    *int  `json:"placeholderNEQ,omitempty"`
	PlaceholderIn     []int `json:"placeholderIn,omitempty"`
	PlaceholderNotIn  []int `json:"placeholderNotIn,omitempty"`
	PlaceholderGT     *int  `json:"placeholderGT,omitempty"`
	PlaceholderGTE    *int  `json:"placeholderGTE,omitempty"`
	PlaceholderLT     *int  `json:"placeholderLT,omitempty"`
	PlaceholderLTE    *int  `json:"placeholderLTE,omitempty"`
	PlaceholderIsNil  bool  `json:"placeholderIsNil,omitempty"`
	PlaceholderNotNil bool  `json:"placeholderNotNil,omitempty"`

	// "contentBlock" edge predicates.
	HasContentBlock     *bool                     `json:"hasContentBlock,omitempty"`
	HasContentBlockWith []*ContentBlockWhereInput `json:"hasContentBlockWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PrimaryContentWhereInput) AddPredicates(predicates ...predicate.PrimaryContent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PrimaryContentWhereInput filter on the PrimaryContentQuery builder.
func (i *PrimaryContentWhereInput) Filter(q *PrimaryContentQuery) (*PrimaryContentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPrimaryContentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPrimaryContentWhereInput is returned in case the PrimaryContentWhereInput is empty.
var ErrEmptyPrimaryContentWhereInput = errors.New("ent: empty predicate PrimaryContentWhereInput")

// P returns a predicate for filtering primarycontents.
// An error is returned if the input is empty or invalid.
func (i *PrimaryContentWhereInput) P() (predicate.PrimaryContent, error) {
	var predicates []predicate.PrimaryContent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, primarycontent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PrimaryContent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, primarycontent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PrimaryContent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, primarycontent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, primarycontent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, primarycontent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, primarycontent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, primarycontent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, primarycontent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, primarycontent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, primarycontent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, primarycontent.IDLTE(*i.IDLTE))
	}
	if i.Placeholder != nil {
		predicates = append(predicates, primarycontent.PlaceholderEQ(*i.Placeholder))
	}
	if i.PlaceholderNEQ != nil {
		predicates = append(predicates, primarycontent.PlaceholderNEQ(*i.PlaceholderNEQ))
	}
	if len(i.PlaceholderIn) > 0 {
		predicates = append(predicates, primarycontent.PlaceholderIn(i.PlaceholderIn...))
	}
	if len(i.PlaceholderNotIn) > 0 {
		predicates = append(predicates, primarycontent.PlaceholderNotIn(i.PlaceholderNotIn...))
	}
	if i.PlaceholderGT != nil {
		predicates = append(predicates, primarycontent.PlaceholderGT(*i.PlaceholderGT))
	}
	if i.PlaceholderGTE != nil {
		predicates = append(predicates, primarycontent.PlaceholderGTE(*i.PlaceholderGTE))
	}
	if i.PlaceholderLT != nil {
		predicates = append(predicates, primarycontent.PlaceholderLT(*i.PlaceholderLT))
	}
	if i.PlaceholderLTE != nil {
		predicates = append(predicates, primarycontent.PlaceholderLTE(*i.PlaceholderLTE))
	}
	if i.PlaceholderIsNil {
		predicates = append(predicates, primarycontent.PlaceholderIsNil())
	}
	if i.PlaceholderNotNil {
		predicates = append(predicates, primarycontent.PlaceholderNotNil())
	}

	if i.HasContentBlock != nil {
		p := primarycontent.HasContentBlock()
		if !*i.HasContentBlock {
			p = primarycontent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContentBlockWith) > 0 {
		with := make([]predicate.ContentBlock, 0, len(i.HasContentBlockWith))
		for _, w := range i.HasContentBlockWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContentBlockWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, primarycontent.HasContentBlockWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPrimaryContentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return primarycontent.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price             *string  `json:"price,omitempty"`
	PriceNEQ          *string  `json:"priceNEQ,omitempty"`
	PriceIn           []string `json:"priceIn,omitempty"`
	PriceNotIn        []string `json:"priceNotIn,omitempty"`
	PriceGT           *string  `json:"priceGT,omitempty"`
	PriceGTE          *string  `json:"priceGTE,omitempty"`
	PriceLT           *string  `json:"priceLT,omitempty"`
	PriceLTE          *string  `json:"priceLTE,omitempty"`
	PriceContains     *string  `json:"priceContains,omitempty"`
	PriceHasPrefix    *string  `json:"priceHasPrefix,omitempty"`
	PriceHasSuffix    *string  `json:"priceHasSuffix,omitempty"`
	PriceEqualFold    *string  `json:"priceEqualFold,omitempty"`
	PriceContainsFold *string  `json:"priceContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "productSeller" edge predicates.
	HasProductSeller     *bool                   `json:"hasProductSeller,omitempty"`
	HasProductSellerWith []*UserSellerWhereInput `json:"hasProductSellerWith,omitempty"`

	// "reviews" edge predicates.
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`

	// "images" edge predicates.
	HasImages     *bool              `json:"hasImages,omitempty"`
	HasImagesWith []*ImageWhereInput `json:"hasImagesWith,omitempty"`

	// "categories" edge predicates.
	HasCategories     *bool                 `json:"hasCategories,omitempty"`
	HasCategoriesWith []*CategoryWhereInput `json:"hasCategoriesWith,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`

	// "productAttributes" edge predicates.
	HasProductAttributes     *bool                         `json:"hasProductAttributes,omitempty"`
	HasProductAttributesWith []*ProductAttributeWhereInput `json:"hasProductAttributesWith,omitempty"`

	// "variations" edge predicates.
	HasVariations     *bool                         `json:"hasVariations,omitempty"`
	HasVariationsWith []*ProductVariationWhereInput `json:"hasVariationsWith,omitempty"`

	// "commissionStructure" edge predicates.
	HasCommissionStructure     *bool                                  `json:"hasCommissionStructure,omitempty"`
	HasCommissionStructureWith []*CommissionStructureSchemaWhereInput `json:"hasCommissionStructureWith,omitempty"`

	// "shop" edge predicates.
	HasShop     *bool             `json:"hasShop,omitempty"`
	HasShopWith []*ShopWhereInput `json:"hasShopWith,omitempty"`

	// "groupBuys" edge predicates.
	HasGroupBuys     *bool                 `json:"hasGroupBuys,omitempty"`
	HasGroupBuysWith []*GroupBuyWhereInput `json:"hasGroupBuysWith,omitempty"`

	// "productPageViews" edge predicates.
	HasProductPageViews     *bool                        `json:"hasProductPageViews,omitempty"`
	HasProductPageViewsWith []*ProductPageViewWhereInput `json:"hasProductPageViewsWith,omitempty"`

	// "blogPosts" edge predicates.
	HasBlogPosts     *bool                 `json:"hasBlogPosts,omitempty"`
	HasBlogPostsWith []*BlogPostWhereInput `json:"hasBlogPostsWith,omitempty"`

	// "marketingCampaigns" edge predicates.
	HasMarketingCampaigns     *bool                          `json:"hasMarketingCampaigns,omitempty"`
	HasMarketingCampaignsWith []*MarketingCampaignWhereInput `json:"hasMarketingCampaignsWith,omitempty"`

	// "chats" edge predicates.
	HasChats     *bool             `json:"hasChats,omitempty"`
	HasChatsWith []*ChatWhereInput `json:"hasChatsWith,omitempty"`

	// "emailCampaign" edge predicates.
	HasEmailCampaign     *bool                      `json:"hasEmailCampaign,omitempty"`
	HasEmailCampaignWith []*EmailCampaignWhereInput `json:"hasEmailCampaignWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, product.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, product.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, product.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, product.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, product.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, product.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, product.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, product.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, product.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, product.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, product.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, product.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, product.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, product.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, product.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, product.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, product.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, product.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, product.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, product.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, product.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, product.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, product.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, product.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, product.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, product.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, product.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, product.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, product.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, product.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, product.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, product.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, product.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, product.PriceLTE(*i.PriceLTE))
	}
	if i.PriceContains != nil {
		predicates = append(predicates, product.PriceContains(*i.PriceContains))
	}
	if i.PriceHasPrefix != nil {
		predicates = append(predicates, product.PriceHasPrefix(*i.PriceHasPrefix))
	}
	if i.PriceHasSuffix != nil {
		predicates = append(predicates, product.PriceHasSuffix(*i.PriceHasSuffix))
	}
	if i.PriceEqualFold != nil {
		predicates = append(predicates, product.PriceEqualFold(*i.PriceEqualFold))
	}
	if i.PriceContainsFold != nil {
		predicates = append(predicates, product.PriceContainsFold(*i.PriceContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, product.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, product.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, product.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, product.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, product.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, product.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, product.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, product.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, product.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, product.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, product.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, product.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, product.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, product.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, product.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, product.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, product.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, product.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, product.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, product.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, product.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, product.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, product.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, product.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, product.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, product.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	if i.HasProductSeller != nil {
		p := product.HasProductSeller()
		if !*i.HasProductSeller {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductSellerWith) > 0 {
		with := make([]predicate.UserSeller, 0, len(i.HasProductSellerWith))
		for _, w := range i.HasProductSellerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductSellerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductSellerWith(with...))
	}
	if i.HasReviews != nil {
		p := product.HasReviews()
		if !*i.HasReviews {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReviewsWith) > 0 {
		with := make([]predicate.Review, 0, len(i.HasReviewsWith))
		for _, w := range i.HasReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReviewsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasReviewsWith(with...))
	}
	if i.HasImages != nil {
		p := product.HasImages()
		if !*i.HasImages {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImagesWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasImagesWith))
		for _, w := range i.HasImagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasImagesWith(with...))
	}
	if i.HasCategories != nil {
		p := product.HasCategories()
		if !*i.HasCategories {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCategoriesWith) > 0 {
		with := make([]predicate.Category, 0, len(i.HasCategoriesWith))
		for _, w := range i.HasCategoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCategoriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCategoriesWith(with...))
	}
	if i.HasTags != nil {
		p := product.HasTags()
		if !*i.HasTags {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasTagsWith(with...))
	}
	if i.HasProductAttributes != nil {
		p := product.HasProductAttributes()
		if !*i.HasProductAttributes {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductAttributesWith) > 0 {
		with := make([]predicate.ProductAttribute, 0, len(i.HasProductAttributesWith))
		for _, w := range i.HasProductAttributesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductAttributesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductAttributesWith(with...))
	}
	if i.HasVariations != nil {
		p := product.HasVariations()
		if !*i.HasVariations {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVariationsWith) > 0 {
		with := make([]predicate.ProductVariation, 0, len(i.HasVariationsWith))
		for _, w := range i.HasVariationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVariationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasVariationsWith(with...))
	}
	if i.HasCommissionStructure != nil {
		p := product.HasCommissionStructure()
		if !*i.HasCommissionStructure {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommissionStructureWith) > 0 {
		with := make([]predicate.CommissionStructureSchema, 0, len(i.HasCommissionStructureWith))
		for _, w := range i.HasCommissionStructureWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCommissionStructureWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCommissionStructureWith(with...))
	}
	if i.HasShop != nil {
		p := product.HasShop()
		if !*i.HasShop {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShopWith) > 0 {
		with := make([]predicate.Shop, 0, len(i.HasShopWith))
		for _, w := range i.HasShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasShopWith(with...))
	}
	if i.HasGroupBuys != nil {
		p := product.HasGroupBuys()
		if !*i.HasGroupBuys {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupBuysWith) > 0 {
		with := make([]predicate.GroupBuy, 0, len(i.HasGroupBuysWith))
		for _, w := range i.HasGroupBuysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupBuysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasGroupBuysWith(with...))
	}
	if i.HasProductPageViews != nil {
		p := product.HasProductPageViews()
		if !*i.HasProductPageViews {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductPageViewsWith) > 0 {
		with := make([]predicate.ProductPageView, 0, len(i.HasProductPageViewsWith))
		for _, w := range i.HasProductPageViewsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductPageViewsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductPageViewsWith(with...))
	}
	if i.HasBlogPosts != nil {
		p := product.HasBlogPosts()
		if !*i.HasBlogPosts {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlogPostsWith) > 0 {
		with := make([]predicate.BlogPost, 0, len(i.HasBlogPostsWith))
		for _, w := range i.HasBlogPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlogPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasBlogPostsWith(with...))
	}
	if i.HasMarketingCampaigns != nil {
		p := product.HasMarketingCampaigns()
		if !*i.HasMarketingCampaigns {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMarketingCampaignsWith) > 0 {
		with := make([]predicate.MarketingCampaign, 0, len(i.HasMarketingCampaignsWith))
		for _, w := range i.HasMarketingCampaignsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMarketingCampaignsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasMarketingCampaignsWith(with...))
	}
	if i.HasChats != nil {
		p := product.HasChats()
		if !*i.HasChats {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChatsWith) > 0 {
		with := make([]predicate.Chat, 0, len(i.HasChatsWith))
		for _, w := range i.HasChatsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChatsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasChatsWith(with...))
	}
	if i.HasEmailCampaign != nil {
		p := product.HasEmailCampaign()
		if !*i.HasEmailCampaign {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailCampaignWith) > 0 {
		with := make([]predicate.EmailCampaign, 0, len(i.HasEmailCampaignWith))
		for _, w := range i.HasEmailCampaignWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailCampaignWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasEmailCampaignWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProductAttributeWhereInput represents a where input for filtering ProductAttribute queries.
type ProductAttributeWhereInput struct {
	Predicates []predicate.ProductAttribute  `json:"-"`
	Not        *ProductAttributeWhereInput   `json:"not,omitempty"`
	Or         []*ProductAttributeWhereInput `json:"or,omitempty"`
	And        []*ProductAttributeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name      *int  `json:"name,omitempty"`
	NameNEQ   *int  `json:"nameNEQ,omitempty"`
	NameIn    []int `json:"nameIn,omitempty"`
	NameNotIn []int `json:"nameNotIn,omitempty"`
	NameGT    *int  `json:"nameGT,omitempty"`
	NameGTE   *int  `json:"nameGTE,omitempty"`
	NameLT    *int  `json:"nameLT,omitempty"`
	NameLTE   *int  `json:"nameLTE,omitempty"`

	// "description" field predicates.
	Description      *int  `json:"description,omitempty"`
	DescriptionNEQ   *int  `json:"descriptionNEQ,omitempty"`
	DescriptionIn    []int `json:"descriptionIn,omitempty"`
	DescriptionNotIn []int `json:"descriptionNotIn,omitempty"`
	DescriptionGT    *int  `json:"descriptionGT,omitempty"`
	DescriptionGTE   *int  `json:"descriptionGTE,omitempty"`
	DescriptionLT    *int  `json:"descriptionLT,omitempty"`
	DescriptionLTE   *int  `json:"descriptionLTE,omitempty"`

	// "value" field predicates.
	Value      *int  `json:"value,omitempty"`
	ValueNEQ   *int  `json:"valueNEQ,omitempty"`
	ValueIn    []int `json:"valueIn,omitempty"`
	ValueNotIn []int `json:"valueNotIn,omitempty"`
	ValueGT    *int  `json:"valueGT,omitempty"`
	ValueGTE   *int  `json:"valueGTE,omitempty"`
	ValueLT    *int  `json:"valueLT,omitempty"`
	ValueLTE   *int  `json:"valueLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductAttributeWhereInput) AddPredicates(predicates ...predicate.ProductAttribute) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductAttributeWhereInput filter on the ProductAttributeQuery builder.
func (i *ProductAttributeWhereInput) Filter(q *ProductAttributeQuery) (*ProductAttributeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductAttributeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductAttributeWhereInput is returned in case the ProductAttributeWhereInput is empty.
var ErrEmptyProductAttributeWhereInput = errors.New("ent: empty predicate ProductAttributeWhereInput")

// P returns a predicate for filtering productattributes.
// An error is returned if the input is empty or invalid.
func (i *ProductAttributeWhereInput) P() (predicate.ProductAttribute, error) {
	var predicates []predicate.ProductAttribute
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productattribute.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductAttribute, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productattribute.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductAttribute, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productattribute.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productattribute.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productattribute.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productattribute.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productattribute.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productattribute.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productattribute.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productattribute.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productattribute.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, productattribute.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, productattribute.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, productattribute.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, productattribute.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, productattribute.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, productattribute.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, productattribute.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, productattribute.NameLTE(*i.NameLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, productattribute.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, productattribute.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, productattribute.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, productattribute.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, productattribute.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, productattribute.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, productattribute.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, productattribute.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.Value != nil {
		predicates = append(predicates, productattribute.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, productattribute.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, productattribute.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, productattribute.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, productattribute.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, productattribute.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, productattribute.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, productattribute.ValueLTE(*i.ValueLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductAttributeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productattribute.And(predicates...), nil
	}
}

// ProductPageViewWhereInput represents a where input for filtering ProductPageView queries.
type ProductPageViewWhereInput struct {
	Predicates []predicate.ProductPageView  `json:"-"`
	Not        *ProductPageViewWhereInput   `json:"not,omitempty"`
	Or         []*ProductPageViewWhereInput `json:"or,omitempty"`
	And        []*ProductPageViewWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "version" field predicates.
	Version      *int  `json:"version,omitempty"`
	VersionNEQ   *int  `json:"versionNEQ,omitempty"`
	VersionIn    []int `json:"versionIn,omitempty"`
	VersionNotIn []int `json:"versionNotIn,omitempty"`
	VersionGT    *int  `json:"versionGT,omitempty"`
	VersionGTE   *int  `json:"versionGTE,omitempty"`
	VersionLT    *int  `json:"versionLT,omitempty"`
	VersionLTE   *int  `json:"versionLTE,omitempty"`

	// "heroContent" edge predicates.
	HasHeroContent     *bool                    `json:"hasHeroContent,omitempty"`
	HasHeroContentWith []*HeroContentWhereInput `json:"hasHeroContentWith,omitempty"`

	// "primaryContent" edge predicates.
	HasPrimaryContent     *bool                       `json:"hasPrimaryContent,omitempty"`
	HasPrimaryContentWith []*PrimaryContentWhereInput `json:"hasPrimaryContentWith,omitempty"`

	// "viewAnalytics" edge predicates.
	HasViewAnalytics     *bool                      `json:"hasViewAnalytics,omitempty"`
	HasViewAnalyticsWith []*ViewAnalyticsWhereInput `json:"hasViewAnalyticsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductPageViewWhereInput) AddPredicates(predicates ...predicate.ProductPageView) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductPageViewWhereInput filter on the ProductPageViewQuery builder.
func (i *ProductPageViewWhereInput) Filter(q *ProductPageViewQuery) (*ProductPageViewQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductPageViewWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductPageViewWhereInput is returned in case the ProductPageViewWhereInput is empty.
var ErrEmptyProductPageViewWhereInput = errors.New("ent: empty predicate ProductPageViewWhereInput")

// P returns a predicate for filtering productpageviews.
// An error is returned if the input is empty or invalid.
func (i *ProductPageViewWhereInput) P() (predicate.ProductPageView, error) {
	var predicates []predicate.ProductPageView
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productpageview.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductPageView, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productpageview.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductPageView, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productpageview.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productpageview.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productpageview.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productpageview.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productpageview.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productpageview.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productpageview.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productpageview.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productpageview.IDLTE(*i.IDLTE))
	}
	if i.Version != nil {
		predicates = append(predicates, productpageview.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, productpageview.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, productpageview.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, productpageview.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, productpageview.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, productpageview.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, productpageview.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, productpageview.VersionLTE(*i.VersionLTE))
	}

	if i.HasHeroContent != nil {
		p := productpageview.HasHeroContent()
		if !*i.HasHeroContent {
			p = productpageview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHeroContentWith) > 0 {
		with := make([]predicate.HeroContent, 0, len(i.HasHeroContentWith))
		for _, w := range i.HasHeroContentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHeroContentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productpageview.HasHeroContentWith(with...))
	}
	if i.HasPrimaryContent != nil {
		p := productpageview.HasPrimaryContent()
		if !*i.HasPrimaryContent {
			p = productpageview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrimaryContentWith) > 0 {
		with := make([]predicate.PrimaryContent, 0, len(i.HasPrimaryContentWith))
		for _, w := range i.HasPrimaryContentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrimaryContentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productpageview.HasPrimaryContentWith(with...))
	}
	if i.HasViewAnalytics != nil {
		p := productpageview.HasViewAnalytics()
		if !*i.HasViewAnalytics {
			p = productpageview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViewAnalyticsWith) > 0 {
		with := make([]predicate.ViewAnalytics, 0, len(i.HasViewAnalyticsWith))
		for _, w := range i.HasViewAnalyticsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasViewAnalyticsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productpageview.HasViewAnalyticsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductPageViewWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productpageview.And(predicates...), nil
	}
}

// ProductVariationWhereInput represents a where input for filtering ProductVariation queries.
type ProductVariationWhereInput struct {
	Predicates []predicate.ProductVariation  `json:"-"`
	Not        *ProductVariationWhereInput   `json:"not,omitempty"`
	Or         []*ProductVariationWhereInput `json:"or,omitempty"`
	And        []*ProductVariationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price             *string  `json:"price,omitempty"`
	PriceNEQ          *string  `json:"priceNEQ,omitempty"`
	PriceIn           []string `json:"priceIn,omitempty"`
	PriceNotIn        []string `json:"priceNotIn,omitempty"`
	PriceGT           *string  `json:"priceGT,omitempty"`
	PriceGTE          *string  `json:"priceGTE,omitempty"`
	PriceLT           *string  `json:"priceLT,omitempty"`
	PriceLTE          *string  `json:"priceLTE,omitempty"`
	PriceContains     *string  `json:"priceContains,omitempty"`
	PriceHasPrefix    *string  `json:"priceHasPrefix,omitempty"`
	PriceHasSuffix    *string  `json:"priceHasSuffix,omitempty"`
	PriceEqualFold    *string  `json:"priceEqualFold,omitempty"`
	PriceContainsFold *string  `json:"priceContainsFold,omitempty"`

	// "productAttributes" edge predicates.
	HasProductAttributes     *bool                         `json:"hasProductAttributes,omitempty"`
	HasProductAttributesWith []*ProductAttributeWhereInput `json:"hasProductAttributesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductVariationWhereInput) AddPredicates(predicates ...predicate.ProductVariation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductVariationWhereInput filter on the ProductVariationQuery builder.
func (i *ProductVariationWhereInput) Filter(q *ProductVariationQuery) (*ProductVariationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductVariationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductVariationWhereInput is returned in case the ProductVariationWhereInput is empty.
var ErrEmptyProductVariationWhereInput = errors.New("ent: empty predicate ProductVariationWhereInput")

// P returns a predicate for filtering productvariations.
// An error is returned if the input is empty or invalid.
func (i *ProductVariationWhereInput) P() (predicate.ProductVariation, error) {
	var predicates []predicate.ProductVariation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productvariation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductVariation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productvariation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductVariation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productvariation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productvariation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productvariation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productvariation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productvariation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productvariation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productvariation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productvariation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productvariation.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, productvariation.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, productvariation.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, productvariation.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, productvariation.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, productvariation.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, productvariation.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, productvariation.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, productvariation.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, productvariation.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, productvariation.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, productvariation.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, productvariation.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, productvariation.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, productvariation.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, productvariation.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, productvariation.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, productvariation.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, productvariation.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, productvariation.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, productvariation.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, productvariation.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, productvariation.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, productvariation.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, productvariation.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, productvariation.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, productvariation.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, productvariation.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, productvariation.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, productvariation.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, productvariation.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, productvariation.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, productvariation.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, productvariation.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, productvariation.PriceLTE(*i.PriceLTE))
	}
	if i.PriceContains != nil {
		predicates = append(predicates, productvariation.PriceContains(*i.PriceContains))
	}
	if i.PriceHasPrefix != nil {
		predicates = append(predicates, productvariation.PriceHasPrefix(*i.PriceHasPrefix))
	}
	if i.PriceHasSuffix != nil {
		predicates = append(predicates, productvariation.PriceHasSuffix(*i.PriceHasSuffix))
	}
	if i.PriceEqualFold != nil {
		predicates = append(predicates, productvariation.PriceEqualFold(*i.PriceEqualFold))
	}
	if i.PriceContainsFold != nil {
		predicates = append(predicates, productvariation.PriceContainsFold(*i.PriceContainsFold))
	}

	if i.HasProductAttributes != nil {
		p := productvariation.HasProductAttributes()
		if !*i.HasProductAttributes {
			p = productvariation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductAttributesWith) > 0 {
		with := make([]predicate.ProductAttribute, 0, len(i.HasProductAttributesWith))
		for _, w := range i.HasProductAttributesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductAttributesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariation.HasProductAttributesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductVariationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productvariation.And(predicates...), nil
	}
}

// ReferralLinkWhereInput represents a where input for filtering ReferralLink queries.
type ReferralLinkWhereInput struct {
	Predicates []predicate.ReferralLink  `json:"-"`
	Not        *ReferralLinkWhereInput   `json:"not,omitempty"`
	Or         []*ReferralLinkWhereInput `json:"or,omitempty"`
	And        []*ReferralLinkWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "xid" field predicates.
	Xid      *int  `json:"xid,omitempty"`
	XidNEQ   *int  `json:"xidNEQ,omitempty"`
	XidIn    []int `json:"xidIn,omitempty"`
	XidNotIn []int `json:"xidNotIn,omitempty"`
	XidGT    *int  `json:"xidGT,omitempty"`
	XidGTE   *int  `json:"xidGTE,omitempty"`
	XidLT    *int  `json:"xidLT,omitempty"`
	XidLTE   *int  `json:"xidLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "link" field predicates.
	Link             *string  `json:"link,omitempty"`
	LinkNEQ          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGT           *string  `json:"linkGT,omitempty"`
	LinkGTE          *string  `json:"linkGTE,omitempty"`
	LinkLT           *string  `json:"linkLT,omitempty"`
	LinkLTE          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`

	// "visits" edge predicates.
	HasVisits     *bool                  `json:"hasVisits,omitempty"`
	HasVisitsWith []*LinkVisitWhereInput `json:"hasVisitsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReferralLinkWhereInput) AddPredicates(predicates ...predicate.ReferralLink) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReferralLinkWhereInput filter on the ReferralLinkQuery builder.
func (i *ReferralLinkWhereInput) Filter(q *ReferralLinkQuery) (*ReferralLinkQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReferralLinkWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReferralLinkWhereInput is returned in case the ReferralLinkWhereInput is empty.
var ErrEmptyReferralLinkWhereInput = errors.New("ent: empty predicate ReferralLinkWhereInput")

// P returns a predicate for filtering referrallinks.
// An error is returned if the input is empty or invalid.
func (i *ReferralLinkWhereInput) P() (predicate.ReferralLink, error) {
	var predicates []predicate.ReferralLink
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, referrallink.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReferralLink, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, referrallink.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReferralLink, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, referrallink.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, referrallink.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, referrallink.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, referrallink.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, referrallink.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, referrallink.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, referrallink.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, referrallink.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, referrallink.IDLTE(*i.IDLTE))
	}
	if i.Xid != nil {
		predicates = append(predicates, referrallink.XidEQ(*i.Xid))
	}
	if i.XidNEQ != nil {
		predicates = append(predicates, referrallink.XidNEQ(*i.XidNEQ))
	}
	if len(i.XidIn) > 0 {
		predicates = append(predicates, referrallink.XidIn(i.XidIn...))
	}
	if len(i.XidNotIn) > 0 {
		predicates = append(predicates, referrallink.XidNotIn(i.XidNotIn...))
	}
	if i.XidGT != nil {
		predicates = append(predicates, referrallink.XidGT(*i.XidGT))
	}
	if i.XidGTE != nil {
		predicates = append(predicates, referrallink.XidGTE(*i.XidGTE))
	}
	if i.XidLT != nil {
		predicates = append(predicates, referrallink.XidLT(*i.XidLT))
	}
	if i.XidLTE != nil {
		predicates = append(predicates, referrallink.XidLTE(*i.XidLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, referrallink.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, referrallink.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, referrallink.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, referrallink.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, referrallink.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, referrallink.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, referrallink.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, referrallink.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, referrallink.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, referrallink.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, referrallink.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, referrallink.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, referrallink.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, referrallink.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, referrallink.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, referrallink.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, referrallink.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, referrallink.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, referrallink.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, referrallink.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, referrallink.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, referrallink.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, referrallink.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, referrallink.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, referrallink.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, referrallink.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Link != nil {
		predicates = append(predicates, referrallink.LinkEQ(*i.Link))
	}
	if i.LinkNEQ != nil {
		predicates = append(predicates, referrallink.LinkNEQ(*i.LinkNEQ))
	}
	if len(i.LinkIn) > 0 {
		predicates = append(predicates, referrallink.LinkIn(i.LinkIn...))
	}
	if len(i.LinkNotIn) > 0 {
		predicates = append(predicates, referrallink.LinkNotIn(i.LinkNotIn...))
	}
	if i.LinkGT != nil {
		predicates = append(predicates, referrallink.LinkGT(*i.LinkGT))
	}
	if i.LinkGTE != nil {
		predicates = append(predicates, referrallink.LinkGTE(*i.LinkGTE))
	}
	if i.LinkLT != nil {
		predicates = append(predicates, referrallink.LinkLT(*i.LinkLT))
	}
	if i.LinkLTE != nil {
		predicates = append(predicates, referrallink.LinkLTE(*i.LinkLTE))
	}
	if i.LinkContains != nil {
		predicates = append(predicates, referrallink.LinkContains(*i.LinkContains))
	}
	if i.LinkHasPrefix != nil {
		predicates = append(predicates, referrallink.LinkHasPrefix(*i.LinkHasPrefix))
	}
	if i.LinkHasSuffix != nil {
		predicates = append(predicates, referrallink.LinkHasSuffix(*i.LinkHasSuffix))
	}
	if i.LinkEqualFold != nil {
		predicates = append(predicates, referrallink.LinkEqualFold(*i.LinkEqualFold))
	}
	if i.LinkContainsFold != nil {
		predicates = append(predicates, referrallink.LinkContainsFold(*i.LinkContainsFold))
	}

	if i.HasVisits != nil {
		p := referrallink.HasVisits()
		if !*i.HasVisits {
			p = referrallink.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVisitsWith) > 0 {
		with := make([]predicate.LinkVisit, 0, len(i.HasVisitsWith))
		for _, w := range i.HasVisitsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVisitsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, referrallink.HasVisitsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReferralLinkWhereInput
	case 1:
		return predicates[0], nil
	default:
		return referrallink.And(predicates...), nil
	}
}

// RefundTransactionsWhereInput represents a where input for filtering RefundTransactions queries.
type RefundTransactionsWhereInput struct {
	Predicates []predicate.RefundTransactions  `json:"-"`
	Not        *RefundTransactionsWhereInput   `json:"not,omitempty"`
	Or         []*RefundTransactionsWhereInput `json:"or,omitempty"`
	And        []*RefundTransactionsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "refundAmount" field predicates.
	RefundAmount             *string  `json:"refundamount,omitempty"`
	RefundAmountNEQ          *string  `json:"refundamountNEQ,omitempty"`
	RefundAmountIn           []string `json:"refundamountIn,omitempty"`
	RefundAmountNotIn        []string `json:"refundamountNotIn,omitempty"`
	RefundAmountGT           *string  `json:"refundamountGT,omitempty"`
	RefundAmountGTE          *string  `json:"refundamountGTE,omitempty"`
	RefundAmountLT           *string  `json:"refundamountLT,omitempty"`
	RefundAmountLTE          *string  `json:"refundamountLTE,omitempty"`
	RefundAmountContains     *string  `json:"refundamountContains,omitempty"`
	RefundAmountHasPrefix    *string  `json:"refundamountHasPrefix,omitempty"`
	RefundAmountHasSuffix    *string  `json:"refundamountHasSuffix,omitempty"`
	RefundAmountEqualFold    *string  `json:"refundamountEqualFold,omitempty"`
	RefundAmountContainsFold *string  `json:"refundamountContainsFold,omitempty"`

	// "refundCurrency" field predicates.
	RefundCurrency             *string  `json:"refundcurrency,omitempty"`
	RefundCurrencyNEQ          *string  `json:"refundcurrencyNEQ,omitempty"`
	RefundCurrencyIn           []string `json:"refundcurrencyIn,omitempty"`
	RefundCurrencyNotIn        []string `json:"refundcurrencyNotIn,omitempty"`
	RefundCurrencyGT           *string  `json:"refundcurrencyGT,omitempty"`
	RefundCurrencyGTE          *string  `json:"refundcurrencyGTE,omitempty"`
	RefundCurrencyLT           *string  `json:"refundcurrencyLT,omitempty"`
	RefundCurrencyLTE          *string  `json:"refundcurrencyLTE,omitempty"`
	RefundCurrencyContains     *string  `json:"refundcurrencyContains,omitempty"`
	RefundCurrencyHasPrefix    *string  `json:"refundcurrencyHasPrefix,omitempty"`
	RefundCurrencyHasSuffix    *string  `json:"refundcurrencyHasSuffix,omitempty"`
	RefundCurrencyEqualFold    *string  `json:"refundcurrencyEqualFold,omitempty"`
	RefundCurrencyContainsFold *string  `json:"refundcurrencyContainsFold,omitempty"`

	// "refundReason" field predicates.
	RefundReason             *string  `json:"refundreason,omitempty"`
	RefundReasonNEQ          *string  `json:"refundreasonNEQ,omitempty"`
	RefundReasonIn           []string `json:"refundreasonIn,omitempty"`
	RefundReasonNotIn        []string `json:"refundreasonNotIn,omitempty"`
	RefundReasonGT           *string  `json:"refundreasonGT,omitempty"`
	RefundReasonGTE          *string  `json:"refundreasonGTE,omitempty"`
	RefundReasonLT           *string  `json:"refundreasonLT,omitempty"`
	RefundReasonLTE          *string  `json:"refundreasonLTE,omitempty"`
	RefundReasonContains     *string  `json:"refundreasonContains,omitempty"`
	RefundReasonHasPrefix    *string  `json:"refundreasonHasPrefix,omitempty"`
	RefundReasonHasSuffix    *string  `json:"refundreasonHasSuffix,omitempty"`
	RefundReasonEqualFold    *string  `json:"refundreasonEqualFold,omitempty"`
	RefundReasonContainsFold *string  `json:"refundreasonContainsFold,omitempty"`

	// "refundStatus" field predicates.
	RefundStatus             *string  `json:"refundstatus,omitempty"`
	RefundStatusNEQ          *string  `json:"refundstatusNEQ,omitempty"`
	RefundStatusIn           []string `json:"refundstatusIn,omitempty"`
	RefundStatusNotIn        []string `json:"refundstatusNotIn,omitempty"`
	RefundStatusGT           *string  `json:"refundstatusGT,omitempty"`
	RefundStatusGTE          *string  `json:"refundstatusGTE,omitempty"`
	RefundStatusLT           *string  `json:"refundstatusLT,omitempty"`
	RefundStatusLTE          *string  `json:"refundstatusLTE,omitempty"`
	RefundStatusContains     *string  `json:"refundstatusContains,omitempty"`
	RefundStatusHasPrefix    *string  `json:"refundstatusHasPrefix,omitempty"`
	RefundStatusHasSuffix    *string  `json:"refundstatusHasSuffix,omitempty"`
	RefundStatusEqualFold    *string  `json:"refundstatusEqualFold,omitempty"`
	RefundStatusContainsFold *string  `json:"refundstatusContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "transaction" edge predicates.
	HasTransaction     *bool                    `json:"hasTransaction,omitempty"`
	HasTransactionWith []*TransactionWhereInput `json:"hasTransactionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RefundTransactionsWhereInput) AddPredicates(predicates ...predicate.RefundTransactions) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RefundTransactionsWhereInput filter on the RefundTransactionsQuery builder.
func (i *RefundTransactionsWhereInput) Filter(q *RefundTransactionsQuery) (*RefundTransactionsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRefundTransactionsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRefundTransactionsWhereInput is returned in case the RefundTransactionsWhereInput is empty.
var ErrEmptyRefundTransactionsWhereInput = errors.New("ent: empty predicate RefundTransactionsWhereInput")

// P returns a predicate for filtering refundtransactionsslice.
// An error is returned if the input is empty or invalid.
func (i *RefundTransactionsWhereInput) P() (predicate.RefundTransactions, error) {
	var predicates []predicate.RefundTransactions
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, refundtransactions.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RefundTransactions, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, refundtransactions.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RefundTransactions, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, refundtransactions.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, refundtransactions.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, refundtransactions.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, refundtransactions.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, refundtransactions.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, refundtransactions.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, refundtransactions.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, refundtransactions.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, refundtransactions.IDLTE(*i.IDLTE))
	}
	if i.RefundAmount != nil {
		predicates = append(predicates, refundtransactions.RefundAmountEQ(*i.RefundAmount))
	}
	if i.RefundAmountNEQ != nil {
		predicates = append(predicates, refundtransactions.RefundAmountNEQ(*i.RefundAmountNEQ))
	}
	if len(i.RefundAmountIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundAmountIn(i.RefundAmountIn...))
	}
	if len(i.RefundAmountNotIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundAmountNotIn(i.RefundAmountNotIn...))
	}
	if i.RefundAmountGT != nil {
		predicates = append(predicates, refundtransactions.RefundAmountGT(*i.RefundAmountGT))
	}
	if i.RefundAmountGTE != nil {
		predicates = append(predicates, refundtransactions.RefundAmountGTE(*i.RefundAmountGTE))
	}
	if i.RefundAmountLT != nil {
		predicates = append(predicates, refundtransactions.RefundAmountLT(*i.RefundAmountLT))
	}
	if i.RefundAmountLTE != nil {
		predicates = append(predicates, refundtransactions.RefundAmountLTE(*i.RefundAmountLTE))
	}
	if i.RefundAmountContains != nil {
		predicates = append(predicates, refundtransactions.RefundAmountContains(*i.RefundAmountContains))
	}
	if i.RefundAmountHasPrefix != nil {
		predicates = append(predicates, refundtransactions.RefundAmountHasPrefix(*i.RefundAmountHasPrefix))
	}
	if i.RefundAmountHasSuffix != nil {
		predicates = append(predicates, refundtransactions.RefundAmountHasSuffix(*i.RefundAmountHasSuffix))
	}
	if i.RefundAmountEqualFold != nil {
		predicates = append(predicates, refundtransactions.RefundAmountEqualFold(*i.RefundAmountEqualFold))
	}
	if i.RefundAmountContainsFold != nil {
		predicates = append(predicates, refundtransactions.RefundAmountContainsFold(*i.RefundAmountContainsFold))
	}
	if i.RefundCurrency != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyEQ(*i.RefundCurrency))
	}
	if i.RefundCurrencyNEQ != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyNEQ(*i.RefundCurrencyNEQ))
	}
	if len(i.RefundCurrencyIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundCurrencyIn(i.RefundCurrencyIn...))
	}
	if len(i.RefundCurrencyNotIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundCurrencyNotIn(i.RefundCurrencyNotIn...))
	}
	if i.RefundCurrencyGT != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyGT(*i.RefundCurrencyGT))
	}
	if i.RefundCurrencyGTE != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyGTE(*i.RefundCurrencyGTE))
	}
	if i.RefundCurrencyLT != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyLT(*i.RefundCurrencyLT))
	}
	if i.RefundCurrencyLTE != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyLTE(*i.RefundCurrencyLTE))
	}
	if i.RefundCurrencyContains != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyContains(*i.RefundCurrencyContains))
	}
	if i.RefundCurrencyHasPrefix != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyHasPrefix(*i.RefundCurrencyHasPrefix))
	}
	if i.RefundCurrencyHasSuffix != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyHasSuffix(*i.RefundCurrencyHasSuffix))
	}
	if i.RefundCurrencyEqualFold != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyEqualFold(*i.RefundCurrencyEqualFold))
	}
	if i.RefundCurrencyContainsFold != nil {
		predicates = append(predicates, refundtransactions.RefundCurrencyContainsFold(*i.RefundCurrencyContainsFold))
	}
	if i.RefundReason != nil {
		predicates = append(predicates, refundtransactions.RefundReasonEQ(*i.RefundReason))
	}
	if i.RefundReasonNEQ != nil {
		predicates = append(predicates, refundtransactions.RefundReasonNEQ(*i.RefundReasonNEQ))
	}
	if len(i.RefundReasonIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundReasonIn(i.RefundReasonIn...))
	}
	if len(i.RefundReasonNotIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundReasonNotIn(i.RefundReasonNotIn...))
	}
	if i.RefundReasonGT != nil {
		predicates = append(predicates, refundtransactions.RefundReasonGT(*i.RefundReasonGT))
	}
	if i.RefundReasonGTE != nil {
		predicates = append(predicates, refundtransactions.RefundReasonGTE(*i.RefundReasonGTE))
	}
	if i.RefundReasonLT != nil {
		predicates = append(predicates, refundtransactions.RefundReasonLT(*i.RefundReasonLT))
	}
	if i.RefundReasonLTE != nil {
		predicates = append(predicates, refundtransactions.RefundReasonLTE(*i.RefundReasonLTE))
	}
	if i.RefundReasonContains != nil {
		predicates = append(predicates, refundtransactions.RefundReasonContains(*i.RefundReasonContains))
	}
	if i.RefundReasonHasPrefix != nil {
		predicates = append(predicates, refundtransactions.RefundReasonHasPrefix(*i.RefundReasonHasPrefix))
	}
	if i.RefundReasonHasSuffix != nil {
		predicates = append(predicates, refundtransactions.RefundReasonHasSuffix(*i.RefundReasonHasSuffix))
	}
	if i.RefundReasonEqualFold != nil {
		predicates = append(predicates, refundtransactions.RefundReasonEqualFold(*i.RefundReasonEqualFold))
	}
	if i.RefundReasonContainsFold != nil {
		predicates = append(predicates, refundtransactions.RefundReasonContainsFold(*i.RefundReasonContainsFold))
	}
	if i.RefundStatus != nil {
		predicates = append(predicates, refundtransactions.RefundStatusEQ(*i.RefundStatus))
	}
	if i.RefundStatusNEQ != nil {
		predicates = append(predicates, refundtransactions.RefundStatusNEQ(*i.RefundStatusNEQ))
	}
	if len(i.RefundStatusIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundStatusIn(i.RefundStatusIn...))
	}
	if len(i.RefundStatusNotIn) > 0 {
		predicates = append(predicates, refundtransactions.RefundStatusNotIn(i.RefundStatusNotIn...))
	}
	if i.RefundStatusGT != nil {
		predicates = append(predicates, refundtransactions.RefundStatusGT(*i.RefundStatusGT))
	}
	if i.RefundStatusGTE != nil {
		predicates = append(predicates, refundtransactions.RefundStatusGTE(*i.RefundStatusGTE))
	}
	if i.RefundStatusLT != nil {
		predicates = append(predicates, refundtransactions.RefundStatusLT(*i.RefundStatusLT))
	}
	if i.RefundStatusLTE != nil {
		predicates = append(predicates, refundtransactions.RefundStatusLTE(*i.RefundStatusLTE))
	}
	if i.RefundStatusContains != nil {
		predicates = append(predicates, refundtransactions.RefundStatusContains(*i.RefundStatusContains))
	}
	if i.RefundStatusHasPrefix != nil {
		predicates = append(predicates, refundtransactions.RefundStatusHasPrefix(*i.RefundStatusHasPrefix))
	}
	if i.RefundStatusHasSuffix != nil {
		predicates = append(predicates, refundtransactions.RefundStatusHasSuffix(*i.RefundStatusHasSuffix))
	}
	if i.RefundStatusEqualFold != nil {
		predicates = append(predicates, refundtransactions.RefundStatusEqualFold(*i.RefundStatusEqualFold))
	}
	if i.RefundStatusContainsFold != nil {
		predicates = append(predicates, refundtransactions.RefundStatusContainsFold(*i.RefundStatusContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, refundtransactions.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, refundtransactions.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, refundtransactions.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, refundtransactions.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, refundtransactions.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, refundtransactions.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, refundtransactions.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, refundtransactions.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, refundtransactions.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, refundtransactions.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, refundtransactions.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, refundtransactions.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, refundtransactions.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, refundtransactions.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, refundtransactions.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, refundtransactions.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	if i.HasTransaction != nil {
		p := refundtransactions.HasTransaction()
		if !*i.HasTransaction {
			p = refundtransactions.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionWith))
		for _, w := range i.HasTransactionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, refundtransactions.HasTransactionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRefundTransactionsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return refundtransactions.And(predicates...), nil
	}
}

// ReviewWhereInput represents a where input for filtering Review queries.
type ReviewWhereInput struct {
	Predicates []predicate.Review  `json:"-"`
	Not        *ReviewWhereInput   `json:"not,omitempty"`
	Or         []*ReviewWhereInput `json:"or,omitempty"`
	And        []*ReviewWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "rating" field predicates.
	Rating             *string  `json:"rating,omitempty"`
	RatingNEQ          *string  `json:"ratingNEQ,omitempty"`
	RatingIn           []string `json:"ratingIn,omitempty"`
	RatingNotIn        []string `json:"ratingNotIn,omitempty"`
	RatingGT           *string  `json:"ratingGT,omitempty"`
	RatingGTE          *string  `json:"ratingGTE,omitempty"`
	RatingLT           *string  `json:"ratingLT,omitempty"`
	RatingLTE          *string  `json:"ratingLTE,omitempty"`
	RatingContains     *string  `json:"ratingContains,omitempty"`
	RatingHasPrefix    *string  `json:"ratingHasPrefix,omitempty"`
	RatingHasSuffix    *string  `json:"ratingHasSuffix,omitempty"`
	RatingEqualFold    *string  `json:"ratingEqualFold,omitempty"`
	RatingContainsFold *string  `json:"ratingContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "productCustomer" edge predicates.
	HasProductCustomer     *bool                  `json:"hasProductCustomer,omitempty"`
	HasProductCustomerWith []*UserBuyerWhereInput `json:"hasProductCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReviewWhereInput) AddPredicates(predicates ...predicate.Review) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReviewWhereInput filter on the ReviewQuery builder.
func (i *ReviewWhereInput) Filter(q *ReviewQuery) (*ReviewQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReviewWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReviewWhereInput is returned in case the ReviewWhereInput is empty.
var ErrEmptyReviewWhereInput = errors.New("ent: empty predicate ReviewWhereInput")

// P returns a predicate for filtering reviews.
// An error is returned if the input is empty or invalid.
func (i *ReviewWhereInput) P() (predicate.Review, error) {
	var predicates []predicate.Review
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, review.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Review, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, review.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Review, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, review.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, review.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, review.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, review.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, review.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, review.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, review.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, review.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, review.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, review.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, review.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, review.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, review.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, review.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, review.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, review.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, review.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, review.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, review.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, review.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, review.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, review.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, review.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, review.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, review.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, review.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, review.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, review.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, review.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, review.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, review.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, review.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, review.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, review.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, review.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Rating != nil {
		predicates = append(predicates, review.RatingEQ(*i.Rating))
	}
	if i.RatingNEQ != nil {
		predicates = append(predicates, review.RatingNEQ(*i.RatingNEQ))
	}
	if len(i.RatingIn) > 0 {
		predicates = append(predicates, review.RatingIn(i.RatingIn...))
	}
	if len(i.RatingNotIn) > 0 {
		predicates = append(predicates, review.RatingNotIn(i.RatingNotIn...))
	}
	if i.RatingGT != nil {
		predicates = append(predicates, review.RatingGT(*i.RatingGT))
	}
	if i.RatingGTE != nil {
		predicates = append(predicates, review.RatingGTE(*i.RatingGTE))
	}
	if i.RatingLT != nil {
		predicates = append(predicates, review.RatingLT(*i.RatingLT))
	}
	if i.RatingLTE != nil {
		predicates = append(predicates, review.RatingLTE(*i.RatingLTE))
	}
	if i.RatingContains != nil {
		predicates = append(predicates, review.RatingContains(*i.RatingContains))
	}
	if i.RatingHasPrefix != nil {
		predicates = append(predicates, review.RatingHasPrefix(*i.RatingHasPrefix))
	}
	if i.RatingHasSuffix != nil {
		predicates = append(predicates, review.RatingHasSuffix(*i.RatingHasSuffix))
	}
	if i.RatingEqualFold != nil {
		predicates = append(predicates, review.RatingEqualFold(*i.RatingEqualFold))
	}
	if i.RatingContainsFold != nil {
		predicates = append(predicates, review.RatingContainsFold(*i.RatingContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, review.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, review.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, review.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, review.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, review.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, review.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, review.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, review.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, review.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, review.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, review.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, review.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, review.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}

	if i.HasProduct != nil {
		p := review.HasProduct()
		if !*i.HasProduct {
			p = review.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, review.HasProductWith(with...))
	}
	if i.HasProductCustomer != nil {
		p := review.HasProductCustomer()
		if !*i.HasProductCustomer {
			p = review.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductCustomerWith) > 0 {
		with := make([]predicate.UserBuyer, 0, len(i.HasProductCustomerWith))
		for _, w := range i.HasProductCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, review.HasProductCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReviewWhereInput
	case 1:
		return predicates[0], nil
	default:
		return review.And(predicates...), nil
	}
}

// RewardTypeWhereInput represents a where input for filtering RewardType queries.
type RewardTypeWhereInput struct {
	Predicates []predicate.RewardType  `json:"-"`
	Not        *RewardTypeWhereInput   `json:"not,omitempty"`
	Or         []*RewardTypeWhereInput `json:"or,omitempty"`
	And        []*RewardTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *rewardtype.Type  `json:"type,omitempty"`
	TypeNEQ   *rewardtype.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []rewardtype.Type `json:"typeIn,omitempty"`
	TypeNotIn []rewardtype.Type `json:"typeNotIn,omitempty"`

	// "val" field predicates.
	Val      *int  `json:"val,omitempty"`
	ValNEQ   *int  `json:"valNEQ,omitempty"`
	ValIn    []int `json:"valIn,omitempty"`
	ValNotIn []int `json:"valNotIn,omitempty"`
	ValGT    *int  `json:"valGT,omitempty"`
	ValGTE   *int  `json:"valGTE,omitempty"`
	ValLT    *int  `json:"valLT,omitempty"`
	ValLTE   *int  `json:"valLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RewardTypeWhereInput) AddPredicates(predicates ...predicate.RewardType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RewardTypeWhereInput filter on the RewardTypeQuery builder.
func (i *RewardTypeWhereInput) Filter(q *RewardTypeQuery) (*RewardTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRewardTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRewardTypeWhereInput is returned in case the RewardTypeWhereInput is empty.
var ErrEmptyRewardTypeWhereInput = errors.New("ent: empty predicate RewardTypeWhereInput")

// P returns a predicate for filtering rewardtypes.
// An error is returned if the input is empty or invalid.
func (i *RewardTypeWhereInput) P() (predicate.RewardType, error) {
	var predicates []predicate.RewardType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, rewardtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RewardType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, rewardtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RewardType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, rewardtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, rewardtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, rewardtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, rewardtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, rewardtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, rewardtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, rewardtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, rewardtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, rewardtype.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, rewardtype.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, rewardtype.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, rewardtype.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, rewardtype.TypeNotIn(i.TypeNotIn...))
	}
	if i.Val != nil {
		predicates = append(predicates, rewardtype.ValEQ(*i.Val))
	}
	if i.ValNEQ != nil {
		predicates = append(predicates, rewardtype.ValNEQ(*i.ValNEQ))
	}
	if len(i.ValIn) > 0 {
		predicates = append(predicates, rewardtype.ValIn(i.ValIn...))
	}
	if len(i.ValNotIn) > 0 {
		predicates = append(predicates, rewardtype.ValNotIn(i.ValNotIn...))
	}
	if i.ValGT != nil {
		predicates = append(predicates, rewardtype.ValGT(*i.ValGT))
	}
	if i.ValGTE != nil {
		predicates = append(predicates, rewardtype.ValGTE(*i.ValGTE))
	}
	if i.ValLT != nil {
		predicates = append(predicates, rewardtype.ValLT(*i.ValLT))
	}
	if i.ValLTE != nil {
		predicates = append(predicates, rewardtype.ValLTE(*i.ValLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRewardTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return rewardtype.And(predicates...), nil
	}
}

// ShippingAddressWhereInput represents a where input for filtering ShippingAddress queries.
type ShippingAddressWhereInput struct {
	Predicates []predicate.ShippingAddress  `json:"-"`
	Not        *ShippingAddressWhereInput   `json:"not,omitempty"`
	Or         []*ShippingAddressWhereInput `json:"or,omitempty"`
	And        []*ShippingAddressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShippingAddressWhereInput) AddPredicates(predicates ...predicate.ShippingAddress) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShippingAddressWhereInput filter on the ShippingAddressQuery builder.
func (i *ShippingAddressWhereInput) Filter(q *ShippingAddressQuery) (*ShippingAddressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShippingAddressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShippingAddressWhereInput is returned in case the ShippingAddressWhereInput is empty.
var ErrEmptyShippingAddressWhereInput = errors.New("ent: empty predicate ShippingAddressWhereInput")

// P returns a predicate for filtering shippingaddresses.
// An error is returned if the input is empty or invalid.
func (i *ShippingAddressWhereInput) P() (predicate.ShippingAddress, error) {
	var predicates []predicate.ShippingAddress
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shippingaddress.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShippingAddress, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shippingaddress.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShippingAddress, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shippingaddress.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shippingaddress.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shippingaddress.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shippingaddress.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shippingaddress.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shippingaddress.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shippingaddress.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shippingaddress.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shippingaddress.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, shippingaddress.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, shippingaddress.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, shippingaddress.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, shippingaddress.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, shippingaddress.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, shippingaddress.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, shippingaddress.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, shippingaddress.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, shippingaddress.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, shippingaddress.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, shippingaddress.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, shippingaddress.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, shippingaddress.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, shippingaddress.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, shippingaddress.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, shippingaddress.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, shippingaddress.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, shippingaddress.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, shippingaddress.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, shippingaddress.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, shippingaddress.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, shippingaddress.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, shippingaddress.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, shippingaddress.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, shippingaddress.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, shippingaddress.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, shippingaddress.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, shippingaddress.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, shippingaddress.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, shippingaddress.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, shippingaddress.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, shippingaddress.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, shippingaddress.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, shippingaddress.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, shippingaddress.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, shippingaddress.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, shippingaddress.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, shippingaddress.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, shippingaddress.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, shippingaddress.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, shippingaddress.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, shippingaddress.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, shippingaddress.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, shippingaddress.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, shippingaddress.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, shippingaddress.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, shippingaddress.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, shippingaddress.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, shippingaddress.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, shippingaddress.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, shippingaddress.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, shippingaddress.StateContainsFold(*i.StateContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, shippingaddress.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, shippingaddress.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, shippingaddress.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, shippingaddress.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, shippingaddress.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, shippingaddress.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, shippingaddress.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, shippingaddress.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, shippingaddress.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, shippingaddress.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, shippingaddress.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, shippingaddress.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, shippingaddress.ZipContainsFold(*i.ZipContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, shippingaddress.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, shippingaddress.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, shippingaddress.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, shippingaddress.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, shippingaddress.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, shippingaddress.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, shippingaddress.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, shippingaddress.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, shippingaddress.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, shippingaddress.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, shippingaddress.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, shippingaddress.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, shippingaddress.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, shippingaddress.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, shippingaddress.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, shippingaddress.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, shippingaddress.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, shippingaddress.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, shippingaddress.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, shippingaddress.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, shippingaddress.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, shippingaddress.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, shippingaddress.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, shippingaddress.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, shippingaddress.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, shippingaddress.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, shippingaddress.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, shippingaddress.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, shippingaddress.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShippingAddressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shippingaddress.And(predicates...), nil
	}
}

// ShopWhereInput represents a where input for filtering Shop queries.
type ShopWhereInput struct {
	Predicates []predicate.Shop  `json:"-"`
	Not        *ShopWhereInput   `json:"not,omitempty"`
	Or         []*ShopWhereInput `json:"or,omitempty"`
	And        []*ShopWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`

	// "bankAccounts" edge predicates.
	HasBankAccounts     *bool                    `json:"hasBankAccounts,omitempty"`
	HasBankAccountsWith []*BankAccountWhereInput `json:"hasBankAccountsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShopWhereInput) AddPredicates(predicates ...predicate.Shop) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShopWhereInput filter on the ShopQuery builder.
func (i *ShopWhereInput) Filter(q *ShopQuery) (*ShopQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShopWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShopWhereInput is returned in case the ShopWhereInput is empty.
var ErrEmptyShopWhereInput = errors.New("ent: empty predicate ShopWhereInput")

// P returns a predicate for filtering shops.
// An error is returned if the input is empty or invalid.
func (i *ShopWhereInput) P() (predicate.Shop, error) {
	var predicates []predicate.Shop
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shop.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Shop, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shop.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Shop, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shop.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shop.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shop.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shop.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shop.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shop.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shop.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shop.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shop.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, shop.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, shop.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, shop.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, shop.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, shop.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, shop.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, shop.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, shop.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, shop.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, shop.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, shop.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, shop.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, shop.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, shop.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, shop.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, shop.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, shop.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, shop.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, shop.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, shop.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, shop.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, shop.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, shop.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, shop.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, shop.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, shop.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasProducts != nil {
		p := shop.HasProducts()
		if !*i.HasProducts {
			p = shop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shop.HasProductsWith(with...))
	}
	if i.HasTransactions != nil {
		p := shop.HasTransactions()
		if !*i.HasTransactions {
			p = shop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shop.HasTransactionsWith(with...))
	}
	if i.HasBankAccounts != nil {
		p := shop.HasBankAccounts()
		if !*i.HasBankAccounts {
			p = shop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBankAccountsWith) > 0 {
		with := make([]predicate.BankAccount, 0, len(i.HasBankAccountsWith))
		for _, w := range i.HasBankAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBankAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shop.HasBankAccountsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShopWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shop.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Predicates []predicate.Tag  `json:"-"`
	Not        *TagWhereInput   `json:"not,omitempty"`
	Or         []*TagWhereInput `json:"or,omitempty"`
	And        []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TagWhereInput) AddPredicates(predicates ...predicate.Tag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTagWhereInput is returned in case the TagWhereInput is empty.
var ErrEmptyTagWhereInput = errors.New("ent: empty predicate TagWhereInput")

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, tag.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, tag.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, tag.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, tag.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, tag.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, tag.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, tag.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, tag.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, tag.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, tag.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, tag.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, tag.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, tag.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TransactionWhereInput represents a where input for filtering Transaction queries.
type TransactionWhereInput struct {
	Predicates []predicate.Transaction  `json:"-"`
	Not        *TransactionWhereInput   `json:"not,omitempty"`
	Or         []*TransactionWhereInput `json:"or,omitempty"`
	And        []*TransactionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "status" field predicates.
	Status      *transaction.Status  `json:"status,omitempty"`
	StatusNEQ   *transaction.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []transaction.Status `json:"statusIn,omitempty"`
	StatusNotIn []transaction.Status `json:"statusNotIn,omitempty"`

	// "paymentMethod" field predicates.
	PaymentMethod             *string  `json:"paymentmethod,omitempty"`
	PaymentMethodNEQ          *string  `json:"paymentmethodNEQ,omitempty"`
	PaymentMethodIn           []string `json:"paymentmethodIn,omitempty"`
	PaymentMethodNotIn        []string `json:"paymentmethodNotIn,omitempty"`
	PaymentMethodGT           *string  `json:"paymentmethodGT,omitempty"`
	PaymentMethodGTE          *string  `json:"paymentmethodGTE,omitempty"`
	PaymentMethodLT           *string  `json:"paymentmethodLT,omitempty"`
	PaymentMethodLTE          *string  `json:"paymentmethodLTE,omitempty"`
	PaymentMethodContains     *string  `json:"paymentmethodContains,omitempty"`
	PaymentMethodHasPrefix    *string  `json:"paymentmethodHasPrefix,omitempty"`
	PaymentMethodHasSuffix    *string  `json:"paymentmethodHasSuffix,omitempty"`
	PaymentMethodEqualFold    *string  `json:"paymentmethodEqualFold,omitempty"`
	PaymentMethodContainsFold *string  `json:"paymentmethodContainsFold,omitempty"`

	// "paymentStatus" field predicates.
	PaymentStatus             *string  `json:"paymentstatus,omitempty"`
	PaymentStatusNEQ          *string  `json:"paymentstatusNEQ,omitempty"`
	PaymentStatusIn           []string `json:"paymentstatusIn,omitempty"`
	PaymentStatusNotIn        []string `json:"paymentstatusNotIn,omitempty"`
	PaymentStatusGT           *string  `json:"paymentstatusGT,omitempty"`
	PaymentStatusGTE          *string  `json:"paymentstatusGTE,omitempty"`
	PaymentStatusLT           *string  `json:"paymentstatusLT,omitempty"`
	PaymentStatusLTE          *string  `json:"paymentstatusLTE,omitempty"`
	PaymentStatusContains     *string  `json:"paymentstatusContains,omitempty"`
	PaymentStatusHasPrefix    *string  `json:"paymentstatusHasPrefix,omitempty"`
	PaymentStatusHasSuffix    *string  `json:"paymentstatusHasSuffix,omitempty"`
	PaymentStatusEqualFold    *string  `json:"paymentstatusEqualFold,omitempty"`
	PaymentStatusContainsFold *string  `json:"paymentstatusContainsFold,omitempty"`

	// "paymentId" field predicates.
	PaymentId             *string  `json:"paymentid,omitempty"`
	PaymentIdNEQ          *string  `json:"paymentidNEQ,omitempty"`
	PaymentIdIn           []string `json:"paymentidIn,omitempty"`
	PaymentIdNotIn        []string `json:"paymentidNotIn,omitempty"`
	PaymentIdGT           *string  `json:"paymentidGT,omitempty"`
	PaymentIdGTE          *string  `json:"paymentidGTE,omitempty"`
	PaymentIdLT           *string  `json:"paymentidLT,omitempty"`
	PaymentIdLTE          *string  `json:"paymentidLTE,omitempty"`
	PaymentIdContains     *string  `json:"paymentidContains,omitempty"`
	PaymentIdHasPrefix    *string  `json:"paymentidHasPrefix,omitempty"`
	PaymentIdHasSuffix    *string  `json:"paymentidHasSuffix,omitempty"`
	PaymentIdEqualFold    *string  `json:"paymentidEqualFold,omitempty"`
	PaymentIdContainsFold *string  `json:"paymentidContainsFold,omitempty"`

	// "paymentAmount" field predicates.
	PaymentAmount             *string  `json:"paymentamount,omitempty"`
	PaymentAmountNEQ          *string  `json:"paymentamountNEQ,omitempty"`
	PaymentAmountIn           []string `json:"paymentamountIn,omitempty"`
	PaymentAmountNotIn        []string `json:"paymentamountNotIn,omitempty"`
	PaymentAmountGT           *string  `json:"paymentamountGT,omitempty"`
	PaymentAmountGTE          *string  `json:"paymentamountGTE,omitempty"`
	PaymentAmountLT           *string  `json:"paymentamountLT,omitempty"`
	PaymentAmountLTE          *string  `json:"paymentamountLTE,omitempty"`
	PaymentAmountContains     *string  `json:"paymentamountContains,omitempty"`
	PaymentAmountHasPrefix    *string  `json:"paymentamountHasPrefix,omitempty"`
	PaymentAmountHasSuffix    *string  `json:"paymentamountHasSuffix,omitempty"`
	PaymentAmountEqualFold    *string  `json:"paymentamountEqualFold,omitempty"`
	PaymentAmountContainsFold *string  `json:"paymentamountContainsFold,omitempty"`

	// "paymentCurrency" field predicates.
	PaymentCurrency             *string  `json:"paymentcurrency,omitempty"`
	PaymentCurrencyNEQ          *string  `json:"paymentcurrencyNEQ,omitempty"`
	PaymentCurrencyIn           []string `json:"paymentcurrencyIn,omitempty"`
	PaymentCurrencyNotIn        []string `json:"paymentcurrencyNotIn,omitempty"`
	PaymentCurrencyGT           *string  `json:"paymentcurrencyGT,omitempty"`
	PaymentCurrencyGTE          *string  `json:"paymentcurrencyGTE,omitempty"`
	PaymentCurrencyLT           *string  `json:"paymentcurrencyLT,omitempty"`
	PaymentCurrencyLTE          *string  `json:"paymentcurrencyLTE,omitempty"`
	PaymentCurrencyContains     *string  `json:"paymentcurrencyContains,omitempty"`
	PaymentCurrencyHasPrefix    *string  `json:"paymentcurrencyHasPrefix,omitempty"`
	PaymentCurrencyHasSuffix    *string  `json:"paymentcurrencyHasSuffix,omitempty"`
	PaymentCurrencyEqualFold    *string  `json:"paymentcurrencyEqualFold,omitempty"`
	PaymentCurrencyContainsFold *string  `json:"paymentcurrencyContainsFold,omitempty"`

	// "paymentDate" field predicates.
	PaymentDate             *string  `json:"paymentdate,omitempty"`
	PaymentDateNEQ          *string  `json:"paymentdateNEQ,omitempty"`
	PaymentDateIn           []string `json:"paymentdateIn,omitempty"`
	PaymentDateNotIn        []string `json:"paymentdateNotIn,omitempty"`
	PaymentDateGT           *string  `json:"paymentdateGT,omitempty"`
	PaymentDateGTE          *string  `json:"paymentdateGTE,omitempty"`
	PaymentDateLT           *string  `json:"paymentdateLT,omitempty"`
	PaymentDateLTE          *string  `json:"paymentdateLTE,omitempty"`
	PaymentDateContains     *string  `json:"paymentdateContains,omitempty"`
	PaymentDateHasPrefix    *string  `json:"paymentdateHasPrefix,omitempty"`
	PaymentDateHasSuffix    *string  `json:"paymentdateHasSuffix,omitempty"`
	PaymentDateEqualFold    *string  `json:"paymentdateEqualFold,omitempty"`
	PaymentDateContainsFold *string  `json:"paymentdateContainsFold,omitempty"`

	// "paymentFee" field predicates.
	PaymentFee             *string  `json:"paymentfee,omitempty"`
	PaymentFeeNEQ          *string  `json:"paymentfeeNEQ,omitempty"`
	PaymentFeeIn           []string `json:"paymentfeeIn,omitempty"`
	PaymentFeeNotIn        []string `json:"paymentfeeNotIn,omitempty"`
	PaymentFeeGT           *string  `json:"paymentfeeGT,omitempty"`
	PaymentFeeGTE          *string  `json:"paymentfeeGTE,omitempty"`
	PaymentFeeLT           *string  `json:"paymentfeeLT,omitempty"`
	PaymentFeeLTE          *string  `json:"paymentfeeLTE,omitempty"`
	PaymentFeeContains     *string  `json:"paymentfeeContains,omitempty"`
	PaymentFeeHasPrefix    *string  `json:"paymentfeeHasPrefix,omitempty"`
	PaymentFeeHasSuffix    *string  `json:"paymentfeeHasSuffix,omitempty"`
	PaymentFeeEqualFold    *string  `json:"paymentfeeEqualFold,omitempty"`
	PaymentFeeContainsFold *string  `json:"paymentfeeContainsFold,omitempty"`

	// "paymentNet" field predicates.
	PaymentNet             *string  `json:"paymentnet,omitempty"`
	PaymentNetNEQ          *string  `json:"paymentnetNEQ,omitempty"`
	PaymentNetIn           []string `json:"paymentnetIn,omitempty"`
	PaymentNetNotIn        []string `json:"paymentnetNotIn,omitempty"`
	PaymentNetGT           *string  `json:"paymentnetGT,omitempty"`
	PaymentNetGTE          *string  `json:"paymentnetGTE,omitempty"`
	PaymentNetLT           *string  `json:"paymentnetLT,omitempty"`
	PaymentNetLTE          *string  `json:"paymentnetLTE,omitempty"`
	PaymentNetContains     *string  `json:"paymentnetContains,omitempty"`
	PaymentNetHasPrefix    *string  `json:"paymentnetHasPrefix,omitempty"`
	PaymentNetHasSuffix    *string  `json:"paymentnetHasSuffix,omitempty"`
	PaymentNetEqualFold    *string  `json:"paymentnetEqualFold,omitempty"`
	PaymentNetContainsFold *string  `json:"paymentnetContainsFold,omitempty"`

	// "paymentPayerEmail" field predicates.
	PaymentPayerEmail             *string  `json:"paymentpayeremail,omitempty"`
	PaymentPayerEmailNEQ          *string  `json:"paymentpayeremailNEQ,omitempty"`
	PaymentPayerEmailIn           []string `json:"paymentpayeremailIn,omitempty"`
	PaymentPayerEmailNotIn        []string `json:"paymentpayeremailNotIn,omitempty"`
	PaymentPayerEmailGT           *string  `json:"paymentpayeremailGT,omitempty"`
	PaymentPayerEmailGTE          *string  `json:"paymentpayeremailGTE,omitempty"`
	PaymentPayerEmailLT           *string  `json:"paymentpayeremailLT,omitempty"`
	PaymentPayerEmailLTE          *string  `json:"paymentpayeremailLTE,omitempty"`
	PaymentPayerEmailContains     *string  `json:"paymentpayeremailContains,omitempty"`
	PaymentPayerEmailHasPrefix    *string  `json:"paymentpayeremailHasPrefix,omitempty"`
	PaymentPayerEmailHasSuffix    *string  `json:"paymentpayeremailHasSuffix,omitempty"`
	PaymentPayerEmailEqualFold    *string  `json:"paymentpayeremailEqualFold,omitempty"`
	PaymentPayerEmailContainsFold *string  `json:"paymentpayeremailContainsFold,omitempty"`

	// "paymentPayerFirstName" field predicates.
	PaymentPayerFirstName             *string  `json:"paymentpayerfirstname,omitempty"`
	PaymentPayerFirstNameNEQ          *string  `json:"paymentpayerfirstnameNEQ,omitempty"`
	PaymentPayerFirstNameIn           []string `json:"paymentpayerfirstnameIn,omitempty"`
	PaymentPayerFirstNameNotIn        []string `json:"paymentpayerfirstnameNotIn,omitempty"`
	PaymentPayerFirstNameGT           *string  `json:"paymentpayerfirstnameGT,omitempty"`
	PaymentPayerFirstNameGTE          *string  `json:"paymentpayerfirstnameGTE,omitempty"`
	PaymentPayerFirstNameLT           *string  `json:"paymentpayerfirstnameLT,omitempty"`
	PaymentPayerFirstNameLTE          *string  `json:"paymentpayerfirstnameLTE,omitempty"`
	PaymentPayerFirstNameContains     *string  `json:"paymentpayerfirstnameContains,omitempty"`
	PaymentPayerFirstNameHasPrefix    *string  `json:"paymentpayerfirstnameHasPrefix,omitempty"`
	PaymentPayerFirstNameHasSuffix    *string  `json:"paymentpayerfirstnameHasSuffix,omitempty"`
	PaymentPayerFirstNameEqualFold    *string  `json:"paymentpayerfirstnameEqualFold,omitempty"`
	PaymentPayerFirstNameContainsFold *string  `json:"paymentpayerfirstnameContainsFold,omitempty"`

	// "paymentPayerLastName" field predicates.
	PaymentPayerLastName             *string  `json:"paymentpayerlastname,omitempty"`
	PaymentPayerLastNameNEQ          *string  `json:"paymentpayerlastnameNEQ,omitempty"`
	PaymentPayerLastNameIn           []string `json:"paymentpayerlastnameIn,omitempty"`
	PaymentPayerLastNameNotIn        []string `json:"paymentpayerlastnameNotIn,omitempty"`
	PaymentPayerLastNameGT           *string  `json:"paymentpayerlastnameGT,omitempty"`
	PaymentPayerLastNameGTE          *string  `json:"paymentpayerlastnameGTE,omitempty"`
	PaymentPayerLastNameLT           *string  `json:"paymentpayerlastnameLT,omitempty"`
	PaymentPayerLastNameLTE          *string  `json:"paymentpayerlastnameLTE,omitempty"`
	PaymentPayerLastNameContains     *string  `json:"paymentpayerlastnameContains,omitempty"`
	PaymentPayerLastNameHasPrefix    *string  `json:"paymentpayerlastnameHasPrefix,omitempty"`
	PaymentPayerLastNameHasSuffix    *string  `json:"paymentpayerlastnameHasSuffix,omitempty"`
	PaymentPayerLastNameEqualFold    *string  `json:"paymentpayerlastnameEqualFold,omitempty"`
	PaymentPayerLastNameContainsFold *string  `json:"paymentpayerlastnameContainsFold,omitempty"`

	// "paymentPayerId" field predicates.
	PaymentPayerId             *string  `json:"paymentpayerid,omitempty"`
	PaymentPayerIdNEQ          *string  `json:"paymentpayeridNEQ,omitempty"`
	PaymentPayerIdIn           []string `json:"paymentpayeridIn,omitempty"`
	PaymentPayerIdNotIn        []string `json:"paymentpayeridNotIn,omitempty"`
	PaymentPayerIdGT           *string  `json:"paymentpayeridGT,omitempty"`
	PaymentPayerIdGTE          *string  `json:"paymentpayeridGTE,omitempty"`
	PaymentPayerIdLT           *string  `json:"paymentpayeridLT,omitempty"`
	PaymentPayerIdLTE          *string  `json:"paymentpayeridLTE,omitempty"`
	PaymentPayerIdContains     *string  `json:"paymentpayeridContains,omitempty"`
	PaymentPayerIdHasPrefix    *string  `json:"paymentpayeridHasPrefix,omitempty"`
	PaymentPayerIdHasSuffix    *string  `json:"paymentpayeridHasSuffix,omitempty"`
	PaymentPayerIdEqualFold    *string  `json:"paymentpayeridEqualFold,omitempty"`
	PaymentPayerIdContainsFold *string  `json:"paymentpayeridContainsFold,omitempty"`

	// "paymentPayerStatus" field predicates.
	PaymentPayerStatus             *string  `json:"paymentpayerstatus,omitempty"`
	PaymentPayerStatusNEQ          *string  `json:"paymentpayerstatusNEQ,omitempty"`
	PaymentPayerStatusIn           []string `json:"paymentpayerstatusIn,omitempty"`
	PaymentPayerStatusNotIn        []string `json:"paymentpayerstatusNotIn,omitempty"`
	PaymentPayerStatusGT           *string  `json:"paymentpayerstatusGT,omitempty"`
	PaymentPayerStatusGTE          *string  `json:"paymentpayerstatusGTE,omitempty"`
	PaymentPayerStatusLT           *string  `json:"paymentpayerstatusLT,omitempty"`
	PaymentPayerStatusLTE          *string  `json:"paymentpayerstatusLTE,omitempty"`
	PaymentPayerStatusContains     *string  `json:"paymentpayerstatusContains,omitempty"`
	PaymentPayerStatusHasPrefix    *string  `json:"paymentpayerstatusHasPrefix,omitempty"`
	PaymentPayerStatusHasSuffix    *string  `json:"paymentpayerstatusHasSuffix,omitempty"`
	PaymentPayerStatusEqualFold    *string  `json:"paymentpayerstatusEqualFold,omitempty"`
	PaymentPayerStatusContainsFold *string  `json:"paymentpayerstatusContainsFold,omitempty"`

	// "paymentReceiverEmail" field predicates.
	PaymentReceiverEmail             *string  `json:"paymentreceiveremail,omitempty"`
	PaymentReceiverEmailNEQ          *string  `json:"paymentreceiveremailNEQ,omitempty"`
	PaymentReceiverEmailIn           []string `json:"paymentreceiveremailIn,omitempty"`
	PaymentReceiverEmailNotIn        []string `json:"paymentreceiveremailNotIn,omitempty"`
	PaymentReceiverEmailGT           *string  `json:"paymentreceiveremailGT,omitempty"`
	PaymentReceiverEmailGTE          *string  `json:"paymentreceiveremailGTE,omitempty"`
	PaymentReceiverEmailLT           *string  `json:"paymentreceiveremailLT,omitempty"`
	PaymentReceiverEmailLTE          *string  `json:"paymentreceiveremailLTE,omitempty"`
	PaymentReceiverEmailContains     *string  `json:"paymentreceiveremailContains,omitempty"`
	PaymentReceiverEmailHasPrefix    *string  `json:"paymentreceiveremailHasPrefix,omitempty"`
	PaymentReceiverEmailHasSuffix    *string  `json:"paymentreceiveremailHasSuffix,omitempty"`
	PaymentReceiverEmailEqualFold    *string  `json:"paymentreceiveremailEqualFold,omitempty"`
	PaymentReceiverEmailContainsFold *string  `json:"paymentreceiveremailContainsFold,omitempty"`

	// "paymentReceiverId" field predicates.
	PaymentReceiverId             *string  `json:"paymentreceiverid,omitempty"`
	PaymentReceiverIdNEQ          *string  `json:"paymentreceiveridNEQ,omitempty"`
	PaymentReceiverIdIn           []string `json:"paymentreceiveridIn,omitempty"`
	PaymentReceiverIdNotIn        []string `json:"paymentreceiveridNotIn,omitempty"`
	PaymentReceiverIdGT           *string  `json:"paymentreceiveridGT,omitempty"`
	PaymentReceiverIdGTE          *string  `json:"paymentreceiveridGTE,omitempty"`
	PaymentReceiverIdLT           *string  `json:"paymentreceiveridLT,omitempty"`
	PaymentReceiverIdLTE          *string  `json:"paymentreceiveridLTE,omitempty"`
	PaymentReceiverIdContains     *string  `json:"paymentreceiveridContains,omitempty"`
	PaymentReceiverIdHasPrefix    *string  `json:"paymentreceiveridHasPrefix,omitempty"`
	PaymentReceiverIdHasSuffix    *string  `json:"paymentreceiveridHasSuffix,omitempty"`
	PaymentReceiverIdEqualFold    *string  `json:"paymentreceiveridEqualFold,omitempty"`
	PaymentReceiverIdContainsFold *string  `json:"paymentreceiveridContainsFold,omitempty"`

	// "paymentTax" field predicates.
	PaymentTax             *string  `json:"paymenttax,omitempty"`
	PaymentTaxNEQ          *string  `json:"paymenttaxNEQ,omitempty"`
	PaymentTaxIn           []string `json:"paymenttaxIn,omitempty"`
	PaymentTaxNotIn        []string `json:"paymenttaxNotIn,omitempty"`
	PaymentTaxGT           *string  `json:"paymenttaxGT,omitempty"`
	PaymentTaxGTE          *string  `json:"paymenttaxGTE,omitempty"`
	PaymentTaxLT           *string  `json:"paymenttaxLT,omitempty"`
	PaymentTaxLTE          *string  `json:"paymenttaxLTE,omitempty"`
	PaymentTaxContains     *string  `json:"paymenttaxContains,omitempty"`
	PaymentTaxHasPrefix    *string  `json:"paymenttaxHasPrefix,omitempty"`
	PaymentTaxHasSuffix    *string  `json:"paymenttaxHasSuffix,omitempty"`
	PaymentTaxEqualFold    *string  `json:"paymenttaxEqualFold,omitempty"`
	PaymentTaxContainsFold *string  `json:"paymenttaxContainsFold,omitempty"`

	// "paymentTransactionId" field predicates.
	PaymentTransactionId             *string  `json:"paymenttransactionid,omitempty"`
	PaymentTransactionIdNEQ          *string  `json:"paymenttransactionidNEQ,omitempty"`
	PaymentTransactionIdIn           []string `json:"paymenttransactionidIn,omitempty"`
	PaymentTransactionIdNotIn        []string `json:"paymenttransactionidNotIn,omitempty"`
	PaymentTransactionIdGT           *string  `json:"paymenttransactionidGT,omitempty"`
	PaymentTransactionIdGTE          *string  `json:"paymenttransactionidGTE,omitempty"`
	PaymentTransactionIdLT           *string  `json:"paymenttransactionidLT,omitempty"`
	PaymentTransactionIdLTE          *string  `json:"paymenttransactionidLTE,omitempty"`
	PaymentTransactionIdContains     *string  `json:"paymenttransactionidContains,omitempty"`
	PaymentTransactionIdHasPrefix    *string  `json:"paymenttransactionidHasPrefix,omitempty"`
	PaymentTransactionIdHasSuffix    *string  `json:"paymenttransactionidHasSuffix,omitempty"`
	PaymentTransactionIdEqualFold    *string  `json:"paymenttransactionidEqualFold,omitempty"`
	PaymentTransactionIdContainsFold *string  `json:"paymenttransactionidContainsFold,omitempty"`

	// "paymentTransactionType" field predicates.
	PaymentTransactionType             *string  `json:"paymenttransactiontype,omitempty"`
	PaymentTransactionTypeNEQ          *string  `json:"paymenttransactiontypeNEQ,omitempty"`
	PaymentTransactionTypeIn           []string `json:"paymenttransactiontypeIn,omitempty"`
	PaymentTransactionTypeNotIn        []string `json:"paymenttransactiontypeNotIn,omitempty"`
	PaymentTransactionTypeGT           *string  `json:"paymenttransactiontypeGT,omitempty"`
	PaymentTransactionTypeGTE          *string  `json:"paymenttransactiontypeGTE,omitempty"`
	PaymentTransactionTypeLT           *string  `json:"paymenttransactiontypeLT,omitempty"`
	PaymentTransactionTypeLTE          *string  `json:"paymenttransactiontypeLTE,omitempty"`
	PaymentTransactionTypeContains     *string  `json:"paymenttransactiontypeContains,omitempty"`
	PaymentTransactionTypeHasPrefix    *string  `json:"paymenttransactiontypeHasPrefix,omitempty"`
	PaymentTransactionTypeHasSuffix    *string  `json:"paymenttransactiontypeHasSuffix,omitempty"`
	PaymentTransactionTypeEqualFold    *string  `json:"paymenttransactiontypeEqualFold,omitempty"`
	PaymentTransactionTypeContainsFold *string  `json:"paymenttransactiontypeContainsFold,omitempty"`

	// "paymentPendingReason" field predicates.
	PaymentPendingReason             *string  `json:"paymentpendingreason,omitempty"`
	PaymentPendingReasonNEQ          *string  `json:"paymentpendingreasonNEQ,omitempty"`
	PaymentPendingReasonIn           []string `json:"paymentpendingreasonIn,omitempty"`
	PaymentPendingReasonNotIn        []string `json:"paymentpendingreasonNotIn,omitempty"`
	PaymentPendingReasonGT           *string  `json:"paymentpendingreasonGT,omitempty"`
	PaymentPendingReasonGTE          *string  `json:"paymentpendingreasonGTE,omitempty"`
	PaymentPendingReasonLT           *string  `json:"paymentpendingreasonLT,omitempty"`
	PaymentPendingReasonLTE          *string  `json:"paymentpendingreasonLTE,omitempty"`
	PaymentPendingReasonContains     *string  `json:"paymentpendingreasonContains,omitempty"`
	PaymentPendingReasonHasPrefix    *string  `json:"paymentpendingreasonHasPrefix,omitempty"`
	PaymentPendingReasonHasSuffix    *string  `json:"paymentpendingreasonHasSuffix,omitempty"`
	PaymentPendingReasonEqualFold    *string  `json:"paymentpendingreasonEqualFold,omitempty"`
	PaymentPendingReasonContainsFold *string  `json:"paymentpendingreasonContainsFold,omitempty"`

	// "paymentReasonCode" field predicates.
	PaymentReasonCode             *string  `json:"paymentreasoncode,omitempty"`
	PaymentReasonCodeNEQ          *string  `json:"paymentreasoncodeNEQ,omitempty"`
	PaymentReasonCodeIn           []string `json:"paymentreasoncodeIn,omitempty"`
	PaymentReasonCodeNotIn        []string `json:"paymentreasoncodeNotIn,omitempty"`
	PaymentReasonCodeGT           *string  `json:"paymentreasoncodeGT,omitempty"`
	PaymentReasonCodeGTE          *string  `json:"paymentreasoncodeGTE,omitempty"`
	PaymentReasonCodeLT           *string  `json:"paymentreasoncodeLT,omitempty"`
	PaymentReasonCodeLTE          *string  `json:"paymentreasoncodeLTE,omitempty"`
	PaymentReasonCodeContains     *string  `json:"paymentreasoncodeContains,omitempty"`
	PaymentReasonCodeHasPrefix    *string  `json:"paymentreasoncodeHasPrefix,omitempty"`
	PaymentReasonCodeHasSuffix    *string  `json:"paymentreasoncodeHasSuffix,omitempty"`
	PaymentReasonCodeEqualFold    *string  `json:"paymentreasoncodeEqualFold,omitempty"`
	PaymentReasonCodeContainsFold *string  `json:"paymentreasoncodeContainsFold,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "originLink" edge predicates.
	HasOriginLink     *bool                  `json:"hasOriginLink,omitempty"`
	HasOriginLinkWith []*LinkVisitWhereInput `json:"hasOriginLinkWith,omitempty"`

	// "productCustomer" edge predicates.
	HasProductCustomer     *bool                  `json:"hasProductCustomer,omitempty"`
	HasProductCustomerWith []*UserBuyerWhereInput `json:"hasProductCustomerWith,omitempty"`

	// "shop" edge predicates.
	HasShop     *bool             `json:"hasShop,omitempty"`
	HasShopWith []*ShopWhereInput `json:"hasShopWith,omitempty"`

	// "productInfluencer" edge predicates.
	HasProductInfluencer     *bool                       `json:"hasProductInfluencer,omitempty"`
	HasProductInfluencerWith []*UserInfluencerWhereInput `json:"hasProductInfluencerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TransactionWhereInput) AddPredicates(predicates ...predicate.Transaction) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TransactionWhereInput filter on the TransactionQuery builder.
func (i *TransactionWhereInput) Filter(q *TransactionQuery) (*TransactionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTransactionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTransactionWhereInput is returned in case the TransactionWhereInput is empty.
var ErrEmptyTransactionWhereInput = errors.New("ent: empty predicate TransactionWhereInput")

// P returns a predicate for filtering transactions.
// An error is returned if the input is empty or invalid.
func (i *TransactionWhereInput) P() (predicate.Transaction, error) {
	var predicates []predicate.Transaction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, transaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Transaction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, transaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Transaction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, transaction.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, transaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transaction.IDLTE(*i.IDLTE))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, transaction.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, transaction.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, transaction.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, transaction.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, transaction.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, transaction.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, transaction.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, transaction.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, transaction.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, transaction.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, transaction.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, transaction.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, transaction.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, transaction.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, transaction.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, transaction.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, transaction.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, transaction.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, transaction.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, transaction.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, transaction.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, transaction.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, transaction.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, transaction.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, transaction.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, transaction.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, transaction.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, transaction.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, transaction.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, transaction.StatusNotIn(i.StatusNotIn...))
	}
	if i.PaymentMethod != nil {
		predicates = append(predicates, transaction.PaymentMethodEQ(*i.PaymentMethod))
	}
	if i.PaymentMethodNEQ != nil {
		predicates = append(predicates, transaction.PaymentMethodNEQ(*i.PaymentMethodNEQ))
	}
	if len(i.PaymentMethodIn) > 0 {
		predicates = append(predicates, transaction.PaymentMethodIn(i.PaymentMethodIn...))
	}
	if len(i.PaymentMethodNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentMethodNotIn(i.PaymentMethodNotIn...))
	}
	if i.PaymentMethodGT != nil {
		predicates = append(predicates, transaction.PaymentMethodGT(*i.PaymentMethodGT))
	}
	if i.PaymentMethodGTE != nil {
		predicates = append(predicates, transaction.PaymentMethodGTE(*i.PaymentMethodGTE))
	}
	if i.PaymentMethodLT != nil {
		predicates = append(predicates, transaction.PaymentMethodLT(*i.PaymentMethodLT))
	}
	if i.PaymentMethodLTE != nil {
		predicates = append(predicates, transaction.PaymentMethodLTE(*i.PaymentMethodLTE))
	}
	if i.PaymentMethodContains != nil {
		predicates = append(predicates, transaction.PaymentMethodContains(*i.PaymentMethodContains))
	}
	if i.PaymentMethodHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentMethodHasPrefix(*i.PaymentMethodHasPrefix))
	}
	if i.PaymentMethodHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentMethodHasSuffix(*i.PaymentMethodHasSuffix))
	}
	if i.PaymentMethodEqualFold != nil {
		predicates = append(predicates, transaction.PaymentMethodEqualFold(*i.PaymentMethodEqualFold))
	}
	if i.PaymentMethodContainsFold != nil {
		predicates = append(predicates, transaction.PaymentMethodContainsFold(*i.PaymentMethodContainsFold))
	}
	if i.PaymentStatus != nil {
		predicates = append(predicates, transaction.PaymentStatusEQ(*i.PaymentStatus))
	}
	if i.PaymentStatusNEQ != nil {
		predicates = append(predicates, transaction.PaymentStatusNEQ(*i.PaymentStatusNEQ))
	}
	if len(i.PaymentStatusIn) > 0 {
		predicates = append(predicates, transaction.PaymentStatusIn(i.PaymentStatusIn...))
	}
	if len(i.PaymentStatusNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentStatusNotIn(i.PaymentStatusNotIn...))
	}
	if i.PaymentStatusGT != nil {
		predicates = append(predicates, transaction.PaymentStatusGT(*i.PaymentStatusGT))
	}
	if i.PaymentStatusGTE != nil {
		predicates = append(predicates, transaction.PaymentStatusGTE(*i.PaymentStatusGTE))
	}
	if i.PaymentStatusLT != nil {
		predicates = append(predicates, transaction.PaymentStatusLT(*i.PaymentStatusLT))
	}
	if i.PaymentStatusLTE != nil {
		predicates = append(predicates, transaction.PaymentStatusLTE(*i.PaymentStatusLTE))
	}
	if i.PaymentStatusContains != nil {
		predicates = append(predicates, transaction.PaymentStatusContains(*i.PaymentStatusContains))
	}
	if i.PaymentStatusHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentStatusHasPrefix(*i.PaymentStatusHasPrefix))
	}
	if i.PaymentStatusHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentStatusHasSuffix(*i.PaymentStatusHasSuffix))
	}
	if i.PaymentStatusEqualFold != nil {
		predicates = append(predicates, transaction.PaymentStatusEqualFold(*i.PaymentStatusEqualFold))
	}
	if i.PaymentStatusContainsFold != nil {
		predicates = append(predicates, transaction.PaymentStatusContainsFold(*i.PaymentStatusContainsFold))
	}
	if i.PaymentId != nil {
		predicates = append(predicates, transaction.PaymentIdEQ(*i.PaymentId))
	}
	if i.PaymentIdNEQ != nil {
		predicates = append(predicates, transaction.PaymentIdNEQ(*i.PaymentIdNEQ))
	}
	if len(i.PaymentIdIn) > 0 {
		predicates = append(predicates, transaction.PaymentIdIn(i.PaymentIdIn...))
	}
	if len(i.PaymentIdNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentIdNotIn(i.PaymentIdNotIn...))
	}
	if i.PaymentIdGT != nil {
		predicates = append(predicates, transaction.PaymentIdGT(*i.PaymentIdGT))
	}
	if i.PaymentIdGTE != nil {
		predicates = append(predicates, transaction.PaymentIdGTE(*i.PaymentIdGTE))
	}
	if i.PaymentIdLT != nil {
		predicates = append(predicates, transaction.PaymentIdLT(*i.PaymentIdLT))
	}
	if i.PaymentIdLTE != nil {
		predicates = append(predicates, transaction.PaymentIdLTE(*i.PaymentIdLTE))
	}
	if i.PaymentIdContains != nil {
		predicates = append(predicates, transaction.PaymentIdContains(*i.PaymentIdContains))
	}
	if i.PaymentIdHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentIdHasPrefix(*i.PaymentIdHasPrefix))
	}
	if i.PaymentIdHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentIdHasSuffix(*i.PaymentIdHasSuffix))
	}
	if i.PaymentIdEqualFold != nil {
		predicates = append(predicates, transaction.PaymentIdEqualFold(*i.PaymentIdEqualFold))
	}
	if i.PaymentIdContainsFold != nil {
		predicates = append(predicates, transaction.PaymentIdContainsFold(*i.PaymentIdContainsFold))
	}
	if i.PaymentAmount != nil {
		predicates = append(predicates, transaction.PaymentAmountEQ(*i.PaymentAmount))
	}
	if i.PaymentAmountNEQ != nil {
		predicates = append(predicates, transaction.PaymentAmountNEQ(*i.PaymentAmountNEQ))
	}
	if len(i.PaymentAmountIn) > 0 {
		predicates = append(predicates, transaction.PaymentAmountIn(i.PaymentAmountIn...))
	}
	if len(i.PaymentAmountNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentAmountNotIn(i.PaymentAmountNotIn...))
	}
	if i.PaymentAmountGT != nil {
		predicates = append(predicates, transaction.PaymentAmountGT(*i.PaymentAmountGT))
	}
	if i.PaymentAmountGTE != nil {
		predicates = append(predicates, transaction.PaymentAmountGTE(*i.PaymentAmountGTE))
	}
	if i.PaymentAmountLT != nil {
		predicates = append(predicates, transaction.PaymentAmountLT(*i.PaymentAmountLT))
	}
	if i.PaymentAmountLTE != nil {
		predicates = append(predicates, transaction.PaymentAmountLTE(*i.PaymentAmountLTE))
	}
	if i.PaymentAmountContains != nil {
		predicates = append(predicates, transaction.PaymentAmountContains(*i.PaymentAmountContains))
	}
	if i.PaymentAmountHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentAmountHasPrefix(*i.PaymentAmountHasPrefix))
	}
	if i.PaymentAmountHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentAmountHasSuffix(*i.PaymentAmountHasSuffix))
	}
	if i.PaymentAmountEqualFold != nil {
		predicates = append(predicates, transaction.PaymentAmountEqualFold(*i.PaymentAmountEqualFold))
	}
	if i.PaymentAmountContainsFold != nil {
		predicates = append(predicates, transaction.PaymentAmountContainsFold(*i.PaymentAmountContainsFold))
	}
	if i.PaymentCurrency != nil {
		predicates = append(predicates, transaction.PaymentCurrencyEQ(*i.PaymentCurrency))
	}
	if i.PaymentCurrencyNEQ != nil {
		predicates = append(predicates, transaction.PaymentCurrencyNEQ(*i.PaymentCurrencyNEQ))
	}
	if len(i.PaymentCurrencyIn) > 0 {
		predicates = append(predicates, transaction.PaymentCurrencyIn(i.PaymentCurrencyIn...))
	}
	if len(i.PaymentCurrencyNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentCurrencyNotIn(i.PaymentCurrencyNotIn...))
	}
	if i.PaymentCurrencyGT != nil {
		predicates = append(predicates, transaction.PaymentCurrencyGT(*i.PaymentCurrencyGT))
	}
	if i.PaymentCurrencyGTE != nil {
		predicates = append(predicates, transaction.PaymentCurrencyGTE(*i.PaymentCurrencyGTE))
	}
	if i.PaymentCurrencyLT != nil {
		predicates = append(predicates, transaction.PaymentCurrencyLT(*i.PaymentCurrencyLT))
	}
	if i.PaymentCurrencyLTE != nil {
		predicates = append(predicates, transaction.PaymentCurrencyLTE(*i.PaymentCurrencyLTE))
	}
	if i.PaymentCurrencyContains != nil {
		predicates = append(predicates, transaction.PaymentCurrencyContains(*i.PaymentCurrencyContains))
	}
	if i.PaymentCurrencyHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentCurrencyHasPrefix(*i.PaymentCurrencyHasPrefix))
	}
	if i.PaymentCurrencyHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentCurrencyHasSuffix(*i.PaymentCurrencyHasSuffix))
	}
	if i.PaymentCurrencyEqualFold != nil {
		predicates = append(predicates, transaction.PaymentCurrencyEqualFold(*i.PaymentCurrencyEqualFold))
	}
	if i.PaymentCurrencyContainsFold != nil {
		predicates = append(predicates, transaction.PaymentCurrencyContainsFold(*i.PaymentCurrencyContainsFold))
	}
	if i.PaymentDate != nil {
		predicates = append(predicates, transaction.PaymentDateEQ(*i.PaymentDate))
	}
	if i.PaymentDateNEQ != nil {
		predicates = append(predicates, transaction.PaymentDateNEQ(*i.PaymentDateNEQ))
	}
	if len(i.PaymentDateIn) > 0 {
		predicates = append(predicates, transaction.PaymentDateIn(i.PaymentDateIn...))
	}
	if len(i.PaymentDateNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentDateNotIn(i.PaymentDateNotIn...))
	}
	if i.PaymentDateGT != nil {
		predicates = append(predicates, transaction.PaymentDateGT(*i.PaymentDateGT))
	}
	if i.PaymentDateGTE != nil {
		predicates = append(predicates, transaction.PaymentDateGTE(*i.PaymentDateGTE))
	}
	if i.PaymentDateLT != nil {
		predicates = append(predicates, transaction.PaymentDateLT(*i.PaymentDateLT))
	}
	if i.PaymentDateLTE != nil {
		predicates = append(predicates, transaction.PaymentDateLTE(*i.PaymentDateLTE))
	}
	if i.PaymentDateContains != nil {
		predicates = append(predicates, transaction.PaymentDateContains(*i.PaymentDateContains))
	}
	if i.PaymentDateHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentDateHasPrefix(*i.PaymentDateHasPrefix))
	}
	if i.PaymentDateHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentDateHasSuffix(*i.PaymentDateHasSuffix))
	}
	if i.PaymentDateEqualFold != nil {
		predicates = append(predicates, transaction.PaymentDateEqualFold(*i.PaymentDateEqualFold))
	}
	if i.PaymentDateContainsFold != nil {
		predicates = append(predicates, transaction.PaymentDateContainsFold(*i.PaymentDateContainsFold))
	}
	if i.PaymentFee != nil {
		predicates = append(predicates, transaction.PaymentFeeEQ(*i.PaymentFee))
	}
	if i.PaymentFeeNEQ != nil {
		predicates = append(predicates, transaction.PaymentFeeNEQ(*i.PaymentFeeNEQ))
	}
	if len(i.PaymentFeeIn) > 0 {
		predicates = append(predicates, transaction.PaymentFeeIn(i.PaymentFeeIn...))
	}
	if len(i.PaymentFeeNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentFeeNotIn(i.PaymentFeeNotIn...))
	}
	if i.PaymentFeeGT != nil {
		predicates = append(predicates, transaction.PaymentFeeGT(*i.PaymentFeeGT))
	}
	if i.PaymentFeeGTE != nil {
		predicates = append(predicates, transaction.PaymentFeeGTE(*i.PaymentFeeGTE))
	}
	if i.PaymentFeeLT != nil {
		predicates = append(predicates, transaction.PaymentFeeLT(*i.PaymentFeeLT))
	}
	if i.PaymentFeeLTE != nil {
		predicates = append(predicates, transaction.PaymentFeeLTE(*i.PaymentFeeLTE))
	}
	if i.PaymentFeeContains != nil {
		predicates = append(predicates, transaction.PaymentFeeContains(*i.PaymentFeeContains))
	}
	if i.PaymentFeeHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentFeeHasPrefix(*i.PaymentFeeHasPrefix))
	}
	if i.PaymentFeeHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentFeeHasSuffix(*i.PaymentFeeHasSuffix))
	}
	if i.PaymentFeeEqualFold != nil {
		predicates = append(predicates, transaction.PaymentFeeEqualFold(*i.PaymentFeeEqualFold))
	}
	if i.PaymentFeeContainsFold != nil {
		predicates = append(predicates, transaction.PaymentFeeContainsFold(*i.PaymentFeeContainsFold))
	}
	if i.PaymentNet != nil {
		predicates = append(predicates, transaction.PaymentNetEQ(*i.PaymentNet))
	}
	if i.PaymentNetNEQ != nil {
		predicates = append(predicates, transaction.PaymentNetNEQ(*i.PaymentNetNEQ))
	}
	if len(i.PaymentNetIn) > 0 {
		predicates = append(predicates, transaction.PaymentNetIn(i.PaymentNetIn...))
	}
	if len(i.PaymentNetNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentNetNotIn(i.PaymentNetNotIn...))
	}
	if i.PaymentNetGT != nil {
		predicates = append(predicates, transaction.PaymentNetGT(*i.PaymentNetGT))
	}
	if i.PaymentNetGTE != nil {
		predicates = append(predicates, transaction.PaymentNetGTE(*i.PaymentNetGTE))
	}
	if i.PaymentNetLT != nil {
		predicates = append(predicates, transaction.PaymentNetLT(*i.PaymentNetLT))
	}
	if i.PaymentNetLTE != nil {
		predicates = append(predicates, transaction.PaymentNetLTE(*i.PaymentNetLTE))
	}
	if i.PaymentNetContains != nil {
		predicates = append(predicates, transaction.PaymentNetContains(*i.PaymentNetContains))
	}
	if i.PaymentNetHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentNetHasPrefix(*i.PaymentNetHasPrefix))
	}
	if i.PaymentNetHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentNetHasSuffix(*i.PaymentNetHasSuffix))
	}
	if i.PaymentNetEqualFold != nil {
		predicates = append(predicates, transaction.PaymentNetEqualFold(*i.PaymentNetEqualFold))
	}
	if i.PaymentNetContainsFold != nil {
		predicates = append(predicates, transaction.PaymentNetContainsFold(*i.PaymentNetContainsFold))
	}
	if i.PaymentPayerEmail != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailEQ(*i.PaymentPayerEmail))
	}
	if i.PaymentPayerEmailNEQ != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailNEQ(*i.PaymentPayerEmailNEQ))
	}
	if len(i.PaymentPayerEmailIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerEmailIn(i.PaymentPayerEmailIn...))
	}
	if len(i.PaymentPayerEmailNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerEmailNotIn(i.PaymentPayerEmailNotIn...))
	}
	if i.PaymentPayerEmailGT != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailGT(*i.PaymentPayerEmailGT))
	}
	if i.PaymentPayerEmailGTE != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailGTE(*i.PaymentPayerEmailGTE))
	}
	if i.PaymentPayerEmailLT != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailLT(*i.PaymentPayerEmailLT))
	}
	if i.PaymentPayerEmailLTE != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailLTE(*i.PaymentPayerEmailLTE))
	}
	if i.PaymentPayerEmailContains != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailContains(*i.PaymentPayerEmailContains))
	}
	if i.PaymentPayerEmailHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailHasPrefix(*i.PaymentPayerEmailHasPrefix))
	}
	if i.PaymentPayerEmailHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailHasSuffix(*i.PaymentPayerEmailHasSuffix))
	}
	if i.PaymentPayerEmailEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailEqualFold(*i.PaymentPayerEmailEqualFold))
	}
	if i.PaymentPayerEmailContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPayerEmailContainsFold(*i.PaymentPayerEmailContainsFold))
	}
	if i.PaymentPayerFirstName != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameEQ(*i.PaymentPayerFirstName))
	}
	if i.PaymentPayerFirstNameNEQ != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameNEQ(*i.PaymentPayerFirstNameNEQ))
	}
	if len(i.PaymentPayerFirstNameIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerFirstNameIn(i.PaymentPayerFirstNameIn...))
	}
	if len(i.PaymentPayerFirstNameNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerFirstNameNotIn(i.PaymentPayerFirstNameNotIn...))
	}
	if i.PaymentPayerFirstNameGT != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameGT(*i.PaymentPayerFirstNameGT))
	}
	if i.PaymentPayerFirstNameGTE != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameGTE(*i.PaymentPayerFirstNameGTE))
	}
	if i.PaymentPayerFirstNameLT != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameLT(*i.PaymentPayerFirstNameLT))
	}
	if i.PaymentPayerFirstNameLTE != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameLTE(*i.PaymentPayerFirstNameLTE))
	}
	if i.PaymentPayerFirstNameContains != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameContains(*i.PaymentPayerFirstNameContains))
	}
	if i.PaymentPayerFirstNameHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameHasPrefix(*i.PaymentPayerFirstNameHasPrefix))
	}
	if i.PaymentPayerFirstNameHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameHasSuffix(*i.PaymentPayerFirstNameHasSuffix))
	}
	if i.PaymentPayerFirstNameEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameEqualFold(*i.PaymentPayerFirstNameEqualFold))
	}
	if i.PaymentPayerFirstNameContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPayerFirstNameContainsFold(*i.PaymentPayerFirstNameContainsFold))
	}
	if i.PaymentPayerLastName != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameEQ(*i.PaymentPayerLastName))
	}
	if i.PaymentPayerLastNameNEQ != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameNEQ(*i.PaymentPayerLastNameNEQ))
	}
	if len(i.PaymentPayerLastNameIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerLastNameIn(i.PaymentPayerLastNameIn...))
	}
	if len(i.PaymentPayerLastNameNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerLastNameNotIn(i.PaymentPayerLastNameNotIn...))
	}
	if i.PaymentPayerLastNameGT != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameGT(*i.PaymentPayerLastNameGT))
	}
	if i.PaymentPayerLastNameGTE != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameGTE(*i.PaymentPayerLastNameGTE))
	}
	if i.PaymentPayerLastNameLT != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameLT(*i.PaymentPayerLastNameLT))
	}
	if i.PaymentPayerLastNameLTE != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameLTE(*i.PaymentPayerLastNameLTE))
	}
	if i.PaymentPayerLastNameContains != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameContains(*i.PaymentPayerLastNameContains))
	}
	if i.PaymentPayerLastNameHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameHasPrefix(*i.PaymentPayerLastNameHasPrefix))
	}
	if i.PaymentPayerLastNameHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameHasSuffix(*i.PaymentPayerLastNameHasSuffix))
	}
	if i.PaymentPayerLastNameEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameEqualFold(*i.PaymentPayerLastNameEqualFold))
	}
	if i.PaymentPayerLastNameContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPayerLastNameContainsFold(*i.PaymentPayerLastNameContainsFold))
	}
	if i.PaymentPayerId != nil {
		predicates = append(predicates, transaction.PaymentPayerIdEQ(*i.PaymentPayerId))
	}
	if i.PaymentPayerIdNEQ != nil {
		predicates = append(predicates, transaction.PaymentPayerIdNEQ(*i.PaymentPayerIdNEQ))
	}
	if len(i.PaymentPayerIdIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerIdIn(i.PaymentPayerIdIn...))
	}
	if len(i.PaymentPayerIdNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerIdNotIn(i.PaymentPayerIdNotIn...))
	}
	if i.PaymentPayerIdGT != nil {
		predicates = append(predicates, transaction.PaymentPayerIdGT(*i.PaymentPayerIdGT))
	}
	if i.PaymentPayerIdGTE != nil {
		predicates = append(predicates, transaction.PaymentPayerIdGTE(*i.PaymentPayerIdGTE))
	}
	if i.PaymentPayerIdLT != nil {
		predicates = append(predicates, transaction.PaymentPayerIdLT(*i.PaymentPayerIdLT))
	}
	if i.PaymentPayerIdLTE != nil {
		predicates = append(predicates, transaction.PaymentPayerIdLTE(*i.PaymentPayerIdLTE))
	}
	if i.PaymentPayerIdContains != nil {
		predicates = append(predicates, transaction.PaymentPayerIdContains(*i.PaymentPayerIdContains))
	}
	if i.PaymentPayerIdHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPayerIdHasPrefix(*i.PaymentPayerIdHasPrefix))
	}
	if i.PaymentPayerIdHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPayerIdHasSuffix(*i.PaymentPayerIdHasSuffix))
	}
	if i.PaymentPayerIdEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPayerIdEqualFold(*i.PaymentPayerIdEqualFold))
	}
	if i.PaymentPayerIdContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPayerIdContainsFold(*i.PaymentPayerIdContainsFold))
	}
	if i.PaymentPayerStatus != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusEQ(*i.PaymentPayerStatus))
	}
	if i.PaymentPayerStatusNEQ != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusNEQ(*i.PaymentPayerStatusNEQ))
	}
	if len(i.PaymentPayerStatusIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerStatusIn(i.PaymentPayerStatusIn...))
	}
	if len(i.PaymentPayerStatusNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPayerStatusNotIn(i.PaymentPayerStatusNotIn...))
	}
	if i.PaymentPayerStatusGT != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusGT(*i.PaymentPayerStatusGT))
	}
	if i.PaymentPayerStatusGTE != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusGTE(*i.PaymentPayerStatusGTE))
	}
	if i.PaymentPayerStatusLT != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusLT(*i.PaymentPayerStatusLT))
	}
	if i.PaymentPayerStatusLTE != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusLTE(*i.PaymentPayerStatusLTE))
	}
	if i.PaymentPayerStatusContains != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusContains(*i.PaymentPayerStatusContains))
	}
	if i.PaymentPayerStatusHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusHasPrefix(*i.PaymentPayerStatusHasPrefix))
	}
	if i.PaymentPayerStatusHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusHasSuffix(*i.PaymentPayerStatusHasSuffix))
	}
	if i.PaymentPayerStatusEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusEqualFold(*i.PaymentPayerStatusEqualFold))
	}
	if i.PaymentPayerStatusContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPayerStatusContainsFold(*i.PaymentPayerStatusContainsFold))
	}
	if i.PaymentReceiverEmail != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailEQ(*i.PaymentReceiverEmail))
	}
	if i.PaymentReceiverEmailNEQ != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailNEQ(*i.PaymentReceiverEmailNEQ))
	}
	if len(i.PaymentReceiverEmailIn) > 0 {
		predicates = append(predicates, transaction.PaymentReceiverEmailIn(i.PaymentReceiverEmailIn...))
	}
	if len(i.PaymentReceiverEmailNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentReceiverEmailNotIn(i.PaymentReceiverEmailNotIn...))
	}
	if i.PaymentReceiverEmailGT != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailGT(*i.PaymentReceiverEmailGT))
	}
	if i.PaymentReceiverEmailGTE != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailGTE(*i.PaymentReceiverEmailGTE))
	}
	if i.PaymentReceiverEmailLT != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailLT(*i.PaymentReceiverEmailLT))
	}
	if i.PaymentReceiverEmailLTE != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailLTE(*i.PaymentReceiverEmailLTE))
	}
	if i.PaymentReceiverEmailContains != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailContains(*i.PaymentReceiverEmailContains))
	}
	if i.PaymentReceiverEmailHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailHasPrefix(*i.PaymentReceiverEmailHasPrefix))
	}
	if i.PaymentReceiverEmailHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailHasSuffix(*i.PaymentReceiverEmailHasSuffix))
	}
	if i.PaymentReceiverEmailEqualFold != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailEqualFold(*i.PaymentReceiverEmailEqualFold))
	}
	if i.PaymentReceiverEmailContainsFold != nil {
		predicates = append(predicates, transaction.PaymentReceiverEmailContainsFold(*i.PaymentReceiverEmailContainsFold))
	}
	if i.PaymentReceiverId != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdEQ(*i.PaymentReceiverId))
	}
	if i.PaymentReceiverIdNEQ != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdNEQ(*i.PaymentReceiverIdNEQ))
	}
	if len(i.PaymentReceiverIdIn) > 0 {
		predicates = append(predicates, transaction.PaymentReceiverIdIn(i.PaymentReceiverIdIn...))
	}
	if len(i.PaymentReceiverIdNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentReceiverIdNotIn(i.PaymentReceiverIdNotIn...))
	}
	if i.PaymentReceiverIdGT != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdGT(*i.PaymentReceiverIdGT))
	}
	if i.PaymentReceiverIdGTE != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdGTE(*i.PaymentReceiverIdGTE))
	}
	if i.PaymentReceiverIdLT != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdLT(*i.PaymentReceiverIdLT))
	}
	if i.PaymentReceiverIdLTE != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdLTE(*i.PaymentReceiverIdLTE))
	}
	if i.PaymentReceiverIdContains != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdContains(*i.PaymentReceiverIdContains))
	}
	if i.PaymentReceiverIdHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdHasPrefix(*i.PaymentReceiverIdHasPrefix))
	}
	if i.PaymentReceiverIdHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdHasSuffix(*i.PaymentReceiverIdHasSuffix))
	}
	if i.PaymentReceiverIdEqualFold != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdEqualFold(*i.PaymentReceiverIdEqualFold))
	}
	if i.PaymentReceiverIdContainsFold != nil {
		predicates = append(predicates, transaction.PaymentReceiverIdContainsFold(*i.PaymentReceiverIdContainsFold))
	}
	if i.PaymentTax != nil {
		predicates = append(predicates, transaction.PaymentTaxEQ(*i.PaymentTax))
	}
	if i.PaymentTaxNEQ != nil {
		predicates = append(predicates, transaction.PaymentTaxNEQ(*i.PaymentTaxNEQ))
	}
	if len(i.PaymentTaxIn) > 0 {
		predicates = append(predicates, transaction.PaymentTaxIn(i.PaymentTaxIn...))
	}
	if len(i.PaymentTaxNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentTaxNotIn(i.PaymentTaxNotIn...))
	}
	if i.PaymentTaxGT != nil {
		predicates = append(predicates, transaction.PaymentTaxGT(*i.PaymentTaxGT))
	}
	if i.PaymentTaxGTE != nil {
		predicates = append(predicates, transaction.PaymentTaxGTE(*i.PaymentTaxGTE))
	}
	if i.PaymentTaxLT != nil {
		predicates = append(predicates, transaction.PaymentTaxLT(*i.PaymentTaxLT))
	}
	if i.PaymentTaxLTE != nil {
		predicates = append(predicates, transaction.PaymentTaxLTE(*i.PaymentTaxLTE))
	}
	if i.PaymentTaxContains != nil {
		predicates = append(predicates, transaction.PaymentTaxContains(*i.PaymentTaxContains))
	}
	if i.PaymentTaxHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentTaxHasPrefix(*i.PaymentTaxHasPrefix))
	}
	if i.PaymentTaxHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentTaxHasSuffix(*i.PaymentTaxHasSuffix))
	}
	if i.PaymentTaxEqualFold != nil {
		predicates = append(predicates, transaction.PaymentTaxEqualFold(*i.PaymentTaxEqualFold))
	}
	if i.PaymentTaxContainsFold != nil {
		predicates = append(predicates, transaction.PaymentTaxContainsFold(*i.PaymentTaxContainsFold))
	}
	if i.PaymentTransactionId != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdEQ(*i.PaymentTransactionId))
	}
	if i.PaymentTransactionIdNEQ != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdNEQ(*i.PaymentTransactionIdNEQ))
	}
	if len(i.PaymentTransactionIdIn) > 0 {
		predicates = append(predicates, transaction.PaymentTransactionIdIn(i.PaymentTransactionIdIn...))
	}
	if len(i.PaymentTransactionIdNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentTransactionIdNotIn(i.PaymentTransactionIdNotIn...))
	}
	if i.PaymentTransactionIdGT != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdGT(*i.PaymentTransactionIdGT))
	}
	if i.PaymentTransactionIdGTE != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdGTE(*i.PaymentTransactionIdGTE))
	}
	if i.PaymentTransactionIdLT != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdLT(*i.PaymentTransactionIdLT))
	}
	if i.PaymentTransactionIdLTE != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdLTE(*i.PaymentTransactionIdLTE))
	}
	if i.PaymentTransactionIdContains != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdContains(*i.PaymentTransactionIdContains))
	}
	if i.PaymentTransactionIdHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdHasPrefix(*i.PaymentTransactionIdHasPrefix))
	}
	if i.PaymentTransactionIdHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdHasSuffix(*i.PaymentTransactionIdHasSuffix))
	}
	if i.PaymentTransactionIdEqualFold != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdEqualFold(*i.PaymentTransactionIdEqualFold))
	}
	if i.PaymentTransactionIdContainsFold != nil {
		predicates = append(predicates, transaction.PaymentTransactionIdContainsFold(*i.PaymentTransactionIdContainsFold))
	}
	if i.PaymentTransactionType != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeEQ(*i.PaymentTransactionType))
	}
	if i.PaymentTransactionTypeNEQ != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeNEQ(*i.PaymentTransactionTypeNEQ))
	}
	if len(i.PaymentTransactionTypeIn) > 0 {
		predicates = append(predicates, transaction.PaymentTransactionTypeIn(i.PaymentTransactionTypeIn...))
	}
	if len(i.PaymentTransactionTypeNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentTransactionTypeNotIn(i.PaymentTransactionTypeNotIn...))
	}
	if i.PaymentTransactionTypeGT != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeGT(*i.PaymentTransactionTypeGT))
	}
	if i.PaymentTransactionTypeGTE != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeGTE(*i.PaymentTransactionTypeGTE))
	}
	if i.PaymentTransactionTypeLT != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeLT(*i.PaymentTransactionTypeLT))
	}
	if i.PaymentTransactionTypeLTE != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeLTE(*i.PaymentTransactionTypeLTE))
	}
	if i.PaymentTransactionTypeContains != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeContains(*i.PaymentTransactionTypeContains))
	}
	if i.PaymentTransactionTypeHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeHasPrefix(*i.PaymentTransactionTypeHasPrefix))
	}
	if i.PaymentTransactionTypeHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeHasSuffix(*i.PaymentTransactionTypeHasSuffix))
	}
	if i.PaymentTransactionTypeEqualFold != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeEqualFold(*i.PaymentTransactionTypeEqualFold))
	}
	if i.PaymentTransactionTypeContainsFold != nil {
		predicates = append(predicates, transaction.PaymentTransactionTypeContainsFold(*i.PaymentTransactionTypeContainsFold))
	}
	if i.PaymentPendingReason != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonEQ(*i.PaymentPendingReason))
	}
	if i.PaymentPendingReasonNEQ != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonNEQ(*i.PaymentPendingReasonNEQ))
	}
	if len(i.PaymentPendingReasonIn) > 0 {
		predicates = append(predicates, transaction.PaymentPendingReasonIn(i.PaymentPendingReasonIn...))
	}
	if len(i.PaymentPendingReasonNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentPendingReasonNotIn(i.PaymentPendingReasonNotIn...))
	}
	if i.PaymentPendingReasonGT != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonGT(*i.PaymentPendingReasonGT))
	}
	if i.PaymentPendingReasonGTE != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonGTE(*i.PaymentPendingReasonGTE))
	}
	if i.PaymentPendingReasonLT != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonLT(*i.PaymentPendingReasonLT))
	}
	if i.PaymentPendingReasonLTE != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonLTE(*i.PaymentPendingReasonLTE))
	}
	if i.PaymentPendingReasonContains != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonContains(*i.PaymentPendingReasonContains))
	}
	if i.PaymentPendingReasonHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonHasPrefix(*i.PaymentPendingReasonHasPrefix))
	}
	if i.PaymentPendingReasonHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonHasSuffix(*i.PaymentPendingReasonHasSuffix))
	}
	if i.PaymentPendingReasonEqualFold != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonEqualFold(*i.PaymentPendingReasonEqualFold))
	}
	if i.PaymentPendingReasonContainsFold != nil {
		predicates = append(predicates, transaction.PaymentPendingReasonContainsFold(*i.PaymentPendingReasonContainsFold))
	}
	if i.PaymentReasonCode != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeEQ(*i.PaymentReasonCode))
	}
	if i.PaymentReasonCodeNEQ != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeNEQ(*i.PaymentReasonCodeNEQ))
	}
	if len(i.PaymentReasonCodeIn) > 0 {
		predicates = append(predicates, transaction.PaymentReasonCodeIn(i.PaymentReasonCodeIn...))
	}
	if len(i.PaymentReasonCodeNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentReasonCodeNotIn(i.PaymentReasonCodeNotIn...))
	}
	if i.PaymentReasonCodeGT != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeGT(*i.PaymentReasonCodeGT))
	}
	if i.PaymentReasonCodeGTE != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeGTE(*i.PaymentReasonCodeGTE))
	}
	if i.PaymentReasonCodeLT != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeLT(*i.PaymentReasonCodeLT))
	}
	if i.PaymentReasonCodeLTE != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeLTE(*i.PaymentReasonCodeLTE))
	}
	if i.PaymentReasonCodeContains != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeContains(*i.PaymentReasonCodeContains))
	}
	if i.PaymentReasonCodeHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeHasPrefix(*i.PaymentReasonCodeHasPrefix))
	}
	if i.PaymentReasonCodeHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeHasSuffix(*i.PaymentReasonCodeHasSuffix))
	}
	if i.PaymentReasonCodeEqualFold != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeEqualFold(*i.PaymentReasonCodeEqualFold))
	}
	if i.PaymentReasonCodeContainsFold != nil {
		predicates = append(predicates, transaction.PaymentReasonCodeContainsFold(*i.PaymentReasonCodeContainsFold))
	}

	if i.HasProduct != nil {
		p := transaction.HasProduct()
		if !*i.HasProduct {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasProductWith(with...))
	}
	if i.HasOriginLink != nil {
		p := transaction.HasOriginLink()
		if !*i.HasOriginLink {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOriginLinkWith) > 0 {
		with := make([]predicate.LinkVisit, 0, len(i.HasOriginLinkWith))
		for _, w := range i.HasOriginLinkWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOriginLinkWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasOriginLinkWith(with...))
	}
	if i.HasProductCustomer != nil {
		p := transaction.HasProductCustomer()
		if !*i.HasProductCustomer {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductCustomerWith) > 0 {
		with := make([]predicate.UserBuyer, 0, len(i.HasProductCustomerWith))
		for _, w := range i.HasProductCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasProductCustomerWith(with...))
	}
	if i.HasShop != nil {
		p := transaction.HasShop()
		if !*i.HasShop {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShopWith) > 0 {
		with := make([]predicate.Shop, 0, len(i.HasShopWith))
		for _, w := range i.HasShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasShopWith(with...))
	}
	if i.HasProductInfluencer != nil {
		p := transaction.HasProductInfluencer()
		if !*i.HasProductInfluencer {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductInfluencerWith) > 0 {
		with := make([]predicate.UserInfluencer, 0, len(i.HasProductInfluencerWith))
		for _, w := range i.HasProductInfluencerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductInfluencerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasProductInfluencerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTransactionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return transaction.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "dateUpdated" field predicates.
	DateUpdated             *string  `json:"dateupdated,omitempty"`
	DateUpdatedNEQ          *string  `json:"dateupdatedNEQ,omitempty"`
	DateUpdatedIn           []string `json:"dateupdatedIn,omitempty"`
	DateUpdatedNotIn        []string `json:"dateupdatedNotIn,omitempty"`
	DateUpdatedGT           *string  `json:"dateupdatedGT,omitempty"`
	DateUpdatedGTE          *string  `json:"dateupdatedGTE,omitempty"`
	DateUpdatedLT           *string  `json:"dateupdatedLT,omitempty"`
	DateUpdatedLTE          *string  `json:"dateupdatedLTE,omitempty"`
	DateUpdatedContains     *string  `json:"dateupdatedContains,omitempty"`
	DateUpdatedHasPrefix    *string  `json:"dateupdatedHasPrefix,omitempty"`
	DateUpdatedHasSuffix    *string  `json:"dateupdatedHasSuffix,omitempty"`
	DateUpdatedEqualFold    *string  `json:"dateupdatedEqualFold,omitempty"`
	DateUpdatedContainsFold *string  `json:"dateupdatedContainsFold,omitempty"`

	// "notifications" edge predicates.
	HasNotifications     *bool                     `json:"hasNotifications,omitempty"`
	HasNotificationsWith []*NotificationWhereInput `json:"hasNotificationsWith,omitempty"`

	// "bankAccounts" edge predicates.
	HasBankAccounts     *bool                    `json:"hasBankAccounts,omitempty"`
	HasBankAccountsWith []*BankAccountWhereInput `json:"hasBankAccountsWith,omitempty"`

	// "shippingAddresses" edge predicates.
	HasShippingAddresses     *bool                        `json:"hasShippingAddresses,omitempty"`
	HasShippingAddressesWith []*ShippingAddressWhereInput `json:"hasShippingAddressesWith,omitempty"`

	// "paymentMethods" edge predicates.
	HasPaymentMethods     *bool                      `json:"hasPaymentMethods,omitempty"`
	HasPaymentMethodsWith []*PaymentMethodWhereInput `json:"hasPaymentMethodsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, user.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, user.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, user.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, user.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, user.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, user.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, user.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, user.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, user.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, user.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, user.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, user.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, user.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, user.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, user.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, user.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, user.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, user.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, user.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, user.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, user.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, user.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, user.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, user.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, user.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, user.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, user.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, user.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, user.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, user.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, user.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, user.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, user.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, user.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, user.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, user.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, user.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, user.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, user.StateContainsFold(*i.StateContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, user.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, user.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, user.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, user.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, user.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, user.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, user.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, user.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, user.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, user.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, user.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, user.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, user.ZipContainsFold(*i.ZipContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, user.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, user.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, user.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, user.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, user.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, user.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, user.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, user.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, user.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, user.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, user.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, user.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, user.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, user.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, user.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, user.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, user.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, user.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, user.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, user.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, user.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, user.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, user.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, user.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, user.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, user.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}
	if i.DateUpdated != nil {
		predicates = append(predicates, user.DateUpdatedEQ(*i.DateUpdated))
	}
	if i.DateUpdatedNEQ != nil {
		predicates = append(predicates, user.DateUpdatedNEQ(*i.DateUpdatedNEQ))
	}
	if len(i.DateUpdatedIn) > 0 {
		predicates = append(predicates, user.DateUpdatedIn(i.DateUpdatedIn...))
	}
	if len(i.DateUpdatedNotIn) > 0 {
		predicates = append(predicates, user.DateUpdatedNotIn(i.DateUpdatedNotIn...))
	}
	if i.DateUpdatedGT != nil {
		predicates = append(predicates, user.DateUpdatedGT(*i.DateUpdatedGT))
	}
	if i.DateUpdatedGTE != nil {
		predicates = append(predicates, user.DateUpdatedGTE(*i.DateUpdatedGTE))
	}
	if i.DateUpdatedLT != nil {
		predicates = append(predicates, user.DateUpdatedLT(*i.DateUpdatedLT))
	}
	if i.DateUpdatedLTE != nil {
		predicates = append(predicates, user.DateUpdatedLTE(*i.DateUpdatedLTE))
	}
	if i.DateUpdatedContains != nil {
		predicates = append(predicates, user.DateUpdatedContains(*i.DateUpdatedContains))
	}
	if i.DateUpdatedHasPrefix != nil {
		predicates = append(predicates, user.DateUpdatedHasPrefix(*i.DateUpdatedHasPrefix))
	}
	if i.DateUpdatedHasSuffix != nil {
		predicates = append(predicates, user.DateUpdatedHasSuffix(*i.DateUpdatedHasSuffix))
	}
	if i.DateUpdatedEqualFold != nil {
		predicates = append(predicates, user.DateUpdatedEqualFold(*i.DateUpdatedEqualFold))
	}
	if i.DateUpdatedContainsFold != nil {
		predicates = append(predicates, user.DateUpdatedContainsFold(*i.DateUpdatedContainsFold))
	}

	if i.HasNotifications != nil {
		p := user.HasNotifications()
		if !*i.HasNotifications {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationsWith) > 0 {
		with := make([]predicate.Notification, 0, len(i.HasNotificationsWith))
		for _, w := range i.HasNotificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasNotificationsWith(with...))
	}
	if i.HasBankAccounts != nil {
		p := user.HasBankAccounts()
		if !*i.HasBankAccounts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBankAccountsWith) > 0 {
		with := make([]predicate.BankAccount, 0, len(i.HasBankAccountsWith))
		for _, w := range i.HasBankAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBankAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasBankAccountsWith(with...))
	}
	if i.HasShippingAddresses != nil {
		p := user.HasShippingAddresses()
		if !*i.HasShippingAddresses {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShippingAddressesWith) > 0 {
		with := make([]predicate.ShippingAddress, 0, len(i.HasShippingAddressesWith))
		for _, w := range i.HasShippingAddressesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShippingAddressesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasShippingAddressesWith(with...))
	}
	if i.HasPaymentMethods != nil {
		p := user.HasPaymentMethods()
		if !*i.HasPaymentMethods {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentMethodsWith) > 0 {
		with := make([]predicate.PaymentMethod, 0, len(i.HasPaymentMethodsWith))
		for _, w := range i.HasPaymentMethodsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPaymentMethodsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPaymentMethodsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserBuyerWhereInput represents a where input for filtering UserBuyer queries.
type UserBuyerWhereInput struct {
	Predicates []predicate.UserBuyer  `json:"-"`
	Not        *UserBuyerWhereInput   `json:"not,omitempty"`
	Or         []*UserBuyerWhereInput `json:"or,omitempty"`
	And        []*UserBuyerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "placeholder" field predicates.
	Placeholder       *int  `json:"placeholder,omitempty"`
	PlaceholderNEQ    *int  `json:"placeholderNEQ,omitempty"`
	PlaceholderIn     []int `json:"placeholderIn,omitempty"`
	PlaceholderNotIn  []int `json:"placeholderNotIn,omitempty"`
	PlaceholderGT     *int  `json:"placeholderGT,omitempty"`
	PlaceholderGTE    *int  `json:"placeholderGTE,omitempty"`
	PlaceholderLT     *int  `json:"placeholderLT,omitempty"`
	PlaceholderLTE    *int  `json:"placeholderLTE,omitempty"`
	PlaceholderIsNil  bool  `json:"placeholderIsNil,omitempty"`
	PlaceholderNotNil bool  `json:"placeholderNotNil,omitempty"`

	// "userProfile" edge predicates.
	HasUserProfile     *bool             `json:"hasUserProfile,omitempty"`
	HasUserProfileWith []*UserWhereInput `json:"hasUserProfileWith,omitempty"`

	// "reviews" edge predicates.
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`

	// "linksClicked" edge predicates.
	HasLinksClicked     *bool                  `json:"hasLinksClicked,omitempty"`
	HasLinksClickedWith []*LinkVisitWhereInput `json:"hasLinksClickedWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserBuyerWhereInput) AddPredicates(predicates ...predicate.UserBuyer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserBuyerWhereInput filter on the UserBuyerQuery builder.
func (i *UserBuyerWhereInput) Filter(q *UserBuyerQuery) (*UserBuyerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserBuyerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserBuyerWhereInput is returned in case the UserBuyerWhereInput is empty.
var ErrEmptyUserBuyerWhereInput = errors.New("ent: empty predicate UserBuyerWhereInput")

// P returns a predicate for filtering userbuyers.
// An error is returned if the input is empty or invalid.
func (i *UserBuyerWhereInput) P() (predicate.UserBuyer, error) {
	var predicates []predicate.UserBuyer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userbuyer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserBuyer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userbuyer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserBuyer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userbuyer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userbuyer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userbuyer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userbuyer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userbuyer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userbuyer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userbuyer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userbuyer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userbuyer.IDLTE(*i.IDLTE))
	}
	if i.Placeholder != nil {
		predicates = append(predicates, userbuyer.PlaceholderEQ(*i.Placeholder))
	}
	if i.PlaceholderNEQ != nil {
		predicates = append(predicates, userbuyer.PlaceholderNEQ(*i.PlaceholderNEQ))
	}
	if len(i.PlaceholderIn) > 0 {
		predicates = append(predicates, userbuyer.PlaceholderIn(i.PlaceholderIn...))
	}
	if len(i.PlaceholderNotIn) > 0 {
		predicates = append(predicates, userbuyer.PlaceholderNotIn(i.PlaceholderNotIn...))
	}
	if i.PlaceholderGT != nil {
		predicates = append(predicates, userbuyer.PlaceholderGT(*i.PlaceholderGT))
	}
	if i.PlaceholderGTE != nil {
		predicates = append(predicates, userbuyer.PlaceholderGTE(*i.PlaceholderGTE))
	}
	if i.PlaceholderLT != nil {
		predicates = append(predicates, userbuyer.PlaceholderLT(*i.PlaceholderLT))
	}
	if i.PlaceholderLTE != nil {
		predicates = append(predicates, userbuyer.PlaceholderLTE(*i.PlaceholderLTE))
	}
	if i.PlaceholderIsNil {
		predicates = append(predicates, userbuyer.PlaceholderIsNil())
	}
	if i.PlaceholderNotNil {
		predicates = append(predicates, userbuyer.PlaceholderNotNil())
	}

	if i.HasUserProfile != nil {
		p := userbuyer.HasUserProfile()
		if !*i.HasUserProfile {
			p = userbuyer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserProfileWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserProfileWith))
		for _, w := range i.HasUserProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userbuyer.HasUserProfileWith(with...))
	}
	if i.HasReviews != nil {
		p := userbuyer.HasReviews()
		if !*i.HasReviews {
			p = userbuyer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReviewsWith) > 0 {
		with := make([]predicate.Review, 0, len(i.HasReviewsWith))
		for _, w := range i.HasReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReviewsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userbuyer.HasReviewsWith(with...))
	}
	if i.HasTransactions != nil {
		p := userbuyer.HasTransactions()
		if !*i.HasTransactions {
			p = userbuyer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userbuyer.HasTransactionsWith(with...))
	}
	if i.HasLinksClicked != nil {
		p := userbuyer.HasLinksClicked()
		if !*i.HasLinksClicked {
			p = userbuyer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLinksClickedWith) > 0 {
		with := make([]predicate.LinkVisit, 0, len(i.HasLinksClickedWith))
		for _, w := range i.HasLinksClickedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLinksClickedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userbuyer.HasLinksClickedWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserBuyerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userbuyer.And(predicates...), nil
	}
}

// UserInfluencerWhereInput represents a where input for filtering UserInfluencer queries.
type UserInfluencerWhereInput struct {
	Predicates []predicate.UserInfluencer  `json:"-"`
	Not        *UserInfluencerWhereInput   `json:"not,omitempty"`
	Or         []*UserInfluencerWhereInput `json:"or,omitempty"`
	And        []*UserInfluencerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "placeholder" field predicates.
	Placeholder       *int  `json:"placeholder,omitempty"`
	PlaceholderNEQ    *int  `json:"placeholderNEQ,omitempty"`
	PlaceholderIn     []int `json:"placeholderIn,omitempty"`
	PlaceholderNotIn  []int `json:"placeholderNotIn,omitempty"`
	PlaceholderGT     *int  `json:"placeholderGT,omitempty"`
	PlaceholderGTE    *int  `json:"placeholderGTE,omitempty"`
	PlaceholderLT     *int  `json:"placeholderLT,omitempty"`
	PlaceholderLTE    *int  `json:"placeholderLTE,omitempty"`
	PlaceholderIsNil  bool  `json:"placeholderIsNil,omitempty"`
	PlaceholderNotNil bool  `json:"placeholderNotNil,omitempty"`

	// "userProfile" edge predicates.
	HasUserProfile     *bool             `json:"hasUserProfile,omitempty"`
	HasUserProfileWith []*UserWhereInput `json:"hasUserProfileWith,omitempty"`

	// "referralLinks" edge predicates.
	HasReferralLinks     *bool                     `json:"hasReferralLinks,omitempty"`
	HasReferralLinksWith []*ReferralLinkWhereInput `json:"hasReferralLinksWith,omitempty"`

	// "reviews" edge predicates.
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserInfluencerWhereInput) AddPredicates(predicates ...predicate.UserInfluencer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserInfluencerWhereInput filter on the UserInfluencerQuery builder.
func (i *UserInfluencerWhereInput) Filter(q *UserInfluencerQuery) (*UserInfluencerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserInfluencerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserInfluencerWhereInput is returned in case the UserInfluencerWhereInput is empty.
var ErrEmptyUserInfluencerWhereInput = errors.New("ent: empty predicate UserInfluencerWhereInput")

// P returns a predicate for filtering userinfluencers.
// An error is returned if the input is empty or invalid.
func (i *UserInfluencerWhereInput) P() (predicate.UserInfluencer, error) {
	var predicates []predicate.UserInfluencer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userinfluencer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserInfluencer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userinfluencer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserInfluencer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userinfluencer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userinfluencer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userinfluencer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userinfluencer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userinfluencer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userinfluencer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userinfluencer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userinfluencer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userinfluencer.IDLTE(*i.IDLTE))
	}
	if i.Placeholder != nil {
		predicates = append(predicates, userinfluencer.PlaceholderEQ(*i.Placeholder))
	}
	if i.PlaceholderNEQ != nil {
		predicates = append(predicates, userinfluencer.PlaceholderNEQ(*i.PlaceholderNEQ))
	}
	if len(i.PlaceholderIn) > 0 {
		predicates = append(predicates, userinfluencer.PlaceholderIn(i.PlaceholderIn...))
	}
	if len(i.PlaceholderNotIn) > 0 {
		predicates = append(predicates, userinfluencer.PlaceholderNotIn(i.PlaceholderNotIn...))
	}
	if i.PlaceholderGT != nil {
		predicates = append(predicates, userinfluencer.PlaceholderGT(*i.PlaceholderGT))
	}
	if i.PlaceholderGTE != nil {
		predicates = append(predicates, userinfluencer.PlaceholderGTE(*i.PlaceholderGTE))
	}
	if i.PlaceholderLT != nil {
		predicates = append(predicates, userinfluencer.PlaceholderLT(*i.PlaceholderLT))
	}
	if i.PlaceholderLTE != nil {
		predicates = append(predicates, userinfluencer.PlaceholderLTE(*i.PlaceholderLTE))
	}
	if i.PlaceholderIsNil {
		predicates = append(predicates, userinfluencer.PlaceholderIsNil())
	}
	if i.PlaceholderNotNil {
		predicates = append(predicates, userinfluencer.PlaceholderNotNil())
	}

	if i.HasUserProfile != nil {
		p := userinfluencer.HasUserProfile()
		if !*i.HasUserProfile {
			p = userinfluencer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserProfileWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserProfileWith))
		for _, w := range i.HasUserProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userinfluencer.HasUserProfileWith(with...))
	}
	if i.HasReferralLinks != nil {
		p := userinfluencer.HasReferralLinks()
		if !*i.HasReferralLinks {
			p = userinfluencer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReferralLinksWith) > 0 {
		with := make([]predicate.ReferralLink, 0, len(i.HasReferralLinksWith))
		for _, w := range i.HasReferralLinksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReferralLinksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userinfluencer.HasReferralLinksWith(with...))
	}
	if i.HasReviews != nil {
		p := userinfluencer.HasReviews()
		if !*i.HasReviews {
			p = userinfluencer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReviewsWith) > 0 {
		with := make([]predicate.Review, 0, len(i.HasReviewsWith))
		for _, w := range i.HasReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReviewsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userinfluencer.HasReviewsWith(with...))
	}
	if i.HasProducts != nil {
		p := userinfluencer.HasProducts()
		if !*i.HasProducts {
			p = userinfluencer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userinfluencer.HasProductsWith(with...))
	}
	if i.HasTags != nil {
		p := userinfluencer.HasTags()
		if !*i.HasTags {
			p = userinfluencer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userinfluencer.HasTagsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserInfluencerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userinfluencer.And(predicates...), nil
	}
}

// UserSellerWhereInput represents a where input for filtering UserSeller queries.
type UserSellerWhereInput struct {
	Predicates []predicate.UserSeller  `json:"-"`
	Not        *UserSellerWhereInput   `json:"not,omitempty"`
	Or         []*UserSellerWhereInput `json:"or,omitempty"`
	And        []*UserSellerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "brandName" field predicates.
	BrandName             *string  `json:"brandname,omitempty"`
	BrandNameNEQ          *string  `json:"brandnameNEQ,omitempty"`
	BrandNameIn           []string `json:"brandnameIn,omitempty"`
	BrandNameNotIn        []string `json:"brandnameNotIn,omitempty"`
	BrandNameGT           *string  `json:"brandnameGT,omitempty"`
	BrandNameGTE          *string  `json:"brandnameGTE,omitempty"`
	BrandNameLT           *string  `json:"brandnameLT,omitempty"`
	BrandNameLTE          *string  `json:"brandnameLTE,omitempty"`
	BrandNameContains     *string  `json:"brandnameContains,omitempty"`
	BrandNameHasPrefix    *string  `json:"brandnameHasPrefix,omitempty"`
	BrandNameHasSuffix    *string  `json:"brandnameHasSuffix,omitempty"`
	BrandNameEqualFold    *string  `json:"brandnameEqualFold,omitempty"`
	BrandNameContainsFold *string  `json:"brandnameContainsFold,omitempty"`

	// "userProfile" edge predicates.
	HasUserProfile     *bool             `json:"hasUserProfile,omitempty"`
	HasUserProfileWith []*UserWhereInput `json:"hasUserProfileWith,omitempty"`

	// "shops" edge predicates.
	HasShops     *bool             `json:"hasShops,omitempty"`
	HasShopsWith []*ShopWhereInput `json:"hasShopsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSellerWhereInput) AddPredicates(predicates ...predicate.UserSeller) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSellerWhereInput filter on the UserSellerQuery builder.
func (i *UserSellerWhereInput) Filter(q *UserSellerQuery) (*UserSellerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSellerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSellerWhereInput is returned in case the UserSellerWhereInput is empty.
var ErrEmptyUserSellerWhereInput = errors.New("ent: empty predicate UserSellerWhereInput")

// P returns a predicate for filtering usersellers.
// An error is returned if the input is empty or invalid.
func (i *UserSellerWhereInput) P() (predicate.UserSeller, error) {
	var predicates []predicate.UserSeller
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userseller.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSeller, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userseller.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSeller, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userseller.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userseller.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userseller.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userseller.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userseller.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userseller.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userseller.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userseller.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userseller.IDLTE(*i.IDLTE))
	}
	if i.BrandName != nil {
		predicates = append(predicates, userseller.BrandNameEQ(*i.BrandName))
	}
	if i.BrandNameNEQ != nil {
		predicates = append(predicates, userseller.BrandNameNEQ(*i.BrandNameNEQ))
	}
	if len(i.BrandNameIn) > 0 {
		predicates = append(predicates, userseller.BrandNameIn(i.BrandNameIn...))
	}
	if len(i.BrandNameNotIn) > 0 {
		predicates = append(predicates, userseller.BrandNameNotIn(i.BrandNameNotIn...))
	}
	if i.BrandNameGT != nil {
		predicates = append(predicates, userseller.BrandNameGT(*i.BrandNameGT))
	}
	if i.BrandNameGTE != nil {
		predicates = append(predicates, userseller.BrandNameGTE(*i.BrandNameGTE))
	}
	if i.BrandNameLT != nil {
		predicates = append(predicates, userseller.BrandNameLT(*i.BrandNameLT))
	}
	if i.BrandNameLTE != nil {
		predicates = append(predicates, userseller.BrandNameLTE(*i.BrandNameLTE))
	}
	if i.BrandNameContains != nil {
		predicates = append(predicates, userseller.BrandNameContains(*i.BrandNameContains))
	}
	if i.BrandNameHasPrefix != nil {
		predicates = append(predicates, userseller.BrandNameHasPrefix(*i.BrandNameHasPrefix))
	}
	if i.BrandNameHasSuffix != nil {
		predicates = append(predicates, userseller.BrandNameHasSuffix(*i.BrandNameHasSuffix))
	}
	if i.BrandNameEqualFold != nil {
		predicates = append(predicates, userseller.BrandNameEqualFold(*i.BrandNameEqualFold))
	}
	if i.BrandNameContainsFold != nil {
		predicates = append(predicates, userseller.BrandNameContainsFold(*i.BrandNameContainsFold))
	}

	if i.HasUserProfile != nil {
		p := userseller.HasUserProfile()
		if !*i.HasUserProfile {
			p = userseller.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserProfileWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserProfileWith))
		for _, w := range i.HasUserProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userseller.HasUserProfileWith(with...))
	}
	if i.HasShops != nil {
		p := userseller.HasShops()
		if !*i.HasShops {
			p = userseller.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShopsWith) > 0 {
		with := make([]predicate.Shop, 0, len(i.HasShopsWith))
		for _, w := range i.HasShopsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShopsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userseller.HasShopsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSellerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userseller.And(predicates...), nil
	}
}

// ViewAnalyticsWhereInput represents a where input for filtering ViewAnalytics queries.
type ViewAnalyticsWhereInput struct {
	Predicates []predicate.ViewAnalytics  `json:"-"`
	Not        *ViewAnalyticsWhereInput   `json:"not,omitempty"`
	Or         []*ViewAnalyticsWhereInput `json:"or,omitempty"`
	And        []*ViewAnalyticsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "views" field predicates.
	Views      *int  `json:"views,omitempty"`
	ViewsNEQ   *int  `json:"viewsNEQ,omitempty"`
	ViewsIn    []int `json:"viewsIn,omitempty"`
	ViewsNotIn []int `json:"viewsNotIn,omitempty"`
	ViewsGT    *int  `json:"viewsGT,omitempty"`
	ViewsGTE   *int  `json:"viewsGTE,omitempty"`
	ViewsLT    *int  `json:"viewsLT,omitempty"`
	ViewsLTE   *int  `json:"viewsLTE,omitempty"`

	// "scrolls" field predicates.
	Scrolls      *int  `json:"scrolls,omitempty"`
	ScrollsNEQ   *int  `json:"scrollsNEQ,omitempty"`
	ScrollsIn    []int `json:"scrollsIn,omitempty"`
	ScrollsNotIn []int `json:"scrollsNotIn,omitempty"`
	ScrollsGT    *int  `json:"scrollsGT,omitempty"`
	ScrollsGTE   *int  `json:"scrollsGTE,omitempty"`
	ScrollsLT    *int  `json:"scrollsLT,omitempty"`
	ScrollsLTE   *int  `json:"scrollsLTE,omitempty"`

	// "exits" field predicates.
	Exits      *int  `json:"exits,omitempty"`
	ExitsNEQ   *int  `json:"exitsNEQ,omitempty"`
	ExitsIn    []int `json:"exitsIn,omitempty"`
	ExitsNotIn []int `json:"exitsNotIn,omitempty"`
	ExitsGT    *int  `json:"exitsGT,omitempty"`
	ExitsGTE   *int  `json:"exitsGTE,omitempty"`
	ExitsLT    *int  `json:"exitsLT,omitempty"`
	ExitsLTE   *int  `json:"exitsLTE,omitempty"`

	// "dateCreated" field predicates.
	DateCreated             *string  `json:"datecreated,omitempty"`
	DateCreatedNEQ          *string  `json:"datecreatedNEQ,omitempty"`
	DateCreatedIn           []string `json:"datecreatedIn,omitempty"`
	DateCreatedNotIn        []string `json:"datecreatedNotIn,omitempty"`
	DateCreatedGT           *string  `json:"datecreatedGT,omitempty"`
	DateCreatedGTE          *string  `json:"datecreatedGTE,omitempty"`
	DateCreatedLT           *string  `json:"datecreatedLT,omitempty"`
	DateCreatedLTE          *string  `json:"datecreatedLTE,omitempty"`
	DateCreatedContains     *string  `json:"datecreatedContains,omitempty"`
	DateCreatedHasPrefix    *string  `json:"datecreatedHasPrefix,omitempty"`
	DateCreatedHasSuffix    *string  `json:"datecreatedHasSuffix,omitempty"`
	DateCreatedEqualFold    *string  `json:"datecreatedEqualFold,omitempty"`
	DateCreatedContainsFold *string  `json:"datecreatedContainsFold,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ViewAnalyticsWhereInput) AddPredicates(predicates ...predicate.ViewAnalytics) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ViewAnalyticsWhereInput filter on the ViewAnalyticsQuery builder.
func (i *ViewAnalyticsWhereInput) Filter(q *ViewAnalyticsQuery) (*ViewAnalyticsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyViewAnalyticsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyViewAnalyticsWhereInput is returned in case the ViewAnalyticsWhereInput is empty.
var ErrEmptyViewAnalyticsWhereInput = errors.New("ent: empty predicate ViewAnalyticsWhereInput")

// P returns a predicate for filtering viewanalyticsslice.
// An error is returned if the input is empty or invalid.
func (i *ViewAnalyticsWhereInput) P() (predicate.ViewAnalytics, error) {
	var predicates []predicate.ViewAnalytics
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, viewanalytics.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ViewAnalytics, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, viewanalytics.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ViewAnalytics, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, viewanalytics.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, viewanalytics.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, viewanalytics.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, viewanalytics.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, viewanalytics.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, viewanalytics.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, viewanalytics.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, viewanalytics.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, viewanalytics.IDLTE(*i.IDLTE))
	}
	if i.Views != nil {
		predicates = append(predicates, viewanalytics.ViewsEQ(*i.Views))
	}
	if i.ViewsNEQ != nil {
		predicates = append(predicates, viewanalytics.ViewsNEQ(*i.ViewsNEQ))
	}
	if len(i.ViewsIn) > 0 {
		predicates = append(predicates, viewanalytics.ViewsIn(i.ViewsIn...))
	}
	if len(i.ViewsNotIn) > 0 {
		predicates = append(predicates, viewanalytics.ViewsNotIn(i.ViewsNotIn...))
	}
	if i.ViewsGT != nil {
		predicates = append(predicates, viewanalytics.ViewsGT(*i.ViewsGT))
	}
	if i.ViewsGTE != nil {
		predicates = append(predicates, viewanalytics.ViewsGTE(*i.ViewsGTE))
	}
	if i.ViewsLT != nil {
		predicates = append(predicates, viewanalytics.ViewsLT(*i.ViewsLT))
	}
	if i.ViewsLTE != nil {
		predicates = append(predicates, viewanalytics.ViewsLTE(*i.ViewsLTE))
	}
	if i.Scrolls != nil {
		predicates = append(predicates, viewanalytics.ScrollsEQ(*i.Scrolls))
	}
	if i.ScrollsNEQ != nil {
		predicates = append(predicates, viewanalytics.ScrollsNEQ(*i.ScrollsNEQ))
	}
	if len(i.ScrollsIn) > 0 {
		predicates = append(predicates, viewanalytics.ScrollsIn(i.ScrollsIn...))
	}
	if len(i.ScrollsNotIn) > 0 {
		predicates = append(predicates, viewanalytics.ScrollsNotIn(i.ScrollsNotIn...))
	}
	if i.ScrollsGT != nil {
		predicates = append(predicates, viewanalytics.ScrollsGT(*i.ScrollsGT))
	}
	if i.ScrollsGTE != nil {
		predicates = append(predicates, viewanalytics.ScrollsGTE(*i.ScrollsGTE))
	}
	if i.ScrollsLT != nil {
		predicates = append(predicates, viewanalytics.ScrollsLT(*i.ScrollsLT))
	}
	if i.ScrollsLTE != nil {
		predicates = append(predicates, viewanalytics.ScrollsLTE(*i.ScrollsLTE))
	}
	if i.Exits != nil {
		predicates = append(predicates, viewanalytics.ExitsEQ(*i.Exits))
	}
	if i.ExitsNEQ != nil {
		predicates = append(predicates, viewanalytics.ExitsNEQ(*i.ExitsNEQ))
	}
	if len(i.ExitsIn) > 0 {
		predicates = append(predicates, viewanalytics.ExitsIn(i.ExitsIn...))
	}
	if len(i.ExitsNotIn) > 0 {
		predicates = append(predicates, viewanalytics.ExitsNotIn(i.ExitsNotIn...))
	}
	if i.ExitsGT != nil {
		predicates = append(predicates, viewanalytics.ExitsGT(*i.ExitsGT))
	}
	if i.ExitsGTE != nil {
		predicates = append(predicates, viewanalytics.ExitsGTE(*i.ExitsGTE))
	}
	if i.ExitsLT != nil {
		predicates = append(predicates, viewanalytics.ExitsLT(*i.ExitsLT))
	}
	if i.ExitsLTE != nil {
		predicates = append(predicates, viewanalytics.ExitsLTE(*i.ExitsLTE))
	}
	if i.DateCreated != nil {
		predicates = append(predicates, viewanalytics.DateCreatedEQ(*i.DateCreated))
	}
	if i.DateCreatedNEQ != nil {
		predicates = append(predicates, viewanalytics.DateCreatedNEQ(*i.DateCreatedNEQ))
	}
	if len(i.DateCreatedIn) > 0 {
		predicates = append(predicates, viewanalytics.DateCreatedIn(i.DateCreatedIn...))
	}
	if len(i.DateCreatedNotIn) > 0 {
		predicates = append(predicates, viewanalytics.DateCreatedNotIn(i.DateCreatedNotIn...))
	}
	if i.DateCreatedGT != nil {
		predicates = append(predicates, viewanalytics.DateCreatedGT(*i.DateCreatedGT))
	}
	if i.DateCreatedGTE != nil {
		predicates = append(predicates, viewanalytics.DateCreatedGTE(*i.DateCreatedGTE))
	}
	if i.DateCreatedLT != nil {
		predicates = append(predicates, viewanalytics.DateCreatedLT(*i.DateCreatedLT))
	}
	if i.DateCreatedLTE != nil {
		predicates = append(predicates, viewanalytics.DateCreatedLTE(*i.DateCreatedLTE))
	}
	if i.DateCreatedContains != nil {
		predicates = append(predicates, viewanalytics.DateCreatedContains(*i.DateCreatedContains))
	}
	if i.DateCreatedHasPrefix != nil {
		predicates = append(predicates, viewanalytics.DateCreatedHasPrefix(*i.DateCreatedHasPrefix))
	}
	if i.DateCreatedHasSuffix != nil {
		predicates = append(predicates, viewanalytics.DateCreatedHasSuffix(*i.DateCreatedHasSuffix))
	}
	if i.DateCreatedEqualFold != nil {
		predicates = append(predicates, viewanalytics.DateCreatedEqualFold(*i.DateCreatedEqualFold))
	}
	if i.DateCreatedContainsFold != nil {
		predicates = append(predicates, viewanalytics.DateCreatedContainsFold(*i.DateCreatedContainsFold))
	}

	if i.HasProduct != nil {
		p := viewanalytics.HasProduct()
		if !*i.HasProduct {
			p = viewanalytics.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, viewanalytics.HasProductWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyViewAnalyticsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return viewanalytics.And(predicates...), nil
	}
}
