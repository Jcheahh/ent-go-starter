// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"entdemo/ent/bankaccount"
	"entdemo/ent/blogpost"
	"entdemo/ent/category"
	"entdemo/ent/chat"
	"entdemo/ent/commissionstructureschema"
	"entdemo/ent/contentblock"
	"entdemo/ent/emailcampaign"
	"entdemo/ent/group"
	"entdemo/ent/groupbuy"
	"entdemo/ent/herocontent"
	"entdemo/ent/image"
	"entdemo/ent/linkvisit"
	"entdemo/ent/marketingcampaign"
	"entdemo/ent/notification"
	"entdemo/ent/paymentmethod"
	"entdemo/ent/primarycontent"
	"entdemo/ent/product"
	"entdemo/ent/productattribute"
	"entdemo/ent/productpageview"
	"entdemo/ent/productvariation"
	"entdemo/ent/referrallink"
	"entdemo/ent/refundtransactions"
	"entdemo/ent/review"
	"entdemo/ent/rewardtype"
	"entdemo/ent/shippingaddress"
	"entdemo/ent/shop"
	"entdemo/ent/tag"
	"entdemo/ent/transaction"
	"entdemo/ent/user"
	"entdemo/ent/userbuyer"
	"entdemo/ent/userinfluencer"
	"entdemo/ent/userseller"
	"entdemo/ent/viewanalytics"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// BankAccountEdge is the edge representation of BankAccount.
type BankAccountEdge struct {
	Node   *BankAccount `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// BankAccountConnection is the connection containing edges to BankAccount.
type BankAccountConnection struct {
	Edges      []*BankAccountEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *BankAccountConnection) build(nodes []*BankAccount, pager *bankaccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BankAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BankAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BankAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*BankAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BankAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BankAccountPaginateOption enables pagination customization.
type BankAccountPaginateOption func(*bankaccountPager) error

// WithBankAccountOrder configures pagination ordering.
func WithBankAccountOrder(order []*BankAccountOrder) BankAccountPaginateOption {
	return func(pager *bankaccountPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBankAccountFilter configures pagination filter.
func WithBankAccountFilter(filter func(*BankAccountQuery) (*BankAccountQuery, error)) BankAccountPaginateOption {
	return func(pager *bankaccountPager) error {
		if filter == nil {
			return errors.New("BankAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bankaccountPager struct {
	reverse bool
	order   []*BankAccountOrder
	filter  func(*BankAccountQuery) (*BankAccountQuery, error)
}

func newBankAccountPager(opts []BankAccountPaginateOption, reverse bool) (*bankaccountPager, error) {
	pager := &bankaccountPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bankaccountPager) applyFilter(query *BankAccountQuery) (*BankAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bankaccountPager) toCursor(ba *BankAccount) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ba).Value)
	}
	return Cursor{ID: ba.ID, Value: cs}
}

func (p *bankaccountPager) applyCursors(query *BankAccountQuery, after, before *Cursor) (*BankAccountQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBankAccountOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bankaccountPager) applyOrder(query *BankAccountQuery) *BankAccountQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBankAccountOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBankAccountOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bankaccountPager) orderExpr(query *BankAccountQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBankAccountOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to BankAccount.
func (ba *BankAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BankAccountPaginateOption,
) (*BankAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBankAccountPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ba, err = pager.applyFilter(ba); err != nil {
		return nil, err
	}
	conn := &BankAccountConnection{Edges: []*BankAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ba.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ba, err = pager.applyCursors(ba, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ba.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ba.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ba = pager.applyOrder(ba)
	nodes, err := ba.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BankAccountOrderFieldXid orders BankAccount by xid.
	BankAccountOrderFieldXid = &BankAccountOrderField{
		Value: func(ba *BankAccount) (ent.Value, error) {
			return ba.Xid, nil
		},
		column: bankaccount.FieldXid,
		toTerm: bankaccount.ByXid,
		toCursor: func(ba *BankAccount) Cursor {
			return Cursor{
				ID:    ba.ID,
				Value: ba.Xid,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BankAccountOrderField) String() string {
	var str string
	switch f.column {
	case BankAccountOrderFieldXid.column:
		str = "XID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BankAccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BankAccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BankAccountOrderField %T must be a string", v)
	}
	switch str {
	case "XID":
		*f = *BankAccountOrderFieldXid
	default:
		return fmt.Errorf("%s is not a valid BankAccountOrderField", str)
	}
	return nil
}

// BankAccountOrderField defines the ordering field of BankAccount.
type BankAccountOrderField struct {
	// Value extracts the ordering value from the given BankAccount.
	Value    func(*BankAccount) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bankaccount.OrderOption
	toCursor func(*BankAccount) Cursor
}

// BankAccountOrder defines the ordering of BankAccount.
type BankAccountOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *BankAccountOrderField `json:"field"`
}

// DefaultBankAccountOrder is the default ordering of BankAccount.
var DefaultBankAccountOrder = &BankAccountOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BankAccountOrderField{
		Value: func(ba *BankAccount) (ent.Value, error) {
			return ba.ID, nil
		},
		column: bankaccount.FieldID,
		toTerm: bankaccount.ByID,
		toCursor: func(ba *BankAccount) Cursor {
			return Cursor{ID: ba.ID}
		},
	},
}

// ToEdge converts BankAccount into BankAccountEdge.
func (ba *BankAccount) ToEdge(order *BankAccountOrder) *BankAccountEdge {
	if order == nil {
		order = DefaultBankAccountOrder
	}
	return &BankAccountEdge{
		Node:   ba,
		Cursor: order.Field.toCursor(ba),
	}
}

// BlogPostEdge is the edge representation of BlogPost.
type BlogPostEdge struct {
	Node   *BlogPost `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// BlogPostConnection is the connection containing edges to BlogPost.
type BlogPostConnection struct {
	Edges      []*BlogPostEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *BlogPostConnection) build(nodes []*BlogPost, pager *blogpostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BlogPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BlogPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BlogPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*BlogPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BlogPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BlogPostPaginateOption enables pagination customization.
type BlogPostPaginateOption func(*blogpostPager) error

// WithBlogPostOrder configures pagination ordering.
func WithBlogPostOrder(order []*BlogPostOrder) BlogPostPaginateOption {
	return func(pager *blogpostPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBlogPostFilter configures pagination filter.
func WithBlogPostFilter(filter func(*BlogPostQuery) (*BlogPostQuery, error)) BlogPostPaginateOption {
	return func(pager *blogpostPager) error {
		if filter == nil {
			return errors.New("BlogPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blogpostPager struct {
	reverse bool
	order   []*BlogPostOrder
	filter  func(*BlogPostQuery) (*BlogPostQuery, error)
}

func newBlogPostPager(opts []BlogPostPaginateOption, reverse bool) (*blogpostPager, error) {
	pager := &blogpostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *blogpostPager) applyFilter(query *BlogPostQuery) (*BlogPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blogpostPager) toCursor(bp *BlogPost) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(bp).Value)
	}
	return Cursor{ID: bp.ID, Value: cs}
}

func (p *blogpostPager) applyCursors(query *BlogPostQuery, after, before *Cursor) (*BlogPostQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBlogPostOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *blogpostPager) applyOrder(query *BlogPostQuery) *BlogPostQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBlogPostOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBlogPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *blogpostPager) orderExpr(query *BlogPostQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBlogPostOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to BlogPost.
func (bp *BlogPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlogPostPaginateOption,
) (*BlogPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlogPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bp, err = pager.applyFilter(bp); err != nil {
		return nil, err
	}
	conn := &BlogPostConnection{Edges: []*BlogPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bp, err = pager.applyCursors(bp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bp = pager.applyOrder(bp)
	nodes, err := bp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BlogPostOrderFieldTitle orders BlogPost by title.
	BlogPostOrderFieldTitle = &BlogPostOrderField{
		Value: func(bp *BlogPost) (ent.Value, error) {
			return bp.Title, nil
		},
		column: blogpost.FieldTitle,
		toTerm: blogpost.ByTitle,
		toCursor: func(bp *BlogPost) Cursor {
			return Cursor{
				ID:    bp.ID,
				Value: bp.Title,
			}
		},
	}
	// BlogPostOrderFieldContent orders BlogPost by content.
	BlogPostOrderFieldContent = &BlogPostOrderField{
		Value: func(bp *BlogPost) (ent.Value, error) {
			return bp.Content, nil
		},
		column: blogpost.FieldContent,
		toTerm: blogpost.ByContent,
		toCursor: func(bp *BlogPost) Cursor {
			return Cursor{
				ID:    bp.ID,
				Value: bp.Content,
			}
		},
	}
	// BlogPostOrderFieldDateCreated orders BlogPost by dateCreated.
	BlogPostOrderFieldDateCreated = &BlogPostOrderField{
		Value: func(bp *BlogPost) (ent.Value, error) {
			return bp.DateCreated, nil
		},
		column: blogpost.FieldDateCreated,
		toTerm: blogpost.ByDateCreated,
		toCursor: func(bp *BlogPost) Cursor {
			return Cursor{
				ID:    bp.ID,
				Value: bp.DateCreated,
			}
		},
	}
	// BlogPostOrderFieldDateUpdated orders BlogPost by dateUpdated.
	BlogPostOrderFieldDateUpdated = &BlogPostOrderField{
		Value: func(bp *BlogPost) (ent.Value, error) {
			return bp.DateUpdated, nil
		},
		column: blogpost.FieldDateUpdated,
		toTerm: blogpost.ByDateUpdated,
		toCursor: func(bp *BlogPost) Cursor {
			return Cursor{
				ID:    bp.ID,
				Value: bp.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BlogPostOrderField) String() string {
	var str string
	switch f.column {
	case BlogPostOrderFieldTitle.column:
		str = "TITLE"
	case BlogPostOrderFieldContent.column:
		str = "CONTENT"
	case BlogPostOrderFieldDateCreated.column:
		str = "DATECREATED"
	case BlogPostOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BlogPostOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BlogPostOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BlogPostOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *BlogPostOrderFieldTitle
	case "CONTENT":
		*f = *BlogPostOrderFieldContent
	case "DATECREATED":
		*f = *BlogPostOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *BlogPostOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid BlogPostOrderField", str)
	}
	return nil
}

// BlogPostOrderField defines the ordering field of BlogPost.
type BlogPostOrderField struct {
	// Value extracts the ordering value from the given BlogPost.
	Value    func(*BlogPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) blogpost.OrderOption
	toCursor func(*BlogPost) Cursor
}

// BlogPostOrder defines the ordering of BlogPost.
type BlogPostOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *BlogPostOrderField `json:"field"`
}

// DefaultBlogPostOrder is the default ordering of BlogPost.
var DefaultBlogPostOrder = &BlogPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BlogPostOrderField{
		Value: func(bp *BlogPost) (ent.Value, error) {
			return bp.ID, nil
		},
		column: blogpost.FieldID,
		toTerm: blogpost.ByID,
		toCursor: func(bp *BlogPost) Cursor {
			return Cursor{ID: bp.ID}
		},
	},
}

// ToEdge converts BlogPost into BlogPostEdge.
func (bp *BlogPost) ToEdge(order *BlogPostOrder) *BlogPostEdge {
	if order == nil {
		order = DefaultBlogPostOrder
	}
	return &BlogPostEdge{
		Node:   bp,
		Cursor: order.Field.toCursor(bp),
	}
}

// CategoryEdge is the edge representation of Category.
type CategoryEdge struct {
	Node   *Category `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CategoryConnection is the connection containing edges to Category.
type CategoryConnection struct {
	Edges      []*CategoryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CategoryConnection) build(nodes []*Category, pager *categoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Category
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Category {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Category {
			return nodes[i]
		}
	}
	c.Edges = make([]*CategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CategoryPaginateOption enables pagination customization.
type CategoryPaginateOption func(*categoryPager) error

// WithCategoryOrder configures pagination ordering.
func WithCategoryOrder(order []*CategoryOrder) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCategoryFilter configures pagination filter.
func WithCategoryFilter(filter func(*CategoryQuery) (*CategoryQuery, error)) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		if filter == nil {
			return errors.New("CategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type categoryPager struct {
	reverse bool
	order   []*CategoryOrder
	filter  func(*CategoryQuery) (*CategoryQuery, error)
}

func newCategoryPager(opts []CategoryPaginateOption, reverse bool) (*categoryPager, error) {
	pager := &categoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *categoryPager) applyFilter(query *CategoryQuery) (*CategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *categoryPager) toCursor(c *Category) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *categoryPager) applyCursors(query *CategoryQuery, after, before *Cursor) (*CategoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCategoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *categoryPager) applyOrder(query *CategoryQuery) *CategoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCategoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *categoryPager) orderExpr(query *CategoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCategoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Category.
func (c *CategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CategoryPaginateOption,
) (*CategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CategoryConnection{Edges: []*CategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CategoryOrderFieldName orders Category by name.
	CategoryOrderFieldName = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.Name, nil
		},
		column: category.FieldName,
		toTerm: category.ByName,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CategoryOrderFieldDescription orders Category by description.
	CategoryOrderFieldDescription = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.Description, nil
		},
		column: category.FieldDescription,
		toTerm: category.ByDescription,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CategoryOrderField) String() string {
	var str string
	switch f.column {
	case CategoryOrderFieldName.column:
		str = "NAME"
	case CategoryOrderFieldDescription.column:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CategoryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CategoryOrderFieldName
	case "DESCRIPTION":
		*f = *CategoryOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid CategoryOrderField", str)
	}
	return nil
}

// CategoryOrderField defines the ordering field of Category.
type CategoryOrderField struct {
	// Value extracts the ordering value from the given Category.
	Value    func(*Category) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) category.OrderOption
	toCursor func(*Category) Cursor
}

// CategoryOrder defines the ordering of Category.
type CategoryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CategoryOrderField `json:"field"`
}

// DefaultCategoryOrder is the default ordering of Category.
var DefaultCategoryOrder = &CategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.ID, nil
		},
		column: category.FieldID,
		toTerm: category.ByID,
		toCursor: func(c *Category) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Category into CategoryEdge.
func (c *Category) ToEdge(order *CategoryOrder) *CategoryEdge {
	if order == nil {
		order = DefaultCategoryOrder
	}
	return &CategoryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ChatEdge is the edge representation of Chat.
type ChatEdge struct {
	Node   *Chat  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ChatConnection is the connection containing edges to Chat.
type ChatConnection struct {
	Edges      []*ChatEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ChatConnection) build(nodes []*Chat, pager *chatPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Chat
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Chat {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Chat {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChatEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChatEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChatPaginateOption enables pagination customization.
type ChatPaginateOption func(*chatPager) error

// WithChatOrder configures pagination ordering.
func WithChatOrder(order []*ChatOrder) ChatPaginateOption {
	return func(pager *chatPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithChatFilter configures pagination filter.
func WithChatFilter(filter func(*ChatQuery) (*ChatQuery, error)) ChatPaginateOption {
	return func(pager *chatPager) error {
		if filter == nil {
			return errors.New("ChatQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type chatPager struct {
	reverse bool
	order   []*ChatOrder
	filter  func(*ChatQuery) (*ChatQuery, error)
}

func newChatPager(opts []ChatPaginateOption, reverse bool) (*chatPager, error) {
	pager := &chatPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *chatPager) applyFilter(query *ChatQuery) (*ChatQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *chatPager) toCursor(c *Chat) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *chatPager) applyCursors(query *ChatQuery, after, before *Cursor) (*ChatQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultChatOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *chatPager) applyOrder(query *ChatQuery) *ChatQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultChatOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultChatOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *chatPager) orderExpr(query *ChatQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultChatOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Chat.
func (c *ChatQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChatPaginateOption,
) (*ChatConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChatPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ChatConnection{Edges: []*ChatEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChatOrderFieldXid orders Chat by xid.
	ChatOrderFieldXid = &ChatOrderField{
		Value: func(c *Chat) (ent.Value, error) {
			return c.Xid, nil
		},
		column: chat.FieldXid,
		toTerm: chat.ByXid,
		toCursor: func(c *Chat) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Xid,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChatOrderField) String() string {
	var str string
	switch f.column {
	case ChatOrderFieldXid.column:
		str = "XID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChatOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChatOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChatOrderField %T must be a string", v)
	}
	switch str {
	case "XID":
		*f = *ChatOrderFieldXid
	default:
		return fmt.Errorf("%s is not a valid ChatOrderField", str)
	}
	return nil
}

// ChatOrderField defines the ordering field of Chat.
type ChatOrderField struct {
	// Value extracts the ordering value from the given Chat.
	Value    func(*Chat) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) chat.OrderOption
	toCursor func(*Chat) Cursor
}

// ChatOrder defines the ordering of Chat.
type ChatOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ChatOrderField `json:"field"`
}

// DefaultChatOrder is the default ordering of Chat.
var DefaultChatOrder = &ChatOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChatOrderField{
		Value: func(c *Chat) (ent.Value, error) {
			return c.ID, nil
		},
		column: chat.FieldID,
		toTerm: chat.ByID,
		toCursor: func(c *Chat) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Chat into ChatEdge.
func (c *Chat) ToEdge(order *ChatOrder) *ChatEdge {
	if order == nil {
		order = DefaultChatOrder
	}
	return &ChatEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CommissionStructureSchemaEdge is the edge representation of CommissionStructureSchema.
type CommissionStructureSchemaEdge struct {
	Node   *CommissionStructureSchema `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// CommissionStructureSchemaConnection is the connection containing edges to CommissionStructureSchema.
type CommissionStructureSchemaConnection struct {
	Edges      []*CommissionStructureSchemaEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *CommissionStructureSchemaConnection) build(nodes []*CommissionStructureSchema, pager *commissionstructureschemaPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CommissionStructureSchema
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CommissionStructureSchema {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CommissionStructureSchema {
			return nodes[i]
		}
	}
	c.Edges = make([]*CommissionStructureSchemaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CommissionStructureSchemaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CommissionStructureSchemaPaginateOption enables pagination customization.
type CommissionStructureSchemaPaginateOption func(*commissionstructureschemaPager) error

// WithCommissionStructureSchemaOrder configures pagination ordering.
func WithCommissionStructureSchemaOrder(order []*CommissionStructureSchemaOrder) CommissionStructureSchemaPaginateOption {
	return func(pager *commissionstructureschemaPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCommissionStructureSchemaFilter configures pagination filter.
func WithCommissionStructureSchemaFilter(filter func(*CommissionStructureSchemaQuery) (*CommissionStructureSchemaQuery, error)) CommissionStructureSchemaPaginateOption {
	return func(pager *commissionstructureschemaPager) error {
		if filter == nil {
			return errors.New("CommissionStructureSchemaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commissionstructureschemaPager struct {
	reverse bool
	order   []*CommissionStructureSchemaOrder
	filter  func(*CommissionStructureSchemaQuery) (*CommissionStructureSchemaQuery, error)
}

func newCommissionStructureSchemaPager(opts []CommissionStructureSchemaPaginateOption, reverse bool) (*commissionstructureschemaPager, error) {
	pager := &commissionstructureschemaPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *commissionstructureschemaPager) applyFilter(query *CommissionStructureSchemaQuery) (*CommissionStructureSchemaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commissionstructureschemaPager) toCursor(css *CommissionStructureSchema) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(css).Value)
	}
	return Cursor{ID: css.ID, Value: cs}
}

func (p *commissionstructureschemaPager) applyCursors(query *CommissionStructureSchemaQuery, after, before *Cursor) (*CommissionStructureSchemaQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCommissionStructureSchemaOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *commissionstructureschemaPager) applyOrder(query *CommissionStructureSchemaQuery) *CommissionStructureSchemaQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCommissionStructureSchemaOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCommissionStructureSchemaOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *commissionstructureschemaPager) orderExpr(query *CommissionStructureSchemaQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCommissionStructureSchemaOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CommissionStructureSchema.
func (css *CommissionStructureSchemaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommissionStructureSchemaPaginateOption,
) (*CommissionStructureSchemaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommissionStructureSchemaPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if css, err = pager.applyFilter(css); err != nil {
		return nil, err
	}
	conn := &CommissionStructureSchemaConnection{Edges: []*CommissionStructureSchemaEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = css.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if css, err = pager.applyCursors(css, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		css.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := css.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	css = pager.applyOrder(css)
	nodes, err := css.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CommissionStructureSchemaOrderFieldName orders CommissionStructureSchema by name.
	CommissionStructureSchemaOrderFieldName = &CommissionStructureSchemaOrderField{
		Value: func(css *CommissionStructureSchema) (ent.Value, error) {
			return css.Name, nil
		},
		column: commissionstructureschema.FieldName,
		toTerm: commissionstructureschema.ByName,
		toCursor: func(css *CommissionStructureSchema) Cursor {
			return Cursor{
				ID:    css.ID,
				Value: css.Name,
			}
		},
	}
	// CommissionStructureSchemaOrderFieldDescription orders CommissionStructureSchema by description.
	CommissionStructureSchemaOrderFieldDescription = &CommissionStructureSchemaOrderField{
		Value: func(css *CommissionStructureSchema) (ent.Value, error) {
			return css.Description, nil
		},
		column: commissionstructureschema.FieldDescription,
		toTerm: commissionstructureschema.ByDescription,
		toCursor: func(css *CommissionStructureSchema) Cursor {
			return Cursor{
				ID:    css.ID,
				Value: css.Description,
			}
		},
	}
	// CommissionStructureSchemaOrderFieldCommissionValue orders CommissionStructureSchema by commissionValue.
	CommissionStructureSchemaOrderFieldCommissionValue = &CommissionStructureSchemaOrderField{
		Value: func(css *CommissionStructureSchema) (ent.Value, error) {
			return css.CommissionValue, nil
		},
		column: commissionstructureschema.FieldCommissionValue,
		toTerm: commissionstructureschema.ByCommissionValue,
		toCursor: func(css *CommissionStructureSchema) Cursor {
			return Cursor{
				ID:    css.ID,
				Value: css.CommissionValue,
			}
		},
	}
	// CommissionStructureSchemaOrderFieldCommissionPercentage orders CommissionStructureSchema by commissionPercentage.
	CommissionStructureSchemaOrderFieldCommissionPercentage = &CommissionStructureSchemaOrderField{
		Value: func(css *CommissionStructureSchema) (ent.Value, error) {
			return css.CommissionPercentage, nil
		},
		column: commissionstructureschema.FieldCommissionPercentage,
		toTerm: commissionstructureschema.ByCommissionPercentage,
		toCursor: func(css *CommissionStructureSchema) Cursor {
			return Cursor{
				ID:    css.ID,
				Value: css.CommissionPercentage,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CommissionStructureSchemaOrderField) String() string {
	var str string
	switch f.column {
	case CommissionStructureSchemaOrderFieldName.column:
		str = "NAME"
	case CommissionStructureSchemaOrderFieldDescription.column:
		str = "DESCRIPTION"
	case CommissionStructureSchemaOrderFieldCommissionValue.column:
		str = "COMMISSIONVALUE"
	case CommissionStructureSchemaOrderFieldCommissionPercentage.column:
		str = "COMMISSIONPERCENTAGE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CommissionStructureSchemaOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CommissionStructureSchemaOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CommissionStructureSchemaOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CommissionStructureSchemaOrderFieldName
	case "DESCRIPTION":
		*f = *CommissionStructureSchemaOrderFieldDescription
	case "COMMISSIONVALUE":
		*f = *CommissionStructureSchemaOrderFieldCommissionValue
	case "COMMISSIONPERCENTAGE":
		*f = *CommissionStructureSchemaOrderFieldCommissionPercentage
	default:
		return fmt.Errorf("%s is not a valid CommissionStructureSchemaOrderField", str)
	}
	return nil
}

// CommissionStructureSchemaOrderField defines the ordering field of CommissionStructureSchema.
type CommissionStructureSchemaOrderField struct {
	// Value extracts the ordering value from the given CommissionStructureSchema.
	Value    func(*CommissionStructureSchema) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) commissionstructureschema.OrderOption
	toCursor func(*CommissionStructureSchema) Cursor
}

// CommissionStructureSchemaOrder defines the ordering of CommissionStructureSchema.
type CommissionStructureSchemaOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *CommissionStructureSchemaOrderField `json:"field"`
}

// DefaultCommissionStructureSchemaOrder is the default ordering of CommissionStructureSchema.
var DefaultCommissionStructureSchemaOrder = &CommissionStructureSchemaOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CommissionStructureSchemaOrderField{
		Value: func(css *CommissionStructureSchema) (ent.Value, error) {
			return css.ID, nil
		},
		column: commissionstructureschema.FieldID,
		toTerm: commissionstructureschema.ByID,
		toCursor: func(css *CommissionStructureSchema) Cursor {
			return Cursor{ID: css.ID}
		},
	},
}

// ToEdge converts CommissionStructureSchema into CommissionStructureSchemaEdge.
func (css *CommissionStructureSchema) ToEdge(order *CommissionStructureSchemaOrder) *CommissionStructureSchemaEdge {
	if order == nil {
		order = DefaultCommissionStructureSchemaOrder
	}
	return &CommissionStructureSchemaEdge{
		Node:   css,
		Cursor: order.Field.toCursor(css),
	}
}

// ContentBlockEdge is the edge representation of ContentBlock.
type ContentBlockEdge struct {
	Node   *ContentBlock `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ContentBlockConnection is the connection containing edges to ContentBlock.
type ContentBlockConnection struct {
	Edges      []*ContentBlockEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ContentBlockConnection) build(nodes []*ContentBlock, pager *contentblockPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ContentBlock
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContentBlock {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContentBlock {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContentBlockEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContentBlockEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContentBlockPaginateOption enables pagination customization.
type ContentBlockPaginateOption func(*contentblockPager) error

// WithContentBlockOrder configures pagination ordering.
func WithContentBlockOrder(order []*ContentBlockOrder) ContentBlockPaginateOption {
	return func(pager *contentblockPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithContentBlockFilter configures pagination filter.
func WithContentBlockFilter(filter func(*ContentBlockQuery) (*ContentBlockQuery, error)) ContentBlockPaginateOption {
	return func(pager *contentblockPager) error {
		if filter == nil {
			return errors.New("ContentBlockQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contentblockPager struct {
	reverse bool
	order   []*ContentBlockOrder
	filter  func(*ContentBlockQuery) (*ContentBlockQuery, error)
}

func newContentBlockPager(opts []ContentBlockPaginateOption, reverse bool) (*contentblockPager, error) {
	pager := &contentblockPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *contentblockPager) applyFilter(query *ContentBlockQuery) (*ContentBlockQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contentblockPager) toCursor(cb *ContentBlock) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(cb).Value)
	}
	return Cursor{ID: cb.ID, Value: cs}
}

func (p *contentblockPager) applyCursors(query *ContentBlockQuery, after, before *Cursor) (*ContentBlockQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultContentBlockOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contentblockPager) applyOrder(query *ContentBlockQuery) *ContentBlockQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultContentBlockOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultContentBlockOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *contentblockPager) orderExpr(query *ContentBlockQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultContentBlockOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContentBlock.
func (cb *ContentBlockQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContentBlockPaginateOption,
) (*ContentBlockConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContentBlockPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cb, err = pager.applyFilter(cb); err != nil {
		return nil, err
	}
	conn := &ContentBlockConnection{Edges: []*ContentBlockEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cb.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cb, err = pager.applyCursors(cb, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cb.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cb = pager.applyOrder(cb)
	nodes, err := cb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContentBlockOrderFieldPrimaryMessage orders ContentBlock by primaryMessage.
	ContentBlockOrderFieldPrimaryMessage = &ContentBlockOrderField{
		Value: func(cb *ContentBlock) (ent.Value, error) {
			return cb.PrimaryMessage, nil
		},
		column: contentblock.FieldPrimaryMessage,
		toTerm: contentblock.ByPrimaryMessage,
		toCursor: func(cb *ContentBlock) Cursor {
			return Cursor{
				ID:    cb.ID,
				Value: cb.PrimaryMessage,
			}
		},
	}
	// ContentBlockOrderFieldSecondaryMessage orders ContentBlock by secondaryMessage.
	ContentBlockOrderFieldSecondaryMessage = &ContentBlockOrderField{
		Value: func(cb *ContentBlock) (ent.Value, error) {
			return cb.SecondaryMessage, nil
		},
		column: contentblock.FieldSecondaryMessage,
		toTerm: contentblock.BySecondaryMessage,
		toCursor: func(cb *ContentBlock) Cursor {
			return Cursor{
				ID:    cb.ID,
				Value: cb.SecondaryMessage,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContentBlockOrderField) String() string {
	var str string
	switch f.column {
	case ContentBlockOrderFieldPrimaryMessage.column:
		str = "PRIMARYMESSAGE"
	case ContentBlockOrderFieldSecondaryMessage.column:
		str = "SECONDARYMESSAGE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContentBlockOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContentBlockOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContentBlockOrderField %T must be a string", v)
	}
	switch str {
	case "PRIMARYMESSAGE":
		*f = *ContentBlockOrderFieldPrimaryMessage
	case "SECONDARYMESSAGE":
		*f = *ContentBlockOrderFieldSecondaryMessage
	default:
		return fmt.Errorf("%s is not a valid ContentBlockOrderField", str)
	}
	return nil
}

// ContentBlockOrderField defines the ordering field of ContentBlock.
type ContentBlockOrderField struct {
	// Value extracts the ordering value from the given ContentBlock.
	Value    func(*ContentBlock) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contentblock.OrderOption
	toCursor func(*ContentBlock) Cursor
}

// ContentBlockOrder defines the ordering of ContentBlock.
type ContentBlockOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ContentBlockOrderField `json:"field"`
}

// DefaultContentBlockOrder is the default ordering of ContentBlock.
var DefaultContentBlockOrder = &ContentBlockOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContentBlockOrderField{
		Value: func(cb *ContentBlock) (ent.Value, error) {
			return cb.ID, nil
		},
		column: contentblock.FieldID,
		toTerm: contentblock.ByID,
		toCursor: func(cb *ContentBlock) Cursor {
			return Cursor{ID: cb.ID}
		},
	},
}

// ToEdge converts ContentBlock into ContentBlockEdge.
func (cb *ContentBlock) ToEdge(order *ContentBlockOrder) *ContentBlockEdge {
	if order == nil {
		order = DefaultContentBlockOrder
	}
	return &ContentBlockEdge{
		Node:   cb,
		Cursor: order.Field.toCursor(cb),
	}
}

// EmailCampaignEdge is the edge representation of EmailCampaign.
type EmailCampaignEdge struct {
	Node   *EmailCampaign `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EmailCampaignConnection is the connection containing edges to EmailCampaign.
type EmailCampaignConnection struct {
	Edges      []*EmailCampaignEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EmailCampaignConnection) build(nodes []*EmailCampaign, pager *emailcampaignPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EmailCampaign
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailCampaign {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailCampaign {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailCampaignEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailCampaignEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailCampaignPaginateOption enables pagination customization.
type EmailCampaignPaginateOption func(*emailcampaignPager) error

// WithEmailCampaignOrder configures pagination ordering.
func WithEmailCampaignOrder(order []*EmailCampaignOrder) EmailCampaignPaginateOption {
	return func(pager *emailcampaignPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEmailCampaignFilter configures pagination filter.
func WithEmailCampaignFilter(filter func(*EmailCampaignQuery) (*EmailCampaignQuery, error)) EmailCampaignPaginateOption {
	return func(pager *emailcampaignPager) error {
		if filter == nil {
			return errors.New("EmailCampaignQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailcampaignPager struct {
	reverse bool
	order   []*EmailCampaignOrder
	filter  func(*EmailCampaignQuery) (*EmailCampaignQuery, error)
}

func newEmailCampaignPager(opts []EmailCampaignPaginateOption, reverse bool) (*emailcampaignPager, error) {
	pager := &emailcampaignPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *emailcampaignPager) applyFilter(query *EmailCampaignQuery) (*EmailCampaignQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailcampaignPager) toCursor(ec *EmailCampaign) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ec).Value)
	}
	return Cursor{ID: ec.ID, Value: cs}
}

func (p *emailcampaignPager) applyCursors(query *EmailCampaignQuery, after, before *Cursor) (*EmailCampaignQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEmailCampaignOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *emailcampaignPager) applyOrder(query *EmailCampaignQuery) *EmailCampaignQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEmailCampaignOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEmailCampaignOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *emailcampaignPager) orderExpr(query *EmailCampaignQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEmailCampaignOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailCampaign.
func (ec *EmailCampaignQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailCampaignPaginateOption,
) (*EmailCampaignConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailCampaignPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ec, err = pager.applyFilter(ec); err != nil {
		return nil, err
	}
	conn := &EmailCampaignConnection{Edges: []*EmailCampaignEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ec.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ec, err = pager.applyCursors(ec, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ec.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ec.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ec = pager.applyOrder(ec)
	nodes, err := ec.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailCampaignOrderFieldXid orders EmailCampaign by xid.
	EmailCampaignOrderFieldXid = &EmailCampaignOrderField{
		Value: func(ec *EmailCampaign) (ent.Value, error) {
			return ec.Xid, nil
		},
		column: emailcampaign.FieldXid,
		toTerm: emailcampaign.ByXid,
		toCursor: func(ec *EmailCampaign) Cursor {
			return Cursor{
				ID:    ec.ID,
				Value: ec.Xid,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailCampaignOrderField) String() string {
	var str string
	switch f.column {
	case EmailCampaignOrderFieldXid.column:
		str = "XID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailCampaignOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailCampaignOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailCampaignOrderField %T must be a string", v)
	}
	switch str {
	case "XID":
		*f = *EmailCampaignOrderFieldXid
	default:
		return fmt.Errorf("%s is not a valid EmailCampaignOrderField", str)
	}
	return nil
}

// EmailCampaignOrderField defines the ordering field of EmailCampaign.
type EmailCampaignOrderField struct {
	// Value extracts the ordering value from the given EmailCampaign.
	Value    func(*EmailCampaign) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) emailcampaign.OrderOption
	toCursor func(*EmailCampaign) Cursor
}

// EmailCampaignOrder defines the ordering of EmailCampaign.
type EmailCampaignOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EmailCampaignOrderField `json:"field"`
}

// DefaultEmailCampaignOrder is the default ordering of EmailCampaign.
var DefaultEmailCampaignOrder = &EmailCampaignOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmailCampaignOrderField{
		Value: func(ec *EmailCampaign) (ent.Value, error) {
			return ec.ID, nil
		},
		column: emailcampaign.FieldID,
		toTerm: emailcampaign.ByID,
		toCursor: func(ec *EmailCampaign) Cursor {
			return Cursor{ID: ec.ID}
		},
	},
}

// ToEdge converts EmailCampaign into EmailCampaignEdge.
func (ec *EmailCampaign) ToEdge(order *EmailCampaignOrder) *EmailCampaignEdge {
	if order == nil {
		order = DefaultEmailCampaignOrder
	}
	return &EmailCampaignEdge{
		Node:   ec,
		Cursor: order.Field.toCursor(ec),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order []*GroupOrder) GroupPaginateOption {
	return func(pager *groupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   []*GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(gr *Group) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(gr).Value)
	}
	return Cursor{ID: gr.ID, Value: cs}
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (gr *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gr, err = pager.applyFilter(gr); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = gr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gr, err = pager.applyCursors(gr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		gr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gr = pager.applyOrder(gr)
	nodes, err := gr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupOrderFieldName orders Group by name.
	GroupOrderFieldName = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.Name, nil
		},
		column: group.FieldName,
		toTerm: group.ByName,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupOrderField) String() string {
	var str string
	switch f.column {
	case GroupOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *GroupOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(gr *Group) Cursor {
			return Cursor{ID: gr.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (gr *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   gr,
		Cursor: order.Field.toCursor(gr),
	}
}

// GroupBuyEdge is the edge representation of GroupBuy.
type GroupBuyEdge struct {
	Node   *GroupBuy `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// GroupBuyConnection is the connection containing edges to GroupBuy.
type GroupBuyConnection struct {
	Edges      []*GroupBuyEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *GroupBuyConnection) build(nodes []*GroupBuy, pager *groupbuyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupBuy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupBuy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupBuy {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupBuyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupBuyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupBuyPaginateOption enables pagination customization.
type GroupBuyPaginateOption func(*groupbuyPager) error

// WithGroupBuyOrder configures pagination ordering.
func WithGroupBuyOrder(order []*GroupBuyOrder) GroupBuyPaginateOption {
	return func(pager *groupbuyPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupBuyFilter configures pagination filter.
func WithGroupBuyFilter(filter func(*GroupBuyQuery) (*GroupBuyQuery, error)) GroupBuyPaginateOption {
	return func(pager *groupbuyPager) error {
		if filter == nil {
			return errors.New("GroupBuyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupbuyPager struct {
	reverse bool
	order   []*GroupBuyOrder
	filter  func(*GroupBuyQuery) (*GroupBuyQuery, error)
}

func newGroupBuyPager(opts []GroupBuyPaginateOption, reverse bool) (*groupbuyPager, error) {
	pager := &groupbuyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupbuyPager) applyFilter(query *GroupBuyQuery) (*GroupBuyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupbuyPager) toCursor(gb *GroupBuy) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(gb).Value)
	}
	return Cursor{ID: gb.ID, Value: cs}
}

func (p *groupbuyPager) applyCursors(query *GroupBuyQuery, after, before *Cursor) (*GroupBuyQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupBuyOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupbuyPager) applyOrder(query *GroupBuyQuery) *GroupBuyQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupBuyOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupBuyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupbuyPager) orderExpr(query *GroupBuyQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupBuyOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupBuy.
func (gb *GroupBuyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupBuyPaginateOption,
) (*GroupBuyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupBuyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gb, err = pager.applyFilter(gb); err != nil {
		return nil, err
	}
	conn := &GroupBuyConnection{Edges: []*GroupBuyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = gb.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gb, err = pager.applyCursors(gb, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		gb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gb.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gb = pager.applyOrder(gb)
	nodes, err := gb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupBuyOrderFieldDateCreated orders GroupBuy by dateCreated.
	GroupBuyOrderFieldDateCreated = &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.DateCreated, nil
		},
		column: groupbuy.FieldDateCreated,
		toTerm: groupbuy.ByDateCreated,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{
				ID:    gb.ID,
				Value: gb.DateCreated,
			}
		},
	}
	// GroupBuyOrderFieldProductPrice orders GroupBuy by productPrice.
	GroupBuyOrderFieldProductPrice = &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.ProductPrice, nil
		},
		column: groupbuy.FieldProductPrice,
		toTerm: groupbuy.ByProductPrice,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{
				ID:    gb.ID,
				Value: gb.ProductPrice,
			}
		},
	}
	// GroupBuyOrderFieldMoq orders GroupBuy by moq.
	GroupBuyOrderFieldMoq = &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.Moq, nil
		},
		column: groupbuy.FieldMoq,
		toTerm: groupbuy.ByMoq,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{
				ID:    gb.ID,
				Value: gb.Moq,
			}
		},
	}
	// GroupBuyOrderFieldStartDate orders GroupBuy by startDate.
	GroupBuyOrderFieldStartDate = &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.StartDate, nil
		},
		column: groupbuy.FieldStartDate,
		toTerm: groupbuy.ByStartDate,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{
				ID:    gb.ID,
				Value: gb.StartDate,
			}
		},
	}
	// GroupBuyOrderFieldEndDate orders GroupBuy by endDate.
	GroupBuyOrderFieldEndDate = &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.EndDate, nil
		},
		column: groupbuy.FieldEndDate,
		toTerm: groupbuy.ByEndDate,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{
				ID:    gb.ID,
				Value: gb.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupBuyOrderField) String() string {
	var str string
	switch f.column {
	case GroupBuyOrderFieldDateCreated.column:
		str = "DATECREATED"
	case GroupBuyOrderFieldProductPrice.column:
		str = "PRODUCTPRICE"
	case GroupBuyOrderFieldMoq.column:
		str = "MOQ"
	case GroupBuyOrderFieldStartDate.column:
		str = "STARTDATE"
	case GroupBuyOrderFieldEndDate.column:
		str = "ENDDATE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupBuyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupBuyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupBuyOrderField %T must be a string", v)
	}
	switch str {
	case "DATECREATED":
		*f = *GroupBuyOrderFieldDateCreated
	case "PRODUCTPRICE":
		*f = *GroupBuyOrderFieldProductPrice
	case "MOQ":
		*f = *GroupBuyOrderFieldMoq
	case "STARTDATE":
		*f = *GroupBuyOrderFieldStartDate
	case "ENDDATE":
		*f = *GroupBuyOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid GroupBuyOrderField", str)
	}
	return nil
}

// GroupBuyOrderField defines the ordering field of GroupBuy.
type GroupBuyOrderField struct {
	// Value extracts the ordering value from the given GroupBuy.
	Value    func(*GroupBuy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupbuy.OrderOption
	toCursor func(*GroupBuy) Cursor
}

// GroupBuyOrder defines the ordering of GroupBuy.
type GroupBuyOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *GroupBuyOrderField `json:"field"`
}

// DefaultGroupBuyOrder is the default ordering of GroupBuy.
var DefaultGroupBuyOrder = &GroupBuyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupBuyOrderField{
		Value: func(gb *GroupBuy) (ent.Value, error) {
			return gb.ID, nil
		},
		column: groupbuy.FieldID,
		toTerm: groupbuy.ByID,
		toCursor: func(gb *GroupBuy) Cursor {
			return Cursor{ID: gb.ID}
		},
	},
}

// ToEdge converts GroupBuy into GroupBuyEdge.
func (gb *GroupBuy) ToEdge(order *GroupBuyOrder) *GroupBuyEdge {
	if order == nil {
		order = DefaultGroupBuyOrder
	}
	return &GroupBuyEdge{
		Node:   gb,
		Cursor: order.Field.toCursor(gb),
	}
}

// HeroContentEdge is the edge representation of HeroContent.
type HeroContentEdge struct {
	Node   *HeroContent `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// HeroContentConnection is the connection containing edges to HeroContent.
type HeroContentConnection struct {
	Edges      []*HeroContentEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *HeroContentConnection) build(nodes []*HeroContent, pager *herocontentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HeroContent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HeroContent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HeroContent {
			return nodes[i]
		}
	}
	c.Edges = make([]*HeroContentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HeroContentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HeroContentPaginateOption enables pagination customization.
type HeroContentPaginateOption func(*herocontentPager) error

// WithHeroContentOrder configures pagination ordering.
func WithHeroContentOrder(order []*HeroContentOrder) HeroContentPaginateOption {
	return func(pager *herocontentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHeroContentFilter configures pagination filter.
func WithHeroContentFilter(filter func(*HeroContentQuery) (*HeroContentQuery, error)) HeroContentPaginateOption {
	return func(pager *herocontentPager) error {
		if filter == nil {
			return errors.New("HeroContentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type herocontentPager struct {
	reverse bool
	order   []*HeroContentOrder
	filter  func(*HeroContentQuery) (*HeroContentQuery, error)
}

func newHeroContentPager(opts []HeroContentPaginateOption, reverse bool) (*herocontentPager, error) {
	pager := &herocontentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *herocontentPager) applyFilter(query *HeroContentQuery) (*HeroContentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *herocontentPager) toCursor(hc *HeroContent) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(hc).Value)
	}
	return Cursor{ID: hc.ID, Value: cs}
}

func (p *herocontentPager) applyCursors(query *HeroContentQuery, after, before *Cursor) (*HeroContentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHeroContentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *herocontentPager) applyOrder(query *HeroContentQuery) *HeroContentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHeroContentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHeroContentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *herocontentPager) orderExpr(query *HeroContentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHeroContentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to HeroContent.
func (hc *HeroContentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HeroContentPaginateOption,
) (*HeroContentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHeroContentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hc, err = pager.applyFilter(hc); err != nil {
		return nil, err
	}
	conn := &HeroContentConnection{Edges: []*HeroContentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hc, err = pager.applyCursors(hc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		hc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hc = pager.applyOrder(hc)
	nodes, err := hc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HeroContentOrderFieldPrimaryMessage orders HeroContent by primaryMessage.
	HeroContentOrderFieldPrimaryMessage = &HeroContentOrderField{
		Value: func(hc *HeroContent) (ent.Value, error) {
			return hc.PrimaryMessage, nil
		},
		column: herocontent.FieldPrimaryMessage,
		toTerm: herocontent.ByPrimaryMessage,
		toCursor: func(hc *HeroContent) Cursor {
			return Cursor{
				ID:    hc.ID,
				Value: hc.PrimaryMessage,
			}
		},
	}
	// HeroContentOrderFieldSecondaryMessage orders HeroContent by secondaryMessage.
	HeroContentOrderFieldSecondaryMessage = &HeroContentOrderField{
		Value: func(hc *HeroContent) (ent.Value, error) {
			return hc.SecondaryMessage, nil
		},
		column: herocontent.FieldSecondaryMessage,
		toTerm: herocontent.BySecondaryMessage,
		toCursor: func(hc *HeroContent) Cursor {
			return Cursor{
				ID:    hc.ID,
				Value: hc.SecondaryMessage,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HeroContentOrderField) String() string {
	var str string
	switch f.column {
	case HeroContentOrderFieldPrimaryMessage.column:
		str = "PRIMARYMESSAGE"
	case HeroContentOrderFieldSecondaryMessage.column:
		str = "SECONDARYMESSAGE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HeroContentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HeroContentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HeroContentOrderField %T must be a string", v)
	}
	switch str {
	case "PRIMARYMESSAGE":
		*f = *HeroContentOrderFieldPrimaryMessage
	case "SECONDARYMESSAGE":
		*f = *HeroContentOrderFieldSecondaryMessage
	default:
		return fmt.Errorf("%s is not a valid HeroContentOrderField", str)
	}
	return nil
}

// HeroContentOrderField defines the ordering field of HeroContent.
type HeroContentOrderField struct {
	// Value extracts the ordering value from the given HeroContent.
	Value    func(*HeroContent) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) herocontent.OrderOption
	toCursor func(*HeroContent) Cursor
}

// HeroContentOrder defines the ordering of HeroContent.
type HeroContentOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *HeroContentOrderField `json:"field"`
}

// DefaultHeroContentOrder is the default ordering of HeroContent.
var DefaultHeroContentOrder = &HeroContentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HeroContentOrderField{
		Value: func(hc *HeroContent) (ent.Value, error) {
			return hc.ID, nil
		},
		column: herocontent.FieldID,
		toTerm: herocontent.ByID,
		toCursor: func(hc *HeroContent) Cursor {
			return Cursor{ID: hc.ID}
		},
	},
}

// ToEdge converts HeroContent into HeroContentEdge.
func (hc *HeroContent) ToEdge(order *HeroContentOrder) *HeroContentEdge {
	if order == nil {
		order = DefaultHeroContentOrder
	}
	return &HeroContentEdge{
		Node:   hc,
		Cursor: order.Field.toCursor(hc),
	}
}

// ImageEdge is the edge representation of Image.
type ImageEdge struct {
	Node   *Image `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ImageConnection is the connection containing edges to Image.
type ImageConnection struct {
	Edges      []*ImageEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ImageConnection) build(nodes []*Image, pager *imagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Image
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Image {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Image {
			return nodes[i]
		}
	}
	c.Edges = make([]*ImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ImagePaginateOption enables pagination customization.
type ImagePaginateOption func(*imagePager) error

// WithImageOrder configures pagination ordering.
func WithImageOrder(order []*ImageOrder) ImagePaginateOption {
	return func(pager *imagePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithImageFilter configures pagination filter.
func WithImageFilter(filter func(*ImageQuery) (*ImageQuery, error)) ImagePaginateOption {
	return func(pager *imagePager) error {
		if filter == nil {
			return errors.New("ImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type imagePager struct {
	reverse bool
	order   []*ImageOrder
	filter  func(*ImageQuery) (*ImageQuery, error)
}

func newImagePager(opts []ImagePaginateOption, reverse bool) (*imagePager, error) {
	pager := &imagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *imagePager) applyFilter(query *ImageQuery) (*ImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *imagePager) toCursor(i *Image) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs}
}

func (p *imagePager) applyCursors(query *ImageQuery, after, before *Cursor) (*ImageQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultImageOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *imagePager) applyOrder(query *ImageQuery) *ImageQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultImageOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultImageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *imagePager) orderExpr(query *ImageQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultImageOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Image.
func (i *ImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ImagePaginateOption,
) (*ImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newImagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &ImageConnection{Edges: []*ImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ImageOrderFieldName orders Image by name.
	ImageOrderFieldName = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.Name, nil
		},
		column: image.FieldName,
		toTerm: image.ByName,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Name,
			}
		},
	}
	// ImageOrderFieldDescription orders Image by description.
	ImageOrderFieldDescription = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.Description, nil
		},
		column: image.FieldDescription,
		toTerm: image.ByDescription,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Description,
			}
		},
	}
	// ImageOrderFieldURL orders Image by url.
	ImageOrderFieldURL = &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.URL, nil
		},
		column: image.FieldURL,
		toTerm: image.ByURL,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.URL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ImageOrderField) String() string {
	var str string
	switch f.column {
	case ImageOrderFieldName.column:
		str = "NAME"
	case ImageOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ImageOrderFieldURL.column:
		str = "URL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ImageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ImageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ImageOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ImageOrderFieldName
	case "DESCRIPTION":
		*f = *ImageOrderFieldDescription
	case "URL":
		*f = *ImageOrderFieldURL
	default:
		return fmt.Errorf("%s is not a valid ImageOrderField", str)
	}
	return nil
}

// ImageOrderField defines the ordering field of Image.
type ImageOrderField struct {
	// Value extracts the ordering value from the given Image.
	Value    func(*Image) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) image.OrderOption
	toCursor func(*Image) Cursor
}

// ImageOrder defines the ordering of Image.
type ImageOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ImageOrderField `json:"field"`
}

// DefaultImageOrder is the default ordering of Image.
var DefaultImageOrder = &ImageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.ID, nil
		},
		column: image.FieldID,
		toTerm: image.ByID,
		toCursor: func(i *Image) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Image into ImageEdge.
func (i *Image) ToEdge(order *ImageOrder) *ImageEdge {
	if order == nil {
		order = DefaultImageOrder
	}
	return &ImageEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// LinkVisitEdge is the edge representation of LinkVisit.
type LinkVisitEdge struct {
	Node   *LinkVisit `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// LinkVisitConnection is the connection containing edges to LinkVisit.
type LinkVisitConnection struct {
	Edges      []*LinkVisitEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *LinkVisitConnection) build(nodes []*LinkVisit, pager *linkvisitPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LinkVisit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LinkVisit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LinkVisit {
			return nodes[i]
		}
	}
	c.Edges = make([]*LinkVisitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LinkVisitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LinkVisitPaginateOption enables pagination customization.
type LinkVisitPaginateOption func(*linkvisitPager) error

// WithLinkVisitOrder configures pagination ordering.
func WithLinkVisitOrder(order []*LinkVisitOrder) LinkVisitPaginateOption {
	return func(pager *linkvisitPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLinkVisitFilter configures pagination filter.
func WithLinkVisitFilter(filter func(*LinkVisitQuery) (*LinkVisitQuery, error)) LinkVisitPaginateOption {
	return func(pager *linkvisitPager) error {
		if filter == nil {
			return errors.New("LinkVisitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type linkvisitPager struct {
	reverse bool
	order   []*LinkVisitOrder
	filter  func(*LinkVisitQuery) (*LinkVisitQuery, error)
}

func newLinkVisitPager(opts []LinkVisitPaginateOption, reverse bool) (*linkvisitPager, error) {
	pager := &linkvisitPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *linkvisitPager) applyFilter(query *LinkVisitQuery) (*LinkVisitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *linkvisitPager) toCursor(lv *LinkVisit) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(lv).Value)
	}
	return Cursor{ID: lv.ID, Value: cs}
}

func (p *linkvisitPager) applyCursors(query *LinkVisitQuery, after, before *Cursor) (*LinkVisitQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLinkVisitOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *linkvisitPager) applyOrder(query *LinkVisitQuery) *LinkVisitQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLinkVisitOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLinkVisitOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *linkvisitPager) orderExpr(query *LinkVisitQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLinkVisitOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to LinkVisit.
func (lv *LinkVisitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LinkVisitPaginateOption,
) (*LinkVisitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLinkVisitPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if lv, err = pager.applyFilter(lv); err != nil {
		return nil, err
	}
	conn := &LinkVisitConnection{Edges: []*LinkVisitEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = lv.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if lv, err = pager.applyCursors(lv, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		lv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := lv.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	lv = pager.applyOrder(lv)
	nodes, err := lv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LinkVisitOrderFieldDateCreated orders LinkVisit by dateCreated.
	LinkVisitOrderFieldDateCreated = &LinkVisitOrderField{
		Value: func(lv *LinkVisit) (ent.Value, error) {
			return lv.DateCreated, nil
		},
		column: linkvisit.FieldDateCreated,
		toTerm: linkvisit.ByDateCreated,
		toCursor: func(lv *LinkVisit) Cursor {
			return Cursor{
				ID:    lv.ID,
				Value: lv.DateCreated,
			}
		},
	}
	// LinkVisitOrderFieldIpAddress orders LinkVisit by ipAddress.
	LinkVisitOrderFieldIpAddress = &LinkVisitOrderField{
		Value: func(lv *LinkVisit) (ent.Value, error) {
			return lv.IpAddress, nil
		},
		column: linkvisit.FieldIpAddress,
		toTerm: linkvisit.ByIpAddress,
		toCursor: func(lv *LinkVisit) Cursor {
			return Cursor{
				ID:    lv.ID,
				Value: lv.IpAddress,
			}
		},
	}
	// LinkVisitOrderFieldSaleValue orders LinkVisit by saleValue.
	LinkVisitOrderFieldSaleValue = &LinkVisitOrderField{
		Value: func(lv *LinkVisit) (ent.Value, error) {
			return lv.SaleValue, nil
		},
		column: linkvisit.FieldSaleValue,
		toTerm: linkvisit.BySaleValue,
		toCursor: func(lv *LinkVisit) Cursor {
			return Cursor{
				ID:    lv.ID,
				Value: lv.SaleValue,
			}
		},
	}
	// LinkVisitOrderFieldCommissionEarned orders LinkVisit by commissionEarned.
	LinkVisitOrderFieldCommissionEarned = &LinkVisitOrderField{
		Value: func(lv *LinkVisit) (ent.Value, error) {
			return lv.CommissionEarned, nil
		},
		column: linkvisit.FieldCommissionEarned,
		toTerm: linkvisit.ByCommissionEarned,
		toCursor: func(lv *LinkVisit) Cursor {
			return Cursor{
				ID:    lv.ID,
				Value: lv.CommissionEarned,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LinkVisitOrderField) String() string {
	var str string
	switch f.column {
	case LinkVisitOrderFieldDateCreated.column:
		str = "DATECREATED"
	case LinkVisitOrderFieldIpAddress.column:
		str = "IPADDRESS"
	case LinkVisitOrderFieldSaleValue.column:
		str = "SALEVALUE"
	case LinkVisitOrderFieldCommissionEarned.column:
		str = "COMMISSIONEARNED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LinkVisitOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LinkVisitOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LinkVisitOrderField %T must be a string", v)
	}
	switch str {
	case "DATECREATED":
		*f = *LinkVisitOrderFieldDateCreated
	case "IPADDRESS":
		*f = *LinkVisitOrderFieldIpAddress
	case "SALEVALUE":
		*f = *LinkVisitOrderFieldSaleValue
	case "COMMISSIONEARNED":
		*f = *LinkVisitOrderFieldCommissionEarned
	default:
		return fmt.Errorf("%s is not a valid LinkVisitOrderField", str)
	}
	return nil
}

// LinkVisitOrderField defines the ordering field of LinkVisit.
type LinkVisitOrderField struct {
	// Value extracts the ordering value from the given LinkVisit.
	Value    func(*LinkVisit) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) linkvisit.OrderOption
	toCursor func(*LinkVisit) Cursor
}

// LinkVisitOrder defines the ordering of LinkVisit.
type LinkVisitOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *LinkVisitOrderField `json:"field"`
}

// DefaultLinkVisitOrder is the default ordering of LinkVisit.
var DefaultLinkVisitOrder = &LinkVisitOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LinkVisitOrderField{
		Value: func(lv *LinkVisit) (ent.Value, error) {
			return lv.ID, nil
		},
		column: linkvisit.FieldID,
		toTerm: linkvisit.ByID,
		toCursor: func(lv *LinkVisit) Cursor {
			return Cursor{ID: lv.ID}
		},
	},
}

// ToEdge converts LinkVisit into LinkVisitEdge.
func (lv *LinkVisit) ToEdge(order *LinkVisitOrder) *LinkVisitEdge {
	if order == nil {
		order = DefaultLinkVisitOrder
	}
	return &LinkVisitEdge{
		Node:   lv,
		Cursor: order.Field.toCursor(lv),
	}
}

// MarketingCampaignEdge is the edge representation of MarketingCampaign.
type MarketingCampaignEdge struct {
	Node   *MarketingCampaign `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// MarketingCampaignConnection is the connection containing edges to MarketingCampaign.
type MarketingCampaignConnection struct {
	Edges      []*MarketingCampaignEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *MarketingCampaignConnection) build(nodes []*MarketingCampaign, pager *marketingcampaignPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MarketingCampaign
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MarketingCampaign {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MarketingCampaign {
			return nodes[i]
		}
	}
	c.Edges = make([]*MarketingCampaignEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MarketingCampaignEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MarketingCampaignPaginateOption enables pagination customization.
type MarketingCampaignPaginateOption func(*marketingcampaignPager) error

// WithMarketingCampaignOrder configures pagination ordering.
func WithMarketingCampaignOrder(order []*MarketingCampaignOrder) MarketingCampaignPaginateOption {
	return func(pager *marketingcampaignPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMarketingCampaignFilter configures pagination filter.
func WithMarketingCampaignFilter(filter func(*MarketingCampaignQuery) (*MarketingCampaignQuery, error)) MarketingCampaignPaginateOption {
	return func(pager *marketingcampaignPager) error {
		if filter == nil {
			return errors.New("MarketingCampaignQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type marketingcampaignPager struct {
	reverse bool
	order   []*MarketingCampaignOrder
	filter  func(*MarketingCampaignQuery) (*MarketingCampaignQuery, error)
}

func newMarketingCampaignPager(opts []MarketingCampaignPaginateOption, reverse bool) (*marketingcampaignPager, error) {
	pager := &marketingcampaignPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *marketingcampaignPager) applyFilter(query *MarketingCampaignQuery) (*MarketingCampaignQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *marketingcampaignPager) toCursor(mc *MarketingCampaign) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(mc).Value)
	}
	return Cursor{ID: mc.ID, Value: cs}
}

func (p *marketingcampaignPager) applyCursors(query *MarketingCampaignQuery, after, before *Cursor) (*MarketingCampaignQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMarketingCampaignOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *marketingcampaignPager) applyOrder(query *MarketingCampaignQuery) *MarketingCampaignQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMarketingCampaignOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMarketingCampaignOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *marketingcampaignPager) orderExpr(query *MarketingCampaignQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMarketingCampaignOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MarketingCampaign.
func (mc *MarketingCampaignQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MarketingCampaignPaginateOption,
) (*MarketingCampaignConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMarketingCampaignPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mc, err = pager.applyFilter(mc); err != nil {
		return nil, err
	}
	conn := &MarketingCampaignConnection{Edges: []*MarketingCampaignEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mc, err = pager.applyCursors(mc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mc = pager.applyOrder(mc)
	nodes, err := mc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MarketingCampaignOrderFieldName orders MarketingCampaign by name.
	MarketingCampaignOrderFieldName = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.Name, nil
		},
		column: marketingcampaign.FieldName,
		toTerm: marketingcampaign.ByName,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.Name,
			}
		},
	}
	// MarketingCampaignOrderFieldDescription orders MarketingCampaign by description.
	MarketingCampaignOrderFieldDescription = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.Description, nil
		},
		column: marketingcampaign.FieldDescription,
		toTerm: marketingcampaign.ByDescription,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.Description,
			}
		},
	}
	// MarketingCampaignOrderFieldConsumerPurchaseValue orders MarketingCampaign by consumerPurchaseValue.
	MarketingCampaignOrderFieldConsumerPurchaseValue = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.ConsumerPurchaseValue, nil
		},
		column: marketingcampaign.FieldConsumerPurchaseValue,
		toTerm: marketingcampaign.ByConsumerPurchaseValue,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.ConsumerPurchaseValue,
			}
		},
	}
	// MarketingCampaignOrderFieldCustomerApplicationLogic orders MarketingCampaign by customerApplicationLogic.
	MarketingCampaignOrderFieldCustomerApplicationLogic = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.CustomerApplicationLogic, nil
		},
		column: marketingcampaign.FieldCustomerApplicationLogic,
		toTerm: marketingcampaign.ByCustomerApplicationLogic,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.CustomerApplicationLogic,
			}
		},
	}
	// MarketingCampaignOrderFieldInitialisationLogic orders MarketingCampaign by initialisationLogic.
	MarketingCampaignOrderFieldInitialisationLogic = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.InitialisationLogic, nil
		},
		column: marketingcampaign.FieldInitialisationLogic,
		toTerm: marketingcampaign.ByInitialisationLogic,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.InitialisationLogic,
			}
		},
	}
	// MarketingCampaignOrderFieldStartDate orders MarketingCampaign by startDate.
	MarketingCampaignOrderFieldStartDate = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.StartDate, nil
		},
		column: marketingcampaign.FieldStartDate,
		toTerm: marketingcampaign.ByStartDate,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.StartDate,
			}
		},
	}
	// MarketingCampaignOrderFieldEndDate orders MarketingCampaign by endDate.
	MarketingCampaignOrderFieldEndDate = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.EndDate, nil
		},
		column: marketingcampaign.FieldEndDate,
		toTerm: marketingcampaign.ByEndDate,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.EndDate,
			}
		},
	}
	// MarketingCampaignOrderFieldDateCreated orders MarketingCampaign by dateCreated.
	MarketingCampaignOrderFieldDateCreated = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.DateCreated, nil
		},
		column: marketingcampaign.FieldDateCreated,
		toTerm: marketingcampaign.ByDateCreated,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.DateCreated,
			}
		},
	}
	// MarketingCampaignOrderFieldDateUpdated orders MarketingCampaign by dateUpdated.
	MarketingCampaignOrderFieldDateUpdated = &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.DateUpdated, nil
		},
		column: marketingcampaign.FieldDateUpdated,
		toTerm: marketingcampaign.ByDateUpdated,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MarketingCampaignOrderField) String() string {
	var str string
	switch f.column {
	case MarketingCampaignOrderFieldName.column:
		str = "NAME"
	case MarketingCampaignOrderFieldDescription.column:
		str = "DESCRIPTION"
	case MarketingCampaignOrderFieldConsumerPurchaseValue.column:
		str = "CONSUMERPURCHASEVALUE"
	case MarketingCampaignOrderFieldCustomerApplicationLogic.column:
		str = "CUSTOMERAPPLICATIONLOGIC"
	case MarketingCampaignOrderFieldInitialisationLogic.column:
		str = "INITIALISATIONLOGIC"
	case MarketingCampaignOrderFieldStartDate.column:
		str = "STARTDATE"
	case MarketingCampaignOrderFieldEndDate.column:
		str = "ENDDATE"
	case MarketingCampaignOrderFieldDateCreated.column:
		str = "DATECREATED"
	case MarketingCampaignOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MarketingCampaignOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MarketingCampaignOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MarketingCampaignOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *MarketingCampaignOrderFieldName
	case "DESCRIPTION":
		*f = *MarketingCampaignOrderFieldDescription
	case "CONSUMERPURCHASEVALUE":
		*f = *MarketingCampaignOrderFieldConsumerPurchaseValue
	case "CUSTOMERAPPLICATIONLOGIC":
		*f = *MarketingCampaignOrderFieldCustomerApplicationLogic
	case "INITIALISATIONLOGIC":
		*f = *MarketingCampaignOrderFieldInitialisationLogic
	case "STARTDATE":
		*f = *MarketingCampaignOrderFieldStartDate
	case "ENDDATE":
		*f = *MarketingCampaignOrderFieldEndDate
	case "DATECREATED":
		*f = *MarketingCampaignOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *MarketingCampaignOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid MarketingCampaignOrderField", str)
	}
	return nil
}

// MarketingCampaignOrderField defines the ordering field of MarketingCampaign.
type MarketingCampaignOrderField struct {
	// Value extracts the ordering value from the given MarketingCampaign.
	Value    func(*MarketingCampaign) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) marketingcampaign.OrderOption
	toCursor func(*MarketingCampaign) Cursor
}

// MarketingCampaignOrder defines the ordering of MarketingCampaign.
type MarketingCampaignOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *MarketingCampaignOrderField `json:"field"`
}

// DefaultMarketingCampaignOrder is the default ordering of MarketingCampaign.
var DefaultMarketingCampaignOrder = &MarketingCampaignOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MarketingCampaignOrderField{
		Value: func(mc *MarketingCampaign) (ent.Value, error) {
			return mc.ID, nil
		},
		column: marketingcampaign.FieldID,
		toTerm: marketingcampaign.ByID,
		toCursor: func(mc *MarketingCampaign) Cursor {
			return Cursor{ID: mc.ID}
		},
	},
}

// ToEdge converts MarketingCampaign into MarketingCampaignEdge.
func (mc *MarketingCampaign) ToEdge(order *MarketingCampaignOrder) *MarketingCampaignEdge {
	if order == nil {
		order = DefaultMarketingCampaignOrder
	}
	return &MarketingCampaignEdge{
		Node:   mc,
		Cursor: order.Field.toCursor(mc),
	}
}

// NotificationEdge is the edge representation of Notification.
type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// NotificationConnection is the connection containing edges to Notification.
type NotificationConnection struct {
	Edges      []*NotificationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *NotificationConnection) build(nodes []*Notification, pager *notificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Notification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Notification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Notification {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPaginateOption enables pagination customization.
type NotificationPaginateOption func(*notificationPager) error

// WithNotificationOrder configures pagination ordering.
func WithNotificationOrder(order []*NotificationOrder) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNotificationFilter configures pagination filter.
func WithNotificationFilter(filter func(*NotificationQuery) (*NotificationQuery, error)) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		if filter == nil {
			return errors.New("NotificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationPager struct {
	reverse bool
	order   []*NotificationOrder
	filter  func(*NotificationQuery) (*NotificationQuery, error)
}

func newNotificationPager(opts []NotificationPaginateOption, reverse bool) (*notificationPager, error) {
	pager := &notificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *notificationPager) applyFilter(query *NotificationQuery) (*NotificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationPager) toCursor(n *Notification) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(n).Value)
	}
	return Cursor{ID: n.ID, Value: cs}
}

func (p *notificationPager) applyCursors(query *NotificationQuery, after, before *Cursor) (*NotificationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNotificationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationPager) applyOrder(query *NotificationQuery) *NotificationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNotificationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNotificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *notificationPager) orderExpr(query *NotificationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNotificationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Notification.
func (n *NotificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPaginateOption,
) (*NotificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NotificationConnection{Edges: []*NotificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = n.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationOrderFieldTitle orders Notification by title.
	NotificationOrderFieldTitle = &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.Title, nil
		},
		column: notification.FieldTitle,
		toTerm: notification.ByTitle,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.Title,
			}
		},
	}
	// NotificationOrderFieldContent orders Notification by content.
	NotificationOrderFieldContent = &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.Content, nil
		},
		column: notification.FieldContent,
		toTerm: notification.ByContent,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.Content,
			}
		},
	}
	// NotificationOrderFieldDateCreated orders Notification by dateCreated.
	NotificationOrderFieldDateCreated = &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.DateCreated, nil
		},
		column: notification.FieldDateCreated,
		toTerm: notification.ByDateCreated,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.DateCreated,
			}
		},
	}
	// NotificationOrderFieldDateUpdated orders Notification by dateUpdated.
	NotificationOrderFieldDateUpdated = &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.DateUpdated, nil
		},
		column: notification.FieldDateUpdated,
		toTerm: notification.ByDateUpdated,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.DateUpdated,
			}
		},
	}
	// NotificationOrderFieldRead orders Notification by read.
	NotificationOrderFieldRead = &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.Read, nil
		},
		column: notification.FieldRead,
		toTerm: notification.ByRead,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.Read,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationOrderField) String() string {
	var str string
	switch f.column {
	case NotificationOrderFieldTitle.column:
		str = "TITLE"
	case NotificationOrderFieldContent.column:
		str = "CONTENT"
	case NotificationOrderFieldDateCreated.column:
		str = "DATECREATED"
	case NotificationOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	case NotificationOrderFieldRead.column:
		str = "READ"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *NotificationOrderFieldTitle
	case "CONTENT":
		*f = *NotificationOrderFieldContent
	case "DATECREATED":
		*f = *NotificationOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *NotificationOrderFieldDateUpdated
	case "READ":
		*f = *NotificationOrderFieldRead
	default:
		return fmt.Errorf("%s is not a valid NotificationOrderField", str)
	}
	return nil
}

// NotificationOrderField defines the ordering field of Notification.
type NotificationOrderField struct {
	// Value extracts the ordering value from the given Notification.
	Value    func(*Notification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notification.OrderOption
	toCursor func(*Notification) Cursor
}

// NotificationOrder defines the ordering of Notification.
type NotificationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *NotificationOrderField `json:"field"`
}

// DefaultNotificationOrder is the default ordering of Notification.
var DefaultNotificationOrder = &NotificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.ID, nil
		},
		column: notification.FieldID,
		toTerm: notification.ByID,
		toCursor: func(n *Notification) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Notification into NotificationEdge.
func (n *Notification) ToEdge(order *NotificationOrder) *NotificationEdge {
	if order == nil {
		order = DefaultNotificationOrder
	}
	return &NotificationEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// PaymentMethodEdge is the edge representation of PaymentMethod.
type PaymentMethodEdge struct {
	Node   *PaymentMethod `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// PaymentMethodConnection is the connection containing edges to PaymentMethod.
type PaymentMethodConnection struct {
	Edges      []*PaymentMethodEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *PaymentMethodConnection) build(nodes []*PaymentMethod, pager *paymentmethodPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PaymentMethod
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PaymentMethod {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PaymentMethod {
			return nodes[i]
		}
	}
	c.Edges = make([]*PaymentMethodEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PaymentMethodEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PaymentMethodPaginateOption enables pagination customization.
type PaymentMethodPaginateOption func(*paymentmethodPager) error

// WithPaymentMethodOrder configures pagination ordering.
func WithPaymentMethodOrder(order []*PaymentMethodOrder) PaymentMethodPaginateOption {
	return func(pager *paymentmethodPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPaymentMethodFilter configures pagination filter.
func WithPaymentMethodFilter(filter func(*PaymentMethodQuery) (*PaymentMethodQuery, error)) PaymentMethodPaginateOption {
	return func(pager *paymentmethodPager) error {
		if filter == nil {
			return errors.New("PaymentMethodQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type paymentmethodPager struct {
	reverse bool
	order   []*PaymentMethodOrder
	filter  func(*PaymentMethodQuery) (*PaymentMethodQuery, error)
}

func newPaymentMethodPager(opts []PaymentMethodPaginateOption, reverse bool) (*paymentmethodPager, error) {
	pager := &paymentmethodPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *paymentmethodPager) applyFilter(query *PaymentMethodQuery) (*PaymentMethodQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *paymentmethodPager) toCursor(pm *PaymentMethod) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pm).Value)
	}
	return Cursor{ID: pm.ID, Value: cs}
}

func (p *paymentmethodPager) applyCursors(query *PaymentMethodQuery, after, before *Cursor) (*PaymentMethodQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPaymentMethodOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *paymentmethodPager) applyOrder(query *PaymentMethodQuery) *PaymentMethodQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPaymentMethodOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPaymentMethodOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *paymentmethodPager) orderExpr(query *PaymentMethodQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPaymentMethodOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PaymentMethod.
func (pm *PaymentMethodQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PaymentMethodPaginateOption,
) (*PaymentMethodConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPaymentMethodPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pm, err = pager.applyFilter(pm); err != nil {
		return nil, err
	}
	conn := &PaymentMethodConnection{Edges: []*PaymentMethodEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pm, err = pager.applyCursors(pm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pm = pager.applyOrder(pm)
	nodes, err := pm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PaymentMethodOrderFieldXid orders PaymentMethod by xid.
	PaymentMethodOrderFieldXid = &PaymentMethodOrderField{
		Value: func(pm *PaymentMethod) (ent.Value, error) {
			return pm.Xid, nil
		},
		column: paymentmethod.FieldXid,
		toTerm: paymentmethod.ByXid,
		toCursor: func(pm *PaymentMethod) Cursor {
			return Cursor{
				ID:    pm.ID,
				Value: pm.Xid,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PaymentMethodOrderField) String() string {
	var str string
	switch f.column {
	case PaymentMethodOrderFieldXid.column:
		str = "XID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PaymentMethodOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PaymentMethodOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PaymentMethodOrderField %T must be a string", v)
	}
	switch str {
	case "XID":
		*f = *PaymentMethodOrderFieldXid
	default:
		return fmt.Errorf("%s is not a valid PaymentMethodOrderField", str)
	}
	return nil
}

// PaymentMethodOrderField defines the ordering field of PaymentMethod.
type PaymentMethodOrderField struct {
	// Value extracts the ordering value from the given PaymentMethod.
	Value    func(*PaymentMethod) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) paymentmethod.OrderOption
	toCursor func(*PaymentMethod) Cursor
}

// PaymentMethodOrder defines the ordering of PaymentMethod.
type PaymentMethodOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *PaymentMethodOrderField `json:"field"`
}

// DefaultPaymentMethodOrder is the default ordering of PaymentMethod.
var DefaultPaymentMethodOrder = &PaymentMethodOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PaymentMethodOrderField{
		Value: func(pm *PaymentMethod) (ent.Value, error) {
			return pm.ID, nil
		},
		column: paymentmethod.FieldID,
		toTerm: paymentmethod.ByID,
		toCursor: func(pm *PaymentMethod) Cursor {
			return Cursor{ID: pm.ID}
		},
	},
}

// ToEdge converts PaymentMethod into PaymentMethodEdge.
func (pm *PaymentMethod) ToEdge(order *PaymentMethodOrder) *PaymentMethodEdge {
	if order == nil {
		order = DefaultPaymentMethodOrder
	}
	return &PaymentMethodEdge{
		Node:   pm,
		Cursor: order.Field.toCursor(pm),
	}
}

// PrimaryContentEdge is the edge representation of PrimaryContent.
type PrimaryContentEdge struct {
	Node   *PrimaryContent `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// PrimaryContentConnection is the connection containing edges to PrimaryContent.
type PrimaryContentConnection struct {
	Edges      []*PrimaryContentEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *PrimaryContentConnection) build(nodes []*PrimaryContent, pager *primarycontentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PrimaryContent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PrimaryContent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PrimaryContent {
			return nodes[i]
		}
	}
	c.Edges = make([]*PrimaryContentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PrimaryContentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PrimaryContentPaginateOption enables pagination customization.
type PrimaryContentPaginateOption func(*primarycontentPager) error

// WithPrimaryContentOrder configures pagination ordering.
func WithPrimaryContentOrder(order []*PrimaryContentOrder) PrimaryContentPaginateOption {
	return func(pager *primarycontentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPrimaryContentFilter configures pagination filter.
func WithPrimaryContentFilter(filter func(*PrimaryContentQuery) (*PrimaryContentQuery, error)) PrimaryContentPaginateOption {
	return func(pager *primarycontentPager) error {
		if filter == nil {
			return errors.New("PrimaryContentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type primarycontentPager struct {
	reverse bool
	order   []*PrimaryContentOrder
	filter  func(*PrimaryContentQuery) (*PrimaryContentQuery, error)
}

func newPrimaryContentPager(opts []PrimaryContentPaginateOption, reverse bool) (*primarycontentPager, error) {
	pager := &primarycontentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *primarycontentPager) applyFilter(query *PrimaryContentQuery) (*PrimaryContentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *primarycontentPager) toCursor(pc *PrimaryContent) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pc).Value)
	}
	return Cursor{ID: pc.ID, Value: cs}
}

func (p *primarycontentPager) applyCursors(query *PrimaryContentQuery, after, before *Cursor) (*PrimaryContentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPrimaryContentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *primarycontentPager) applyOrder(query *PrimaryContentQuery) *PrimaryContentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPrimaryContentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPrimaryContentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *primarycontentPager) orderExpr(query *PrimaryContentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPrimaryContentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PrimaryContent.
func (pc *PrimaryContentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PrimaryContentPaginateOption,
) (*PrimaryContentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPrimaryContentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}
	conn := &PrimaryContentConnection{Edges: []*PrimaryContentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pc, err = pager.applyCursors(pc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pc = pager.applyOrder(pc)
	nodes, err := pc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PrimaryContentOrderFieldPlaceholder orders PrimaryContent by placeholder.
	PrimaryContentOrderFieldPlaceholder = &PrimaryContentOrderField{
		Value: func(pc *PrimaryContent) (ent.Value, error) {
			return pc.Placeholder, nil
		},
		column: primarycontent.FieldPlaceholder,
		toTerm: primarycontent.ByPlaceholder,
		toCursor: func(pc *PrimaryContent) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.Placeholder,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PrimaryContentOrderField) String() string {
	var str string
	switch f.column {
	case PrimaryContentOrderFieldPlaceholder.column:
		str = "PLACEHOLDER"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PrimaryContentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PrimaryContentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PrimaryContentOrderField %T must be a string", v)
	}
	switch str {
	case "PLACEHOLDER":
		*f = *PrimaryContentOrderFieldPlaceholder
	default:
		return fmt.Errorf("%s is not a valid PrimaryContentOrderField", str)
	}
	return nil
}

// PrimaryContentOrderField defines the ordering field of PrimaryContent.
type PrimaryContentOrderField struct {
	// Value extracts the ordering value from the given PrimaryContent.
	Value    func(*PrimaryContent) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) primarycontent.OrderOption
	toCursor func(*PrimaryContent) Cursor
}

// PrimaryContentOrder defines the ordering of PrimaryContent.
type PrimaryContentOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *PrimaryContentOrderField `json:"field"`
}

// DefaultPrimaryContentOrder is the default ordering of PrimaryContent.
var DefaultPrimaryContentOrder = &PrimaryContentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PrimaryContentOrderField{
		Value: func(pc *PrimaryContent) (ent.Value, error) {
			return pc.ID, nil
		},
		column: primarycontent.FieldID,
		toTerm: primarycontent.ByID,
		toCursor: func(pc *PrimaryContent) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// ToEdge converts PrimaryContent into PrimaryContentEdge.
func (pc *PrimaryContent) ToEdge(order *PrimaryContentOrder) *PrimaryContentEdge {
	if order == nil {
		order = DefaultPrimaryContentOrder
	}
	return &PrimaryContentEdge{
		Node:   pc,
		Cursor: order.Field.toCursor(pc),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order []*ProductOrder) ProductPaginateOption {
	return func(pager *productPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   []*ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProductOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProductOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldName orders Product by name.
	ProductOrderFieldName = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Name, nil
		},
		column: product.FieldName,
		toTerm: product.ByName,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProductOrderFieldDescription orders Product by description.
	ProductOrderFieldDescription = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Description, nil
		},
		column: product.FieldDescription,
		toTerm: product.ByDescription,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Description,
			}
		},
	}
	// ProductOrderFieldPrice orders Product by price.
	ProductOrderFieldPrice = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Price, nil
		},
		column: product.FieldPrice,
		toTerm: product.ByPrice,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Price,
			}
		},
	}
	// ProductOrderFieldDateCreated orders Product by dateCreated.
	ProductOrderFieldDateCreated = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.DateCreated, nil
		},
		column: product.FieldDateCreated,
		toTerm: product.ByDateCreated,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.DateCreated,
			}
		},
	}
	// ProductOrderFieldDateUpdated orders Product by dateUpdated.
	ProductOrderFieldDateUpdated = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.DateUpdated, nil
		},
		column: product.FieldDateUpdated,
		toTerm: product.ByDateUpdated,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.column {
	case ProductOrderFieldName.column:
		str = "NAME"
	case ProductOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ProductOrderFieldPrice.column:
		str = "PRICE"
	case ProductOrderFieldDateCreated.column:
		str = "DATECREATED"
	case ProductOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ProductOrderFieldName
	case "DESCRIPTION":
		*f = *ProductOrderFieldDescription
	case "PRICE":
		*f = *ProductOrderFieldPrice
	case "DATECREATED":
		*f = *ProductOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *ProductOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductAttributeEdge is the edge representation of ProductAttribute.
type ProductAttributeEdge struct {
	Node   *ProductAttribute `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProductAttributeConnection is the connection containing edges to ProductAttribute.
type ProductAttributeConnection struct {
	Edges      []*ProductAttributeEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProductAttributeConnection) build(nodes []*ProductAttribute, pager *productattributePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductAttribute
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductAttribute {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductAttribute {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductAttributeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductAttributeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductAttributePaginateOption enables pagination customization.
type ProductAttributePaginateOption func(*productattributePager) error

// WithProductAttributeOrder configures pagination ordering.
func WithProductAttributeOrder(order []*ProductAttributeOrder) ProductAttributePaginateOption {
	return func(pager *productattributePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProductAttributeFilter configures pagination filter.
func WithProductAttributeFilter(filter func(*ProductAttributeQuery) (*ProductAttributeQuery, error)) ProductAttributePaginateOption {
	return func(pager *productattributePager) error {
		if filter == nil {
			return errors.New("ProductAttributeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productattributePager struct {
	reverse bool
	order   []*ProductAttributeOrder
	filter  func(*ProductAttributeQuery) (*ProductAttributeQuery, error)
}

func newProductAttributePager(opts []ProductAttributePaginateOption, reverse bool) (*productattributePager, error) {
	pager := &productattributePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *productattributePager) applyFilter(query *ProductAttributeQuery) (*ProductAttributeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productattributePager) toCursor(pa *ProductAttribute) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pa).Value)
	}
	return Cursor{ID: pa.ID, Value: cs}
}

func (p *productattributePager) applyCursors(query *ProductAttributeQuery, after, before *Cursor) (*ProductAttributeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProductAttributeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productattributePager) applyOrder(query *ProductAttributeQuery) *ProductAttributeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProductAttributeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProductAttributeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *productattributePager) orderExpr(query *ProductAttributeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProductAttributeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductAttribute.
func (pa *ProductAttributeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductAttributePaginateOption,
) (*ProductAttributeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductAttributePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &ProductAttributeConnection{Edges: []*ProductAttributeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductAttributeOrderFieldName orders ProductAttribute by name.
	ProductAttributeOrderFieldName = &ProductAttributeOrderField{
		Value: func(pa *ProductAttribute) (ent.Value, error) {
			return pa.Name, nil
		},
		column: productattribute.FieldName,
		toTerm: productattribute.ByName,
		toCursor: func(pa *ProductAttribute) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.Name,
			}
		},
	}
	// ProductAttributeOrderFieldDescription orders ProductAttribute by description.
	ProductAttributeOrderFieldDescription = &ProductAttributeOrderField{
		Value: func(pa *ProductAttribute) (ent.Value, error) {
			return pa.Description, nil
		},
		column: productattribute.FieldDescription,
		toTerm: productattribute.ByDescription,
		toCursor: func(pa *ProductAttribute) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.Description,
			}
		},
	}
	// ProductAttributeOrderFieldValue orders ProductAttribute by value.
	ProductAttributeOrderFieldValue = &ProductAttributeOrderField{
		Value: func(pa *ProductAttribute) (ent.Value, error) {
			return pa.Value, nil
		},
		column: productattribute.FieldValue,
		toTerm: productattribute.ByValue,
		toCursor: func(pa *ProductAttribute) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductAttributeOrderField) String() string {
	var str string
	switch f.column {
	case ProductAttributeOrderFieldName.column:
		str = "NAME"
	case ProductAttributeOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ProductAttributeOrderFieldValue.column:
		str = "VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductAttributeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductAttributeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductAttributeOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ProductAttributeOrderFieldName
	case "DESCRIPTION":
		*f = *ProductAttributeOrderFieldDescription
	case "VALUE":
		*f = *ProductAttributeOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid ProductAttributeOrderField", str)
	}
	return nil
}

// ProductAttributeOrderField defines the ordering field of ProductAttribute.
type ProductAttributeOrderField struct {
	// Value extracts the ordering value from the given ProductAttribute.
	Value    func(*ProductAttribute) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productattribute.OrderOption
	toCursor func(*ProductAttribute) Cursor
}

// ProductAttributeOrder defines the ordering of ProductAttribute.
type ProductAttributeOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProductAttributeOrderField `json:"field"`
}

// DefaultProductAttributeOrder is the default ordering of ProductAttribute.
var DefaultProductAttributeOrder = &ProductAttributeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductAttributeOrderField{
		Value: func(pa *ProductAttribute) (ent.Value, error) {
			return pa.ID, nil
		},
		column: productattribute.FieldID,
		toTerm: productattribute.ByID,
		toCursor: func(pa *ProductAttribute) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts ProductAttribute into ProductAttributeEdge.
func (pa *ProductAttribute) ToEdge(order *ProductAttributeOrder) *ProductAttributeEdge {
	if order == nil {
		order = DefaultProductAttributeOrder
	}
	return &ProductAttributeEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ProductPageViewEdge is the edge representation of ProductPageView.
type ProductPageViewEdge struct {
	Node   *ProductPageView `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ProductPageViewConnection is the connection containing edges to ProductPageView.
type ProductPageViewConnection struct {
	Edges      []*ProductPageViewEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ProductPageViewConnection) build(nodes []*ProductPageView, pager *productpageviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductPageView
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductPageView {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductPageView {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductPageViewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductPageViewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPageViewPaginateOption enables pagination customization.
type ProductPageViewPaginateOption func(*productpageviewPager) error

// WithProductPageViewOrder configures pagination ordering.
func WithProductPageViewOrder(order []*ProductPageViewOrder) ProductPageViewPaginateOption {
	return func(pager *productpageviewPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProductPageViewFilter configures pagination filter.
func WithProductPageViewFilter(filter func(*ProductPageViewQuery) (*ProductPageViewQuery, error)) ProductPageViewPaginateOption {
	return func(pager *productpageviewPager) error {
		if filter == nil {
			return errors.New("ProductPageViewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productpageviewPager struct {
	reverse bool
	order   []*ProductPageViewOrder
	filter  func(*ProductPageViewQuery) (*ProductPageViewQuery, error)
}

func newProductPageViewPager(opts []ProductPageViewPaginateOption, reverse bool) (*productpageviewPager, error) {
	pager := &productpageviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *productpageviewPager) applyFilter(query *ProductPageViewQuery) (*ProductPageViewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productpageviewPager) toCursor(ppv *ProductPageView) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ppv).Value)
	}
	return Cursor{ID: ppv.ID, Value: cs}
}

func (p *productpageviewPager) applyCursors(query *ProductPageViewQuery, after, before *Cursor) (*ProductPageViewQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProductPageViewOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productpageviewPager) applyOrder(query *ProductPageViewQuery) *ProductPageViewQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProductPageViewOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProductPageViewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *productpageviewPager) orderExpr(query *ProductPageViewQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProductPageViewOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductPageView.
func (ppv *ProductPageViewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPageViewPaginateOption,
) (*ProductPageViewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPageViewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ppv, err = pager.applyFilter(ppv); err != nil {
		return nil, err
	}
	conn := &ProductPageViewConnection{Edges: []*ProductPageViewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ppv.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ppv, err = pager.applyCursors(ppv, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ppv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ppv.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ppv = pager.applyOrder(ppv)
	nodes, err := ppv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductPageViewOrderFieldVersion orders ProductPageView by version.
	ProductPageViewOrderFieldVersion = &ProductPageViewOrderField{
		Value: func(ppv *ProductPageView) (ent.Value, error) {
			return ppv.Version, nil
		},
		column: productpageview.FieldVersion,
		toTerm: productpageview.ByVersion,
		toCursor: func(ppv *ProductPageView) Cursor {
			return Cursor{
				ID:    ppv.ID,
				Value: ppv.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductPageViewOrderField) String() string {
	var str string
	switch f.column {
	case ProductPageViewOrderFieldVersion.column:
		str = "VERSION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductPageViewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductPageViewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductPageViewOrderField %T must be a string", v)
	}
	switch str {
	case "VERSION":
		*f = *ProductPageViewOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid ProductPageViewOrderField", str)
	}
	return nil
}

// ProductPageViewOrderField defines the ordering field of ProductPageView.
type ProductPageViewOrderField struct {
	// Value extracts the ordering value from the given ProductPageView.
	Value    func(*ProductPageView) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productpageview.OrderOption
	toCursor func(*ProductPageView) Cursor
}

// ProductPageViewOrder defines the ordering of ProductPageView.
type ProductPageViewOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ProductPageViewOrderField `json:"field"`
}

// DefaultProductPageViewOrder is the default ordering of ProductPageView.
var DefaultProductPageViewOrder = &ProductPageViewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductPageViewOrderField{
		Value: func(ppv *ProductPageView) (ent.Value, error) {
			return ppv.ID, nil
		},
		column: productpageview.FieldID,
		toTerm: productpageview.ByID,
		toCursor: func(ppv *ProductPageView) Cursor {
			return Cursor{ID: ppv.ID}
		},
	},
}

// ToEdge converts ProductPageView into ProductPageViewEdge.
func (ppv *ProductPageView) ToEdge(order *ProductPageViewOrder) *ProductPageViewEdge {
	if order == nil {
		order = DefaultProductPageViewOrder
	}
	return &ProductPageViewEdge{
		Node:   ppv,
		Cursor: order.Field.toCursor(ppv),
	}
}

// ProductVariationEdge is the edge representation of ProductVariation.
type ProductVariationEdge struct {
	Node   *ProductVariation `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProductVariationConnection is the connection containing edges to ProductVariation.
type ProductVariationConnection struct {
	Edges      []*ProductVariationEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProductVariationConnection) build(nodes []*ProductVariation, pager *productvariationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductVariation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductVariation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductVariation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductVariationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductVariationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductVariationPaginateOption enables pagination customization.
type ProductVariationPaginateOption func(*productvariationPager) error

// WithProductVariationOrder configures pagination ordering.
func WithProductVariationOrder(order []*ProductVariationOrder) ProductVariationPaginateOption {
	return func(pager *productvariationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProductVariationFilter configures pagination filter.
func WithProductVariationFilter(filter func(*ProductVariationQuery) (*ProductVariationQuery, error)) ProductVariationPaginateOption {
	return func(pager *productvariationPager) error {
		if filter == nil {
			return errors.New("ProductVariationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productvariationPager struct {
	reverse bool
	order   []*ProductVariationOrder
	filter  func(*ProductVariationQuery) (*ProductVariationQuery, error)
}

func newProductVariationPager(opts []ProductVariationPaginateOption, reverse bool) (*productvariationPager, error) {
	pager := &productvariationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *productvariationPager) applyFilter(query *ProductVariationQuery) (*ProductVariationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productvariationPager) toCursor(pv *ProductVariation) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pv).Value)
	}
	return Cursor{ID: pv.ID, Value: cs}
}

func (p *productvariationPager) applyCursors(query *ProductVariationQuery, after, before *Cursor) (*ProductVariationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProductVariationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productvariationPager) applyOrder(query *ProductVariationQuery) *ProductVariationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProductVariationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProductVariationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *productvariationPager) orderExpr(query *ProductVariationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProductVariationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductVariation.
func (pv *ProductVariationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductVariationPaginateOption,
) (*ProductVariationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductVariationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pv, err = pager.applyFilter(pv); err != nil {
		return nil, err
	}
	conn := &ProductVariationConnection{Edges: []*ProductVariationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pv.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pv, err = pager.applyCursors(pv, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pv.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pv = pager.applyOrder(pv)
	nodes, err := pv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductVariationOrderFieldName orders ProductVariation by name.
	ProductVariationOrderFieldName = &ProductVariationOrderField{
		Value: func(pv *ProductVariation) (ent.Value, error) {
			return pv.Name, nil
		},
		column: productvariation.FieldName,
		toTerm: productvariation.ByName,
		toCursor: func(pv *ProductVariation) Cursor {
			return Cursor{
				ID:    pv.ID,
				Value: pv.Name,
			}
		},
	}
	// ProductVariationOrderFieldDescription orders ProductVariation by description.
	ProductVariationOrderFieldDescription = &ProductVariationOrderField{
		Value: func(pv *ProductVariation) (ent.Value, error) {
			return pv.Description, nil
		},
		column: productvariation.FieldDescription,
		toTerm: productvariation.ByDescription,
		toCursor: func(pv *ProductVariation) Cursor {
			return Cursor{
				ID:    pv.ID,
				Value: pv.Description,
			}
		},
	}
	// ProductVariationOrderFieldPrice orders ProductVariation by price.
	ProductVariationOrderFieldPrice = &ProductVariationOrderField{
		Value: func(pv *ProductVariation) (ent.Value, error) {
			return pv.Price, nil
		},
		column: productvariation.FieldPrice,
		toTerm: productvariation.ByPrice,
		toCursor: func(pv *ProductVariation) Cursor {
			return Cursor{
				ID:    pv.ID,
				Value: pv.Price,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductVariationOrderField) String() string {
	var str string
	switch f.column {
	case ProductVariationOrderFieldName.column:
		str = "NAME"
	case ProductVariationOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ProductVariationOrderFieldPrice.column:
		str = "PRICE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductVariationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductVariationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductVariationOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ProductVariationOrderFieldName
	case "DESCRIPTION":
		*f = *ProductVariationOrderFieldDescription
	case "PRICE":
		*f = *ProductVariationOrderFieldPrice
	default:
		return fmt.Errorf("%s is not a valid ProductVariationOrderField", str)
	}
	return nil
}

// ProductVariationOrderField defines the ordering field of ProductVariation.
type ProductVariationOrderField struct {
	// Value extracts the ordering value from the given ProductVariation.
	Value    func(*ProductVariation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productvariation.OrderOption
	toCursor func(*ProductVariation) Cursor
}

// ProductVariationOrder defines the ordering of ProductVariation.
type ProductVariationOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProductVariationOrderField `json:"field"`
}

// DefaultProductVariationOrder is the default ordering of ProductVariation.
var DefaultProductVariationOrder = &ProductVariationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductVariationOrderField{
		Value: func(pv *ProductVariation) (ent.Value, error) {
			return pv.ID, nil
		},
		column: productvariation.FieldID,
		toTerm: productvariation.ByID,
		toCursor: func(pv *ProductVariation) Cursor {
			return Cursor{ID: pv.ID}
		},
	},
}

// ToEdge converts ProductVariation into ProductVariationEdge.
func (pv *ProductVariation) ToEdge(order *ProductVariationOrder) *ProductVariationEdge {
	if order == nil {
		order = DefaultProductVariationOrder
	}
	return &ProductVariationEdge{
		Node:   pv,
		Cursor: order.Field.toCursor(pv),
	}
}

// ReferralLinkEdge is the edge representation of ReferralLink.
type ReferralLinkEdge struct {
	Node   *ReferralLink `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ReferralLinkConnection is the connection containing edges to ReferralLink.
type ReferralLinkConnection struct {
	Edges      []*ReferralLinkEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ReferralLinkConnection) build(nodes []*ReferralLink, pager *referrallinkPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReferralLink
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReferralLink {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReferralLink {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReferralLinkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReferralLinkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReferralLinkPaginateOption enables pagination customization.
type ReferralLinkPaginateOption func(*referrallinkPager) error

// WithReferralLinkOrder configures pagination ordering.
func WithReferralLinkOrder(order []*ReferralLinkOrder) ReferralLinkPaginateOption {
	return func(pager *referrallinkPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReferralLinkFilter configures pagination filter.
func WithReferralLinkFilter(filter func(*ReferralLinkQuery) (*ReferralLinkQuery, error)) ReferralLinkPaginateOption {
	return func(pager *referrallinkPager) error {
		if filter == nil {
			return errors.New("ReferralLinkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type referrallinkPager struct {
	reverse bool
	order   []*ReferralLinkOrder
	filter  func(*ReferralLinkQuery) (*ReferralLinkQuery, error)
}

func newReferralLinkPager(opts []ReferralLinkPaginateOption, reverse bool) (*referrallinkPager, error) {
	pager := &referrallinkPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *referrallinkPager) applyFilter(query *ReferralLinkQuery) (*ReferralLinkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *referrallinkPager) toCursor(rl *ReferralLink) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(rl).Value)
	}
	return Cursor{ID: rl.ID, Value: cs}
}

func (p *referrallinkPager) applyCursors(query *ReferralLinkQuery, after, before *Cursor) (*ReferralLinkQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReferralLinkOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *referrallinkPager) applyOrder(query *ReferralLinkQuery) *ReferralLinkQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReferralLinkOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReferralLinkOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *referrallinkPager) orderExpr(query *ReferralLinkQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReferralLinkOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReferralLink.
func (rl *ReferralLinkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReferralLinkPaginateOption,
) (*ReferralLinkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReferralLinkPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rl, err = pager.applyFilter(rl); err != nil {
		return nil, err
	}
	conn := &ReferralLinkConnection{Edges: []*ReferralLinkEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rl.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rl, err = pager.applyCursors(rl, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		rl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rl.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rl = pager.applyOrder(rl)
	nodes, err := rl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReferralLinkOrderFieldXid orders ReferralLink by xid.
	ReferralLinkOrderFieldXid = &ReferralLinkOrderField{
		Value: func(rl *ReferralLink) (ent.Value, error) {
			return rl.Xid, nil
		},
		column: referrallink.FieldXid,
		toTerm: referrallink.ByXid,
		toCursor: func(rl *ReferralLink) Cursor {
			return Cursor{
				ID:    rl.ID,
				Value: rl.Xid,
			}
		},
	}
	// ReferralLinkOrderFieldName orders ReferralLink by name.
	ReferralLinkOrderFieldName = &ReferralLinkOrderField{
		Value: func(rl *ReferralLink) (ent.Value, error) {
			return rl.Name, nil
		},
		column: referrallink.FieldName,
		toTerm: referrallink.ByName,
		toCursor: func(rl *ReferralLink) Cursor {
			return Cursor{
				ID:    rl.ID,
				Value: rl.Name,
			}
		},
	}
	// ReferralLinkOrderFieldDescription orders ReferralLink by description.
	ReferralLinkOrderFieldDescription = &ReferralLinkOrderField{
		Value: func(rl *ReferralLink) (ent.Value, error) {
			return rl.Description, nil
		},
		column: referrallink.FieldDescription,
		toTerm: referrallink.ByDescription,
		toCursor: func(rl *ReferralLink) Cursor {
			return Cursor{
				ID:    rl.ID,
				Value: rl.Description,
			}
		},
	}
	// ReferralLinkOrderFieldLink orders ReferralLink by link.
	ReferralLinkOrderFieldLink = &ReferralLinkOrderField{
		Value: func(rl *ReferralLink) (ent.Value, error) {
			return rl.Link, nil
		},
		column: referrallink.FieldLink,
		toTerm: referrallink.ByLink,
		toCursor: func(rl *ReferralLink) Cursor {
			return Cursor{
				ID:    rl.ID,
				Value: rl.Link,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReferralLinkOrderField) String() string {
	var str string
	switch f.column {
	case ReferralLinkOrderFieldXid.column:
		str = "XID"
	case ReferralLinkOrderFieldName.column:
		str = "NAME"
	case ReferralLinkOrderFieldDescription.column:
		str = "DESCRIPTION"
	case ReferralLinkOrderFieldLink.column:
		str = "LINK"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReferralLinkOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReferralLinkOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReferralLinkOrderField %T must be a string", v)
	}
	switch str {
	case "XID":
		*f = *ReferralLinkOrderFieldXid
	case "NAME":
		*f = *ReferralLinkOrderFieldName
	case "DESCRIPTION":
		*f = *ReferralLinkOrderFieldDescription
	case "LINK":
		*f = *ReferralLinkOrderFieldLink
	default:
		return fmt.Errorf("%s is not a valid ReferralLinkOrderField", str)
	}
	return nil
}

// ReferralLinkOrderField defines the ordering field of ReferralLink.
type ReferralLinkOrderField struct {
	// Value extracts the ordering value from the given ReferralLink.
	Value    func(*ReferralLink) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) referrallink.OrderOption
	toCursor func(*ReferralLink) Cursor
}

// ReferralLinkOrder defines the ordering of ReferralLink.
type ReferralLinkOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ReferralLinkOrderField `json:"field"`
}

// DefaultReferralLinkOrder is the default ordering of ReferralLink.
var DefaultReferralLinkOrder = &ReferralLinkOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReferralLinkOrderField{
		Value: func(rl *ReferralLink) (ent.Value, error) {
			return rl.ID, nil
		},
		column: referrallink.FieldID,
		toTerm: referrallink.ByID,
		toCursor: func(rl *ReferralLink) Cursor {
			return Cursor{ID: rl.ID}
		},
	},
}

// ToEdge converts ReferralLink into ReferralLinkEdge.
func (rl *ReferralLink) ToEdge(order *ReferralLinkOrder) *ReferralLinkEdge {
	if order == nil {
		order = DefaultReferralLinkOrder
	}
	return &ReferralLinkEdge{
		Node:   rl,
		Cursor: order.Field.toCursor(rl),
	}
}

// RefundTransactionsEdge is the edge representation of RefundTransactions.
type RefundTransactionsEdge struct {
	Node   *RefundTransactions `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// RefundTransactionsConnection is the connection containing edges to RefundTransactions.
type RefundTransactionsConnection struct {
	Edges      []*RefundTransactionsEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *RefundTransactionsConnection) build(nodes []*RefundTransactions, pager *refundtransactionsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RefundTransactions
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RefundTransactions {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RefundTransactions {
			return nodes[i]
		}
	}
	c.Edges = make([]*RefundTransactionsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RefundTransactionsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RefundTransactionsPaginateOption enables pagination customization.
type RefundTransactionsPaginateOption func(*refundtransactionsPager) error

// WithRefundTransactionsOrder configures pagination ordering.
func WithRefundTransactionsOrder(order []*RefundTransactionsOrder) RefundTransactionsPaginateOption {
	return func(pager *refundtransactionsPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRefundTransactionsFilter configures pagination filter.
func WithRefundTransactionsFilter(filter func(*RefundTransactionsQuery) (*RefundTransactionsQuery, error)) RefundTransactionsPaginateOption {
	return func(pager *refundtransactionsPager) error {
		if filter == nil {
			return errors.New("RefundTransactionsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type refundtransactionsPager struct {
	reverse bool
	order   []*RefundTransactionsOrder
	filter  func(*RefundTransactionsQuery) (*RefundTransactionsQuery, error)
}

func newRefundTransactionsPager(opts []RefundTransactionsPaginateOption, reverse bool) (*refundtransactionsPager, error) {
	pager := &refundtransactionsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *refundtransactionsPager) applyFilter(query *RefundTransactionsQuery) (*RefundTransactionsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *refundtransactionsPager) toCursor(rt *RefundTransactions) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(rt).Value)
	}
	return Cursor{ID: rt.ID, Value: cs}
}

func (p *refundtransactionsPager) applyCursors(query *RefundTransactionsQuery, after, before *Cursor) (*RefundTransactionsQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRefundTransactionsOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *refundtransactionsPager) applyOrder(query *RefundTransactionsQuery) *RefundTransactionsQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRefundTransactionsOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRefundTransactionsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *refundtransactionsPager) orderExpr(query *RefundTransactionsQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRefundTransactionsOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to RefundTransactions.
func (rt *RefundTransactionsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RefundTransactionsPaginateOption,
) (*RefundTransactionsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRefundTransactionsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rt, err = pager.applyFilter(rt); err != nil {
		return nil, err
	}
	conn := &RefundTransactionsConnection{Edges: []*RefundTransactionsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rt, err = pager.applyCursors(rt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		rt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rt = pager.applyOrder(rt)
	nodes, err := rt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RefundTransactionsOrderFieldRefundAmount orders RefundTransactions by refundAmount.
	RefundTransactionsOrderFieldRefundAmount = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.RefundAmount, nil
		},
		column: refundtransactions.FieldRefundAmount,
		toTerm: refundtransactions.ByRefundAmount,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.RefundAmount,
			}
		},
	}
	// RefundTransactionsOrderFieldRefundCurrency orders RefundTransactions by refundCurrency.
	RefundTransactionsOrderFieldRefundCurrency = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.RefundCurrency, nil
		},
		column: refundtransactions.FieldRefundCurrency,
		toTerm: refundtransactions.ByRefundCurrency,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.RefundCurrency,
			}
		},
	}
	// RefundTransactionsOrderFieldRefundReason orders RefundTransactions by refundReason.
	RefundTransactionsOrderFieldRefundReason = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.RefundReason, nil
		},
		column: refundtransactions.FieldRefundReason,
		toTerm: refundtransactions.ByRefundReason,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.RefundReason,
			}
		},
	}
	// RefundTransactionsOrderFieldRefundStatus orders RefundTransactions by refundStatus.
	RefundTransactionsOrderFieldRefundStatus = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.RefundStatus, nil
		},
		column: refundtransactions.FieldRefundStatus,
		toTerm: refundtransactions.ByRefundStatus,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.RefundStatus,
			}
		},
	}
	// RefundTransactionsOrderFieldDateCreated orders RefundTransactions by dateCreated.
	RefundTransactionsOrderFieldDateCreated = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.DateCreated, nil
		},
		column: refundtransactions.FieldDateCreated,
		toTerm: refundtransactions.ByDateCreated,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.DateCreated,
			}
		},
	}
	// RefundTransactionsOrderFieldDateUpdated orders RefundTransactions by dateUpdated.
	RefundTransactionsOrderFieldDateUpdated = &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.DateUpdated, nil
		},
		column: refundtransactions.FieldDateUpdated,
		toTerm: refundtransactions.ByDateUpdated,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RefundTransactionsOrderField) String() string {
	var str string
	switch f.column {
	case RefundTransactionsOrderFieldRefundAmount.column:
		str = "REFUNDAMOUNT"
	case RefundTransactionsOrderFieldRefundCurrency.column:
		str = "REFUNDCURRENCY"
	case RefundTransactionsOrderFieldRefundReason.column:
		str = "REFUNDREASON"
	case RefundTransactionsOrderFieldRefundStatus.column:
		str = "REFUNDSTATUS"
	case RefundTransactionsOrderFieldDateCreated.column:
		str = "DATECREATED"
	case RefundTransactionsOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RefundTransactionsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RefundTransactionsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RefundTransactionsOrderField %T must be a string", v)
	}
	switch str {
	case "REFUNDAMOUNT":
		*f = *RefundTransactionsOrderFieldRefundAmount
	case "REFUNDCURRENCY":
		*f = *RefundTransactionsOrderFieldRefundCurrency
	case "REFUNDREASON":
		*f = *RefundTransactionsOrderFieldRefundReason
	case "REFUNDSTATUS":
		*f = *RefundTransactionsOrderFieldRefundStatus
	case "DATECREATED":
		*f = *RefundTransactionsOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *RefundTransactionsOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid RefundTransactionsOrderField", str)
	}
	return nil
}

// RefundTransactionsOrderField defines the ordering field of RefundTransactions.
type RefundTransactionsOrderField struct {
	// Value extracts the ordering value from the given RefundTransactions.
	Value    func(*RefundTransactions) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) refundtransactions.OrderOption
	toCursor func(*RefundTransactions) Cursor
}

// RefundTransactionsOrder defines the ordering of RefundTransactions.
type RefundTransactionsOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *RefundTransactionsOrderField `json:"field"`
}

// DefaultRefundTransactionsOrder is the default ordering of RefundTransactions.
var DefaultRefundTransactionsOrder = &RefundTransactionsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RefundTransactionsOrderField{
		Value: func(rt *RefundTransactions) (ent.Value, error) {
			return rt.ID, nil
		},
		column: refundtransactions.FieldID,
		toTerm: refundtransactions.ByID,
		toCursor: func(rt *RefundTransactions) Cursor {
			return Cursor{ID: rt.ID}
		},
	},
}

// ToEdge converts RefundTransactions into RefundTransactionsEdge.
func (rt *RefundTransactions) ToEdge(order *RefundTransactionsOrder) *RefundTransactionsEdge {
	if order == nil {
		order = DefaultRefundTransactionsOrder
	}
	return &RefundTransactionsEdge{
		Node:   rt,
		Cursor: order.Field.toCursor(rt),
	}
}

// ReviewEdge is the edge representation of Review.
type ReviewEdge struct {
	Node   *Review `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ReviewConnection is the connection containing edges to Review.
type ReviewConnection struct {
	Edges      []*ReviewEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ReviewConnection) build(nodes []*Review, pager *reviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Review
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Review {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Review {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReviewPaginateOption enables pagination customization.
type ReviewPaginateOption func(*reviewPager) error

// WithReviewOrder configures pagination ordering.
func WithReviewOrder(order []*ReviewOrder) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReviewFilter configures pagination filter.
func WithReviewFilter(filter func(*ReviewQuery) (*ReviewQuery, error)) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		if filter == nil {
			return errors.New("ReviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reviewPager struct {
	reverse bool
	order   []*ReviewOrder
	filter  func(*ReviewQuery) (*ReviewQuery, error)
}

func newReviewPager(opts []ReviewPaginateOption, reverse bool) (*reviewPager, error) {
	pager := &reviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *reviewPager) applyFilter(query *ReviewQuery) (*ReviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reviewPager) toCursor(r *Review) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs}
}

func (p *reviewPager) applyCursors(query *ReviewQuery, after, before *Cursor) (*ReviewQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReviewOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *reviewPager) applyOrder(query *ReviewQuery) *ReviewQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReviewOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *reviewPager) orderExpr(query *ReviewQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReviewOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Review.
func (r *ReviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReviewPaginateOption,
) (*ReviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &ReviewConnection{Edges: []*ReviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReviewOrderFieldType orders Review by type.
	ReviewOrderFieldType = &ReviewOrderField{
		Value: func(r *Review) (ent.Value, error) {
			return r.Type, nil
		},
		column: review.FieldType,
		toTerm: review.ByType,
		toCursor: func(r *Review) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Type,
			}
		},
	}
	// ReviewOrderFieldContent orders Review by content.
	ReviewOrderFieldContent = &ReviewOrderField{
		Value: func(r *Review) (ent.Value, error) {
			return r.Content, nil
		},
		column: review.FieldContent,
		toTerm: review.ByContent,
		toCursor: func(r *Review) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Content,
			}
		},
	}
	// ReviewOrderFieldRating orders Review by rating.
	ReviewOrderFieldRating = &ReviewOrderField{
		Value: func(r *Review) (ent.Value, error) {
			return r.Rating, nil
		},
		column: review.FieldRating,
		toTerm: review.ByRating,
		toCursor: func(r *Review) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Rating,
			}
		},
	}
	// ReviewOrderFieldDateCreated orders Review by dateCreated.
	ReviewOrderFieldDateCreated = &ReviewOrderField{
		Value: func(r *Review) (ent.Value, error) {
			return r.DateCreated, nil
		},
		column: review.FieldDateCreated,
		toTerm: review.ByDateCreated,
		toCursor: func(r *Review) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DateCreated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReviewOrderField) String() string {
	var str string
	switch f.column {
	case ReviewOrderFieldType.column:
		str = "TYPE"
	case ReviewOrderFieldContent.column:
		str = "CONTENT"
	case ReviewOrderFieldRating.column:
		str = "RATING"
	case ReviewOrderFieldDateCreated.column:
		str = "DATECREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReviewOrderField %T must be a string", v)
	}
	switch str {
	case "TYPE":
		*f = *ReviewOrderFieldType
	case "CONTENT":
		*f = *ReviewOrderFieldContent
	case "RATING":
		*f = *ReviewOrderFieldRating
	case "DATECREATED":
		*f = *ReviewOrderFieldDateCreated
	default:
		return fmt.Errorf("%s is not a valid ReviewOrderField", str)
	}
	return nil
}

// ReviewOrderField defines the ordering field of Review.
type ReviewOrderField struct {
	// Value extracts the ordering value from the given Review.
	Value    func(*Review) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) review.OrderOption
	toCursor func(*Review) Cursor
}

// ReviewOrder defines the ordering of Review.
type ReviewOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ReviewOrderField `json:"field"`
}

// DefaultReviewOrder is the default ordering of Review.
var DefaultReviewOrder = &ReviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReviewOrderField{
		Value: func(r *Review) (ent.Value, error) {
			return r.ID, nil
		},
		column: review.FieldID,
		toTerm: review.ByID,
		toCursor: func(r *Review) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Review into ReviewEdge.
func (r *Review) ToEdge(order *ReviewOrder) *ReviewEdge {
	if order == nil {
		order = DefaultReviewOrder
	}
	return &ReviewEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RewardTypeEdge is the edge representation of RewardType.
type RewardTypeEdge struct {
	Node   *RewardType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// RewardTypeConnection is the connection containing edges to RewardType.
type RewardTypeConnection struct {
	Edges      []*RewardTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *RewardTypeConnection) build(nodes []*RewardType, pager *rewardtypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RewardType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RewardType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RewardType {
			return nodes[i]
		}
	}
	c.Edges = make([]*RewardTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RewardTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RewardTypePaginateOption enables pagination customization.
type RewardTypePaginateOption func(*rewardtypePager) error

// WithRewardTypeOrder configures pagination ordering.
func WithRewardTypeOrder(order []*RewardTypeOrder) RewardTypePaginateOption {
	return func(pager *rewardtypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRewardTypeFilter configures pagination filter.
func WithRewardTypeFilter(filter func(*RewardTypeQuery) (*RewardTypeQuery, error)) RewardTypePaginateOption {
	return func(pager *rewardtypePager) error {
		if filter == nil {
			return errors.New("RewardTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type rewardtypePager struct {
	reverse bool
	order   []*RewardTypeOrder
	filter  func(*RewardTypeQuery) (*RewardTypeQuery, error)
}

func newRewardTypePager(opts []RewardTypePaginateOption, reverse bool) (*rewardtypePager, error) {
	pager := &rewardtypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *rewardtypePager) applyFilter(query *RewardTypeQuery) (*RewardTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *rewardtypePager) toCursor(rt *RewardType) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(rt).Value)
	}
	return Cursor{ID: rt.ID, Value: cs}
}

func (p *rewardtypePager) applyCursors(query *RewardTypeQuery, after, before *Cursor) (*RewardTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRewardTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *rewardtypePager) applyOrder(query *RewardTypeQuery) *RewardTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRewardTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRewardTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *rewardtypePager) orderExpr(query *RewardTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRewardTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to RewardType.
func (rt *RewardTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RewardTypePaginateOption,
) (*RewardTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRewardTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rt, err = pager.applyFilter(rt); err != nil {
		return nil, err
	}
	conn := &RewardTypeConnection{Edges: []*RewardTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rt, err = pager.applyCursors(rt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		rt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rt = pager.applyOrder(rt)
	nodes, err := rt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RewardTypeOrderFieldType orders RewardType by type.
	RewardTypeOrderFieldType = &RewardTypeOrderField{
		Value: func(rt *RewardType) (ent.Value, error) {
			return rt.Type, nil
		},
		column: rewardtype.FieldType,
		toTerm: rewardtype.ByType,
		toCursor: func(rt *RewardType) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.Type,
			}
		},
	}
	// RewardTypeOrderFieldVal orders RewardType by val.
	RewardTypeOrderFieldVal = &RewardTypeOrderField{
		Value: func(rt *RewardType) (ent.Value, error) {
			return rt.Val, nil
		},
		column: rewardtype.FieldVal,
		toTerm: rewardtype.ByVal,
		toCursor: func(rt *RewardType) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.Val,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RewardTypeOrderField) String() string {
	var str string
	switch f.column {
	case RewardTypeOrderFieldType.column:
		str = "TYPE"
	case RewardTypeOrderFieldVal.column:
		str = "VAL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RewardTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RewardTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RewardTypeOrderField %T must be a string", v)
	}
	switch str {
	case "TYPE":
		*f = *RewardTypeOrderFieldType
	case "VAL":
		*f = *RewardTypeOrderFieldVal
	default:
		return fmt.Errorf("%s is not a valid RewardTypeOrderField", str)
	}
	return nil
}

// RewardTypeOrderField defines the ordering field of RewardType.
type RewardTypeOrderField struct {
	// Value extracts the ordering value from the given RewardType.
	Value    func(*RewardType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) rewardtype.OrderOption
	toCursor func(*RewardType) Cursor
}

// RewardTypeOrder defines the ordering of RewardType.
type RewardTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *RewardTypeOrderField `json:"field"`
}

// DefaultRewardTypeOrder is the default ordering of RewardType.
var DefaultRewardTypeOrder = &RewardTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RewardTypeOrderField{
		Value: func(rt *RewardType) (ent.Value, error) {
			return rt.ID, nil
		},
		column: rewardtype.FieldID,
		toTerm: rewardtype.ByID,
		toCursor: func(rt *RewardType) Cursor {
			return Cursor{ID: rt.ID}
		},
	},
}

// ToEdge converts RewardType into RewardTypeEdge.
func (rt *RewardType) ToEdge(order *RewardTypeOrder) *RewardTypeEdge {
	if order == nil {
		order = DefaultRewardTypeOrder
	}
	return &RewardTypeEdge{
		Node:   rt,
		Cursor: order.Field.toCursor(rt),
	}
}

// ShippingAddressEdge is the edge representation of ShippingAddress.
type ShippingAddressEdge struct {
	Node   *ShippingAddress `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ShippingAddressConnection is the connection containing edges to ShippingAddress.
type ShippingAddressConnection struct {
	Edges      []*ShippingAddressEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ShippingAddressConnection) build(nodes []*ShippingAddress, pager *shippingaddressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShippingAddress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShippingAddress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShippingAddress {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShippingAddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShippingAddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShippingAddressPaginateOption enables pagination customization.
type ShippingAddressPaginateOption func(*shippingaddressPager) error

// WithShippingAddressOrder configures pagination ordering.
func WithShippingAddressOrder(order []*ShippingAddressOrder) ShippingAddressPaginateOption {
	return func(pager *shippingaddressPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithShippingAddressFilter configures pagination filter.
func WithShippingAddressFilter(filter func(*ShippingAddressQuery) (*ShippingAddressQuery, error)) ShippingAddressPaginateOption {
	return func(pager *shippingaddressPager) error {
		if filter == nil {
			return errors.New("ShippingAddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shippingaddressPager struct {
	reverse bool
	order   []*ShippingAddressOrder
	filter  func(*ShippingAddressQuery) (*ShippingAddressQuery, error)
}

func newShippingAddressPager(opts []ShippingAddressPaginateOption, reverse bool) (*shippingaddressPager, error) {
	pager := &shippingaddressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *shippingaddressPager) applyFilter(query *ShippingAddressQuery) (*ShippingAddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shippingaddressPager) toCursor(sa *ShippingAddress) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(sa).Value)
	}
	return Cursor{ID: sa.ID, Value: cs}
}

func (p *shippingaddressPager) applyCursors(query *ShippingAddressQuery, after, before *Cursor) (*ShippingAddressQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultShippingAddressOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shippingaddressPager) applyOrder(query *ShippingAddressQuery) *ShippingAddressQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultShippingAddressOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultShippingAddressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *shippingaddressPager) orderExpr(query *ShippingAddressQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultShippingAddressOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShippingAddress.
func (sa *ShippingAddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShippingAddressPaginateOption,
) (*ShippingAddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShippingAddressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sa, err = pager.applyFilter(sa); err != nil {
		return nil, err
	}
	conn := &ShippingAddressConnection{Edges: []*ShippingAddressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sa, err = pager.applyCursors(sa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sa = pager.applyOrder(sa)
	nodes, err := sa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ShippingAddressOrderFieldName orders ShippingAddress by name.
	ShippingAddressOrderFieldName = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.Name, nil
		},
		column: shippingaddress.FieldName,
		toTerm: shippingaddress.ByName,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.Name,
			}
		},
	}
	// ShippingAddressOrderFieldAddress orders ShippingAddress by address.
	ShippingAddressOrderFieldAddress = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.Address, nil
		},
		column: shippingaddress.FieldAddress,
		toTerm: shippingaddress.ByAddress,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.Address,
			}
		},
	}
	// ShippingAddressOrderFieldCity orders ShippingAddress by city.
	ShippingAddressOrderFieldCity = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.City, nil
		},
		column: shippingaddress.FieldCity,
		toTerm: shippingaddress.ByCity,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.City,
			}
		},
	}
	// ShippingAddressOrderFieldState orders ShippingAddress by state.
	ShippingAddressOrderFieldState = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.State, nil
		},
		column: shippingaddress.FieldState,
		toTerm: shippingaddress.ByState,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.State,
			}
		},
	}
	// ShippingAddressOrderFieldZip orders ShippingAddress by zip.
	ShippingAddressOrderFieldZip = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.Zip, nil
		},
		column: shippingaddress.FieldZip,
		toTerm: shippingaddress.ByZip,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.Zip,
			}
		},
	}
	// ShippingAddressOrderFieldCountry orders ShippingAddress by country.
	ShippingAddressOrderFieldCountry = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.Country, nil
		},
		column: shippingaddress.FieldCountry,
		toTerm: shippingaddress.ByCountry,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.Country,
			}
		},
	}
	// ShippingAddressOrderFieldDateCreated orders ShippingAddress by dateCreated.
	ShippingAddressOrderFieldDateCreated = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.DateCreated, nil
		},
		column: shippingaddress.FieldDateCreated,
		toTerm: shippingaddress.ByDateCreated,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.DateCreated,
			}
		},
	}
	// ShippingAddressOrderFieldDateUpdated orders ShippingAddress by dateUpdated.
	ShippingAddressOrderFieldDateUpdated = &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.DateUpdated, nil
		},
		column: shippingaddress.FieldDateUpdated,
		toTerm: shippingaddress.ByDateUpdated,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShippingAddressOrderField) String() string {
	var str string
	switch f.column {
	case ShippingAddressOrderFieldName.column:
		str = "NAME"
	case ShippingAddressOrderFieldAddress.column:
		str = "ADDRESS"
	case ShippingAddressOrderFieldCity.column:
		str = "CITY"
	case ShippingAddressOrderFieldState.column:
		str = "STATE"
	case ShippingAddressOrderFieldZip.column:
		str = "ZIP"
	case ShippingAddressOrderFieldCountry.column:
		str = "COUNTRY"
	case ShippingAddressOrderFieldDateCreated.column:
		str = "DATECREATED"
	case ShippingAddressOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShippingAddressOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShippingAddressOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShippingAddressOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ShippingAddressOrderFieldName
	case "ADDRESS":
		*f = *ShippingAddressOrderFieldAddress
	case "CITY":
		*f = *ShippingAddressOrderFieldCity
	case "STATE":
		*f = *ShippingAddressOrderFieldState
	case "ZIP":
		*f = *ShippingAddressOrderFieldZip
	case "COUNTRY":
		*f = *ShippingAddressOrderFieldCountry
	case "DATECREATED":
		*f = *ShippingAddressOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *ShippingAddressOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid ShippingAddressOrderField", str)
	}
	return nil
}

// ShippingAddressOrderField defines the ordering field of ShippingAddress.
type ShippingAddressOrderField struct {
	// Value extracts the ordering value from the given ShippingAddress.
	Value    func(*ShippingAddress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shippingaddress.OrderOption
	toCursor func(*ShippingAddress) Cursor
}

// ShippingAddressOrder defines the ordering of ShippingAddress.
type ShippingAddressOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ShippingAddressOrderField `json:"field"`
}

// DefaultShippingAddressOrder is the default ordering of ShippingAddress.
var DefaultShippingAddressOrder = &ShippingAddressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShippingAddressOrderField{
		Value: func(sa *ShippingAddress) (ent.Value, error) {
			return sa.ID, nil
		},
		column: shippingaddress.FieldID,
		toTerm: shippingaddress.ByID,
		toCursor: func(sa *ShippingAddress) Cursor {
			return Cursor{ID: sa.ID}
		},
	},
}

// ToEdge converts ShippingAddress into ShippingAddressEdge.
func (sa *ShippingAddress) ToEdge(order *ShippingAddressOrder) *ShippingAddressEdge {
	if order == nil {
		order = DefaultShippingAddressOrder
	}
	return &ShippingAddressEdge{
		Node:   sa,
		Cursor: order.Field.toCursor(sa),
	}
}

// ShopEdge is the edge representation of Shop.
type ShopEdge struct {
	Node   *Shop  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ShopConnection is the connection containing edges to Shop.
type ShopConnection struct {
	Edges      []*ShopEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ShopConnection) build(nodes []*Shop, pager *shopPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Shop
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Shop {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Shop {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShopEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShopEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShopPaginateOption enables pagination customization.
type ShopPaginateOption func(*shopPager) error

// WithShopOrder configures pagination ordering.
func WithShopOrder(order []*ShopOrder) ShopPaginateOption {
	return func(pager *shopPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithShopFilter configures pagination filter.
func WithShopFilter(filter func(*ShopQuery) (*ShopQuery, error)) ShopPaginateOption {
	return func(pager *shopPager) error {
		if filter == nil {
			return errors.New("ShopQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shopPager struct {
	reverse bool
	order   []*ShopOrder
	filter  func(*ShopQuery) (*ShopQuery, error)
}

func newShopPager(opts []ShopPaginateOption, reverse bool) (*shopPager, error) {
	pager := &shopPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *shopPager) applyFilter(query *ShopQuery) (*ShopQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shopPager) toCursor(s *Shop) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *shopPager) applyCursors(query *ShopQuery, after, before *Cursor) (*ShopQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultShopOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shopPager) applyOrder(query *ShopQuery) *ShopQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultShopOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultShopOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *shopPager) orderExpr(query *ShopQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultShopOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Shop.
func (s *ShopQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShopPaginateOption,
) (*ShopConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShopPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &ShopConnection{Edges: []*ShopEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ShopOrderFieldName orders Shop by name.
	ShopOrderFieldName = &ShopOrderField{
		Value: func(s *Shop) (ent.Value, error) {
			return s.Name, nil
		},
		column: shop.FieldName,
		toTerm: shop.ByName,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
	// ShopOrderFieldDescription orders Shop by description.
	ShopOrderFieldDescription = &ShopOrderField{
		Value: func(s *Shop) (ent.Value, error) {
			return s.Description, nil
		},
		column: shop.FieldDescription,
		toTerm: shop.ByDescription,
		toCursor: func(s *Shop) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShopOrderField) String() string {
	var str string
	switch f.column {
	case ShopOrderFieldName.column:
		str = "NAME"
	case ShopOrderFieldDescription.column:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShopOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShopOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShopOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ShopOrderFieldName
	case "DESCRIPTION":
		*f = *ShopOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid ShopOrderField", str)
	}
	return nil
}

// ShopOrderField defines the ordering field of Shop.
type ShopOrderField struct {
	// Value extracts the ordering value from the given Shop.
	Value    func(*Shop) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shop.OrderOption
	toCursor func(*Shop) Cursor
}

// ShopOrder defines the ordering of Shop.
type ShopOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ShopOrderField `json:"field"`
}

// DefaultShopOrder is the default ordering of Shop.
var DefaultShopOrder = &ShopOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShopOrderField{
		Value: func(s *Shop) (ent.Value, error) {
			return s.ID, nil
		},
		column: shop.FieldID,
		toTerm: shop.ByID,
		toCursor: func(s *Shop) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Shop into ShopEdge.
func (s *Shop) ToEdge(order *ShopOrder) *ShopEdge {
	if order == nil {
		order = DefaultShopOrder
	}
	return &ShopEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *TagConnection) build(nodes []*Tag, pager *tagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order []*TagOrder) TagPaginateOption {
	return func(pager *tagPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	reverse bool
	order   []*TagOrder
	filter  func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption, reverse bool) (*tagPager, error) {
	pager := &tagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) (*TagQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTagOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tagPager) applyOrder(query *TagQuery) *TagQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTagOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tagPager) orderExpr(query *TagQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTagOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TagConnection{Edges: []*TagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TagOrderFieldName orders Tag by name.
	TagOrderFieldName = &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.Name, nil
		},
		column: tag.FieldName,
		toTerm: tag.ByName,
		toCursor: func(t *Tag) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
	// TagOrderFieldDescription orders Tag by description.
	TagOrderFieldDescription = &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.Description, nil
		},
		column: tag.FieldDescription,
		toTerm: tag.ByDescription,
		toCursor: func(t *Tag) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TagOrderField) String() string {
	var str string
	switch f.column {
	case TagOrderFieldName.column:
		str = "NAME"
	case TagOrderFieldDescription.column:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TagOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TagOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TagOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *TagOrderFieldName
	case "DESCRIPTION":
		*f = *TagOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid TagOrderField", str)
	}
	return nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	// Value extracts the ordering value from the given Tag.
	Value    func(*Tag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tag.OrderOption
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.ID, nil
		},
		column: tag.FieldID,
		toTerm: tag.ByID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TransactionEdge is the edge representation of Transaction.
type TransactionEdge struct {
	Node   *Transaction `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TransactionConnection is the connection containing edges to Transaction.
type TransactionConnection struct {
	Edges      []*TransactionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TransactionConnection) build(nodes []*Transaction, pager *transactionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Transaction
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Transaction {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Transaction {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionPaginateOption enables pagination customization.
type TransactionPaginateOption func(*transactionPager) error

// WithTransactionOrder configures pagination ordering.
func WithTransactionOrder(order []*TransactionOrder) TransactionPaginateOption {
	return func(pager *transactionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTransactionFilter configures pagination filter.
func WithTransactionFilter(filter func(*TransactionQuery) (*TransactionQuery, error)) TransactionPaginateOption {
	return func(pager *transactionPager) error {
		if filter == nil {
			return errors.New("TransactionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionPager struct {
	reverse bool
	order   []*TransactionOrder
	filter  func(*TransactionQuery) (*TransactionQuery, error)
}

func newTransactionPager(opts []TransactionPaginateOption, reverse bool) (*transactionPager, error) {
	pager := &transactionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *transactionPager) applyFilter(query *TransactionQuery) (*TransactionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionPager) toCursor(t *Transaction) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *transactionPager) applyCursors(query *TransactionQuery, after, before *Cursor) (*TransactionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTransactionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *transactionPager) applyOrder(query *TransactionQuery) *TransactionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTransactionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTransactionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *transactionPager) orderExpr(query *TransactionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTransactionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Transaction.
func (t *TransactionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionPaginateOption,
) (*TransactionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TransactionConnection{Edges: []*TransactionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TransactionOrderFieldDateCreated orders Transaction by dateCreated.
	TransactionOrderFieldDateCreated = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.DateCreated, nil
		},
		column: transaction.FieldDateCreated,
		toTerm: transaction.ByDateCreated,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.DateCreated,
			}
		},
	}
	// TransactionOrderFieldDateUpdated orders Transaction by dateUpdated.
	TransactionOrderFieldDateUpdated = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.DateUpdated, nil
		},
		column: transaction.FieldDateUpdated,
		toTerm: transaction.ByDateUpdated,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.DateUpdated,
			}
		},
	}
	// TransactionOrderFieldStatus orders Transaction by status.
	TransactionOrderFieldStatus = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.Status, nil
		},
		column: transaction.FieldStatus,
		toTerm: transaction.ByStatus,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Status,
			}
		},
	}
	// TransactionOrderFieldPaymentMethod orders Transaction by paymentMethod.
	TransactionOrderFieldPaymentMethod = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentMethod, nil
		},
		column: transaction.FieldPaymentMethod,
		toTerm: transaction.ByPaymentMethod,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentMethod,
			}
		},
	}
	// TransactionOrderFieldPaymentStatus orders Transaction by paymentStatus.
	TransactionOrderFieldPaymentStatus = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentStatus, nil
		},
		column: transaction.FieldPaymentStatus,
		toTerm: transaction.ByPaymentStatus,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentStatus,
			}
		},
	}
	// TransactionOrderFieldPaymentId orders Transaction by paymentId.
	TransactionOrderFieldPaymentId = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentId, nil
		},
		column: transaction.FieldPaymentId,
		toTerm: transaction.ByPaymentId,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentId,
			}
		},
	}
	// TransactionOrderFieldPaymentAmount orders Transaction by paymentAmount.
	TransactionOrderFieldPaymentAmount = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentAmount, nil
		},
		column: transaction.FieldPaymentAmount,
		toTerm: transaction.ByPaymentAmount,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentAmount,
			}
		},
	}
	// TransactionOrderFieldPaymentCurrency orders Transaction by paymentCurrency.
	TransactionOrderFieldPaymentCurrency = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentCurrency, nil
		},
		column: transaction.FieldPaymentCurrency,
		toTerm: transaction.ByPaymentCurrency,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentCurrency,
			}
		},
	}
	// TransactionOrderFieldPaymentDate orders Transaction by paymentDate.
	TransactionOrderFieldPaymentDate = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentDate, nil
		},
		column: transaction.FieldPaymentDate,
		toTerm: transaction.ByPaymentDate,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentDate,
			}
		},
	}
	// TransactionOrderFieldPaymentFee orders Transaction by paymentFee.
	TransactionOrderFieldPaymentFee = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentFee, nil
		},
		column: transaction.FieldPaymentFee,
		toTerm: transaction.ByPaymentFee,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentFee,
			}
		},
	}
	// TransactionOrderFieldPaymentNet orders Transaction by paymentNet.
	TransactionOrderFieldPaymentNet = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentNet, nil
		},
		column: transaction.FieldPaymentNet,
		toTerm: transaction.ByPaymentNet,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentNet,
			}
		},
	}
	// TransactionOrderFieldPaymentPayerEmail orders Transaction by paymentPayerEmail.
	TransactionOrderFieldPaymentPayerEmail = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPayerEmail, nil
		},
		column: transaction.FieldPaymentPayerEmail,
		toTerm: transaction.ByPaymentPayerEmail,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPayerEmail,
			}
		},
	}
	// TransactionOrderFieldPaymentPayerFirstName orders Transaction by paymentPayerFirstName.
	TransactionOrderFieldPaymentPayerFirstName = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPayerFirstName, nil
		},
		column: transaction.FieldPaymentPayerFirstName,
		toTerm: transaction.ByPaymentPayerFirstName,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPayerFirstName,
			}
		},
	}
	// TransactionOrderFieldPaymentPayerLastName orders Transaction by paymentPayerLastName.
	TransactionOrderFieldPaymentPayerLastName = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPayerLastName, nil
		},
		column: transaction.FieldPaymentPayerLastName,
		toTerm: transaction.ByPaymentPayerLastName,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPayerLastName,
			}
		},
	}
	// TransactionOrderFieldPaymentPayerId orders Transaction by paymentPayerId.
	TransactionOrderFieldPaymentPayerId = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPayerId, nil
		},
		column: transaction.FieldPaymentPayerId,
		toTerm: transaction.ByPaymentPayerId,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPayerId,
			}
		},
	}
	// TransactionOrderFieldPaymentPayerStatus orders Transaction by paymentPayerStatus.
	TransactionOrderFieldPaymentPayerStatus = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPayerStatus, nil
		},
		column: transaction.FieldPaymentPayerStatus,
		toTerm: transaction.ByPaymentPayerStatus,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPayerStatus,
			}
		},
	}
	// TransactionOrderFieldPaymentReceiverEmail orders Transaction by paymentReceiverEmail.
	TransactionOrderFieldPaymentReceiverEmail = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentReceiverEmail, nil
		},
		column: transaction.FieldPaymentReceiverEmail,
		toTerm: transaction.ByPaymentReceiverEmail,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentReceiverEmail,
			}
		},
	}
	// TransactionOrderFieldPaymentReceiverId orders Transaction by paymentReceiverId.
	TransactionOrderFieldPaymentReceiverId = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentReceiverId, nil
		},
		column: transaction.FieldPaymentReceiverId,
		toTerm: transaction.ByPaymentReceiverId,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentReceiverId,
			}
		},
	}
	// TransactionOrderFieldPaymentTax orders Transaction by paymentTax.
	TransactionOrderFieldPaymentTax = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentTax, nil
		},
		column: transaction.FieldPaymentTax,
		toTerm: transaction.ByPaymentTax,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentTax,
			}
		},
	}
	// TransactionOrderFieldPaymentTransactionId orders Transaction by paymentTransactionId.
	TransactionOrderFieldPaymentTransactionId = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentTransactionId, nil
		},
		column: transaction.FieldPaymentTransactionId,
		toTerm: transaction.ByPaymentTransactionId,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentTransactionId,
			}
		},
	}
	// TransactionOrderFieldPaymentTransactionType orders Transaction by paymentTransactionType.
	TransactionOrderFieldPaymentTransactionType = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentTransactionType, nil
		},
		column: transaction.FieldPaymentTransactionType,
		toTerm: transaction.ByPaymentTransactionType,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentTransactionType,
			}
		},
	}
	// TransactionOrderFieldPaymentPendingReason orders Transaction by paymentPendingReason.
	TransactionOrderFieldPaymentPendingReason = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentPendingReason, nil
		},
		column: transaction.FieldPaymentPendingReason,
		toTerm: transaction.ByPaymentPendingReason,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentPendingReason,
			}
		},
	}
	// TransactionOrderFieldPaymentReasonCode orders Transaction by paymentReasonCode.
	TransactionOrderFieldPaymentReasonCode = &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.PaymentReasonCode, nil
		},
		column: transaction.FieldPaymentReasonCode,
		toTerm: transaction.ByPaymentReasonCode,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PaymentReasonCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TransactionOrderField) String() string {
	var str string
	switch f.column {
	case TransactionOrderFieldDateCreated.column:
		str = "DATECREATED"
	case TransactionOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	case TransactionOrderFieldStatus.column:
		str = "STATUS"
	case TransactionOrderFieldPaymentMethod.column:
		str = "PAYMENTMETHOD"
	case TransactionOrderFieldPaymentStatus.column:
		str = "PAYMENTSTATUS"
	case TransactionOrderFieldPaymentId.column:
		str = "PAYMENTID"
	case TransactionOrderFieldPaymentAmount.column:
		str = "PAYMENTAMOUNT"
	case TransactionOrderFieldPaymentCurrency.column:
		str = "PAYMENTCURRENCY"
	case TransactionOrderFieldPaymentDate.column:
		str = "PAYMENTDATE"
	case TransactionOrderFieldPaymentFee.column:
		str = "PAYMENTFEE"
	case TransactionOrderFieldPaymentNet.column:
		str = "PAYMENTNET"
	case TransactionOrderFieldPaymentPayerEmail.column:
		str = "PAYMENTPAYEREMAIL"
	case TransactionOrderFieldPaymentPayerFirstName.column:
		str = "PAYMENTPAYERFIRSTNAME"
	case TransactionOrderFieldPaymentPayerLastName.column:
		str = "PAYMENTPAYERLASTNAME"
	case TransactionOrderFieldPaymentPayerId.column:
		str = "PAYMENTPAYERID"
	case TransactionOrderFieldPaymentPayerStatus.column:
		str = "PAYMENTPAYERSTATUS"
	case TransactionOrderFieldPaymentReceiverEmail.column:
		str = "PAYMENTRECEIVEREMAIL"
	case TransactionOrderFieldPaymentReceiverId.column:
		str = "PAYMENTRECEIVERID"
	case TransactionOrderFieldPaymentTax.column:
		str = "PAYMENTTAX"
	case TransactionOrderFieldPaymentTransactionId.column:
		str = "PAYMENTTRANSACTIONID"
	case TransactionOrderFieldPaymentTransactionType.column:
		str = "PAYMENTTRANSACTIONTYPE"
	case TransactionOrderFieldPaymentPendingReason.column:
		str = "PAYMENTPENDINGREASON"
	case TransactionOrderFieldPaymentReasonCode.column:
		str = "PAYMENTREASONCODE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TransactionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TransactionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TransactionOrderField %T must be a string", v)
	}
	switch str {
	case "DATECREATED":
		*f = *TransactionOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *TransactionOrderFieldDateUpdated
	case "STATUS":
		*f = *TransactionOrderFieldStatus
	case "PAYMENTMETHOD":
		*f = *TransactionOrderFieldPaymentMethod
	case "PAYMENTSTATUS":
		*f = *TransactionOrderFieldPaymentStatus
	case "PAYMENTID":
		*f = *TransactionOrderFieldPaymentId
	case "PAYMENTAMOUNT":
		*f = *TransactionOrderFieldPaymentAmount
	case "PAYMENTCURRENCY":
		*f = *TransactionOrderFieldPaymentCurrency
	case "PAYMENTDATE":
		*f = *TransactionOrderFieldPaymentDate
	case "PAYMENTFEE":
		*f = *TransactionOrderFieldPaymentFee
	case "PAYMENTNET":
		*f = *TransactionOrderFieldPaymentNet
	case "PAYMENTPAYEREMAIL":
		*f = *TransactionOrderFieldPaymentPayerEmail
	case "PAYMENTPAYERFIRSTNAME":
		*f = *TransactionOrderFieldPaymentPayerFirstName
	case "PAYMENTPAYERLASTNAME":
		*f = *TransactionOrderFieldPaymentPayerLastName
	case "PAYMENTPAYERID":
		*f = *TransactionOrderFieldPaymentPayerId
	case "PAYMENTPAYERSTATUS":
		*f = *TransactionOrderFieldPaymentPayerStatus
	case "PAYMENTRECEIVEREMAIL":
		*f = *TransactionOrderFieldPaymentReceiverEmail
	case "PAYMENTRECEIVERID":
		*f = *TransactionOrderFieldPaymentReceiverId
	case "PAYMENTTAX":
		*f = *TransactionOrderFieldPaymentTax
	case "PAYMENTTRANSACTIONID":
		*f = *TransactionOrderFieldPaymentTransactionId
	case "PAYMENTTRANSACTIONTYPE":
		*f = *TransactionOrderFieldPaymentTransactionType
	case "PAYMENTPENDINGREASON":
		*f = *TransactionOrderFieldPaymentPendingReason
	case "PAYMENTREASONCODE":
		*f = *TransactionOrderFieldPaymentReasonCode
	default:
		return fmt.Errorf("%s is not a valid TransactionOrderField", str)
	}
	return nil
}

// TransactionOrderField defines the ordering field of Transaction.
type TransactionOrderField struct {
	// Value extracts the ordering value from the given Transaction.
	Value    func(*Transaction) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) transaction.OrderOption
	toCursor func(*Transaction) Cursor
}

// TransactionOrder defines the ordering of Transaction.
type TransactionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TransactionOrderField `json:"field"`
}

// DefaultTransactionOrder is the default ordering of Transaction.
var DefaultTransactionOrder = &TransactionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TransactionOrderField{
		Value: func(t *Transaction) (ent.Value, error) {
			return t.ID, nil
		},
		column: transaction.FieldID,
		toTerm: transaction.ByID,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Transaction into TransactionEdge.
func (t *Transaction) ToEdge(order *TransactionOrder) *TransactionEdge {
	if order == nil {
		order = DefaultTransactionOrder
	}
	return &TransactionEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order []*UserOrder) UserPaginateOption {
	return func(pager *userPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   []*UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(u).Value)
	}
	return Cursor{ID: u.ID, Value: cs}
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldName orders User by name.
	UserOrderFieldName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Name, nil
		},
		column: user.FieldName,
		toTerm: user.ByName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Name,
			}
		},
	}
	// UserOrderFieldEmail orders User by email.
	UserOrderFieldEmail = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Email, nil
		},
		column: user.FieldEmail,
		toTerm: user.ByEmail,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Email,
			}
		},
	}
	// UserOrderFieldPhone orders User by phone.
	UserOrderFieldPhone = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Phone, nil
		},
		column: user.FieldPhone,
		toTerm: user.ByPhone,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Phone,
			}
		},
	}
	// UserOrderFieldAddress orders User by address.
	UserOrderFieldAddress = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Address, nil
		},
		column: user.FieldAddress,
		toTerm: user.ByAddress,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Address,
			}
		},
	}
	// UserOrderFieldCity orders User by city.
	UserOrderFieldCity = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.City, nil
		},
		column: user.FieldCity,
		toTerm: user.ByCity,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.City,
			}
		},
	}
	// UserOrderFieldState orders User by state.
	UserOrderFieldState = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.State, nil
		},
		column: user.FieldState,
		toTerm: user.ByState,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.State,
			}
		},
	}
	// UserOrderFieldZip orders User by zip.
	UserOrderFieldZip = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Zip, nil
		},
		column: user.FieldZip,
		toTerm: user.ByZip,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Zip,
			}
		},
	}
	// UserOrderFieldCountry orders User by country.
	UserOrderFieldCountry = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Country, nil
		},
		column: user.FieldCountry,
		toTerm: user.ByCountry,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Country,
			}
		},
	}
	// UserOrderFieldDateCreated orders User by dateCreated.
	UserOrderFieldDateCreated = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.DateCreated, nil
		},
		column: user.FieldDateCreated,
		toTerm: user.ByDateCreated,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DateCreated,
			}
		},
	}
	// UserOrderFieldDateUpdated orders User by dateUpdated.
	UserOrderFieldDateUpdated = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.DateUpdated, nil
		},
		column: user.FieldDateUpdated,
		toTerm: user.ByDateUpdated,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DateUpdated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldName.column:
		str = "NAME"
	case UserOrderFieldEmail.column:
		str = "EMAIL"
	case UserOrderFieldPhone.column:
		str = "PHONE"
	case UserOrderFieldAddress.column:
		str = "ADDRESS"
	case UserOrderFieldCity.column:
		str = "CITY"
	case UserOrderFieldState.column:
		str = "STATE"
	case UserOrderFieldZip.column:
		str = "ZIP"
	case UserOrderFieldCountry.column:
		str = "COUNTRY"
	case UserOrderFieldDateCreated.column:
		str = "DATECREATED"
	case UserOrderFieldDateUpdated.column:
		str = "DATEUPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *UserOrderFieldName
	case "EMAIL":
		*f = *UserOrderFieldEmail
	case "PHONE":
		*f = *UserOrderFieldPhone
	case "ADDRESS":
		*f = *UserOrderFieldAddress
	case "CITY":
		*f = *UserOrderFieldCity
	case "STATE":
		*f = *UserOrderFieldState
	case "ZIP":
		*f = *UserOrderFieldZip
	case "COUNTRY":
		*f = *UserOrderFieldCountry
	case "DATECREATED":
		*f = *UserOrderFieldDateCreated
	case "DATEUPDATED":
		*f = *UserOrderFieldDateUpdated
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserBuyerEdge is the edge representation of UserBuyer.
type UserBuyerEdge struct {
	Node   *UserBuyer `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// UserBuyerConnection is the connection containing edges to UserBuyer.
type UserBuyerConnection struct {
	Edges      []*UserBuyerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *UserBuyerConnection) build(nodes []*UserBuyer, pager *userbuyerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserBuyer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserBuyer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserBuyer {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserBuyerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserBuyerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserBuyerPaginateOption enables pagination customization.
type UserBuyerPaginateOption func(*userbuyerPager) error

// WithUserBuyerOrder configures pagination ordering.
func WithUserBuyerOrder(order []*UserBuyerOrder) UserBuyerPaginateOption {
	return func(pager *userbuyerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserBuyerFilter configures pagination filter.
func WithUserBuyerFilter(filter func(*UserBuyerQuery) (*UserBuyerQuery, error)) UserBuyerPaginateOption {
	return func(pager *userbuyerPager) error {
		if filter == nil {
			return errors.New("UserBuyerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userbuyerPager struct {
	reverse bool
	order   []*UserBuyerOrder
	filter  func(*UserBuyerQuery) (*UserBuyerQuery, error)
}

func newUserBuyerPager(opts []UserBuyerPaginateOption, reverse bool) (*userbuyerPager, error) {
	pager := &userbuyerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userbuyerPager) applyFilter(query *UserBuyerQuery) (*UserBuyerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userbuyerPager) toCursor(ub *UserBuyer) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ub).Value)
	}
	return Cursor{ID: ub.ID, Value: cs}
}

func (p *userbuyerPager) applyCursors(query *UserBuyerQuery, after, before *Cursor) (*UserBuyerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserBuyerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userbuyerPager) applyOrder(query *UserBuyerQuery) *UserBuyerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserBuyerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserBuyerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userbuyerPager) orderExpr(query *UserBuyerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserBuyerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserBuyer.
func (ub *UserBuyerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserBuyerPaginateOption,
) (*UserBuyerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserBuyerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ub, err = pager.applyFilter(ub); err != nil {
		return nil, err
	}
	conn := &UserBuyerConnection{Edges: []*UserBuyerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ub.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ub, err = pager.applyCursors(ub, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ub.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ub.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ub = pager.applyOrder(ub)
	nodes, err := ub.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserBuyerOrderFieldPlaceholder orders UserBuyer by placeholder.
	UserBuyerOrderFieldPlaceholder = &UserBuyerOrderField{
		Value: func(ub *UserBuyer) (ent.Value, error) {
			return ub.Placeholder, nil
		},
		column: userbuyer.FieldPlaceholder,
		toTerm: userbuyer.ByPlaceholder,
		toCursor: func(ub *UserBuyer) Cursor {
			return Cursor{
				ID:    ub.ID,
				Value: ub.Placeholder,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserBuyerOrderField) String() string {
	var str string
	switch f.column {
	case UserBuyerOrderFieldPlaceholder.column:
		str = "PLACEHOLDER"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserBuyerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserBuyerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserBuyerOrderField %T must be a string", v)
	}
	switch str {
	case "PLACEHOLDER":
		*f = *UserBuyerOrderFieldPlaceholder
	default:
		return fmt.Errorf("%s is not a valid UserBuyerOrderField", str)
	}
	return nil
}

// UserBuyerOrderField defines the ordering field of UserBuyer.
type UserBuyerOrderField struct {
	// Value extracts the ordering value from the given UserBuyer.
	Value    func(*UserBuyer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userbuyer.OrderOption
	toCursor func(*UserBuyer) Cursor
}

// UserBuyerOrder defines the ordering of UserBuyer.
type UserBuyerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *UserBuyerOrderField `json:"field"`
}

// DefaultUserBuyerOrder is the default ordering of UserBuyer.
var DefaultUserBuyerOrder = &UserBuyerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserBuyerOrderField{
		Value: func(ub *UserBuyer) (ent.Value, error) {
			return ub.ID, nil
		},
		column: userbuyer.FieldID,
		toTerm: userbuyer.ByID,
		toCursor: func(ub *UserBuyer) Cursor {
			return Cursor{ID: ub.ID}
		},
	},
}

// ToEdge converts UserBuyer into UserBuyerEdge.
func (ub *UserBuyer) ToEdge(order *UserBuyerOrder) *UserBuyerEdge {
	if order == nil {
		order = DefaultUserBuyerOrder
	}
	return &UserBuyerEdge{
		Node:   ub,
		Cursor: order.Field.toCursor(ub),
	}
}

// UserInfluencerEdge is the edge representation of UserInfluencer.
type UserInfluencerEdge struct {
	Node   *UserInfluencer `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// UserInfluencerConnection is the connection containing edges to UserInfluencer.
type UserInfluencerConnection struct {
	Edges      []*UserInfluencerEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *UserInfluencerConnection) build(nodes []*UserInfluencer, pager *userinfluencerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserInfluencer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserInfluencer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserInfluencer {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserInfluencerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserInfluencerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserInfluencerPaginateOption enables pagination customization.
type UserInfluencerPaginateOption func(*userinfluencerPager) error

// WithUserInfluencerOrder configures pagination ordering.
func WithUserInfluencerOrder(order []*UserInfluencerOrder) UserInfluencerPaginateOption {
	return func(pager *userinfluencerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserInfluencerFilter configures pagination filter.
func WithUserInfluencerFilter(filter func(*UserInfluencerQuery) (*UserInfluencerQuery, error)) UserInfluencerPaginateOption {
	return func(pager *userinfluencerPager) error {
		if filter == nil {
			return errors.New("UserInfluencerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userinfluencerPager struct {
	reverse bool
	order   []*UserInfluencerOrder
	filter  func(*UserInfluencerQuery) (*UserInfluencerQuery, error)
}

func newUserInfluencerPager(opts []UserInfluencerPaginateOption, reverse bool) (*userinfluencerPager, error) {
	pager := &userinfluencerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userinfluencerPager) applyFilter(query *UserInfluencerQuery) (*UserInfluencerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userinfluencerPager) toCursor(ui *UserInfluencer) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(ui).Value)
	}
	return Cursor{ID: ui.ID, Value: cs}
}

func (p *userinfluencerPager) applyCursors(query *UserInfluencerQuery, after, before *Cursor) (*UserInfluencerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserInfluencerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userinfluencerPager) applyOrder(query *UserInfluencerQuery) *UserInfluencerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserInfluencerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserInfluencerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userinfluencerPager) orderExpr(query *UserInfluencerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserInfluencerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserInfluencer.
func (ui *UserInfluencerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserInfluencerPaginateOption,
) (*UserInfluencerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserInfluencerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ui, err = pager.applyFilter(ui); err != nil {
		return nil, err
	}
	conn := &UserInfluencerConnection{Edges: []*UserInfluencerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ui.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ui, err = pager.applyCursors(ui, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ui.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ui.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ui = pager.applyOrder(ui)
	nodes, err := ui.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserInfluencerOrderFieldPlaceholder orders UserInfluencer by placeholder.
	UserInfluencerOrderFieldPlaceholder = &UserInfluencerOrderField{
		Value: func(ui *UserInfluencer) (ent.Value, error) {
			return ui.Placeholder, nil
		},
		column: userinfluencer.FieldPlaceholder,
		toTerm: userinfluencer.ByPlaceholder,
		toCursor: func(ui *UserInfluencer) Cursor {
			return Cursor{
				ID:    ui.ID,
				Value: ui.Placeholder,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserInfluencerOrderField) String() string {
	var str string
	switch f.column {
	case UserInfluencerOrderFieldPlaceholder.column:
		str = "PLACEHOLDER"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserInfluencerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserInfluencerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserInfluencerOrderField %T must be a string", v)
	}
	switch str {
	case "PLACEHOLDER":
		*f = *UserInfluencerOrderFieldPlaceholder
	default:
		return fmt.Errorf("%s is not a valid UserInfluencerOrderField", str)
	}
	return nil
}

// UserInfluencerOrderField defines the ordering field of UserInfluencer.
type UserInfluencerOrderField struct {
	// Value extracts the ordering value from the given UserInfluencer.
	Value    func(*UserInfluencer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userinfluencer.OrderOption
	toCursor func(*UserInfluencer) Cursor
}

// UserInfluencerOrder defines the ordering of UserInfluencer.
type UserInfluencerOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *UserInfluencerOrderField `json:"field"`
}

// DefaultUserInfluencerOrder is the default ordering of UserInfluencer.
var DefaultUserInfluencerOrder = &UserInfluencerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserInfluencerOrderField{
		Value: func(ui *UserInfluencer) (ent.Value, error) {
			return ui.ID, nil
		},
		column: userinfluencer.FieldID,
		toTerm: userinfluencer.ByID,
		toCursor: func(ui *UserInfluencer) Cursor {
			return Cursor{ID: ui.ID}
		},
	},
}

// ToEdge converts UserInfluencer into UserInfluencerEdge.
func (ui *UserInfluencer) ToEdge(order *UserInfluencerOrder) *UserInfluencerEdge {
	if order == nil {
		order = DefaultUserInfluencerOrder
	}
	return &UserInfluencerEdge{
		Node:   ui,
		Cursor: order.Field.toCursor(ui),
	}
}

// UserSellerEdge is the edge representation of UserSeller.
type UserSellerEdge struct {
	Node   *UserSeller `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// UserSellerConnection is the connection containing edges to UserSeller.
type UserSellerConnection struct {
	Edges      []*UserSellerEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *UserSellerConnection) build(nodes []*UserSeller, pager *usersellerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSeller
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSeller {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSeller {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSellerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSellerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSellerPaginateOption enables pagination customization.
type UserSellerPaginateOption func(*usersellerPager) error

// WithUserSellerOrder configures pagination ordering.
func WithUserSellerOrder(order []*UserSellerOrder) UserSellerPaginateOption {
	return func(pager *usersellerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserSellerFilter configures pagination filter.
func WithUserSellerFilter(filter func(*UserSellerQuery) (*UserSellerQuery, error)) UserSellerPaginateOption {
	return func(pager *usersellerPager) error {
		if filter == nil {
			return errors.New("UserSellerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersellerPager struct {
	reverse bool
	order   []*UserSellerOrder
	filter  func(*UserSellerQuery) (*UserSellerQuery, error)
}

func newUserSellerPager(opts []UserSellerPaginateOption, reverse bool) (*usersellerPager, error) {
	pager := &usersellerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *usersellerPager) applyFilter(query *UserSellerQuery) (*UserSellerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersellerPager) toCursor(us *UserSeller) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(us).Value)
	}
	return Cursor{ID: us.ID, Value: cs}
}

func (p *usersellerPager) applyCursors(query *UserSellerQuery, after, before *Cursor) (*UserSellerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserSellerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersellerPager) applyOrder(query *UserSellerQuery) *UserSellerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserSellerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserSellerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *usersellerPager) orderExpr(query *UserSellerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserSellerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSeller.
func (us *UserSellerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSellerPaginateOption,
) (*UserSellerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSellerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSellerConnection{Edges: []*UserSellerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = us.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSellerOrderFieldBrandName orders UserSeller by brandName.
	UserSellerOrderFieldBrandName = &UserSellerOrderField{
		Value: func(us *UserSeller) (ent.Value, error) {
			return us.BrandName, nil
		},
		column: userseller.FieldBrandName,
		toTerm: userseller.ByBrandName,
		toCursor: func(us *UserSeller) Cursor {
			return Cursor{
				ID:    us.ID,
				Value: us.BrandName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSellerOrderField) String() string {
	var str string
	switch f.column {
	case UserSellerOrderFieldBrandName.column:
		str = "BRANDNAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSellerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSellerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSellerOrderField %T must be a string", v)
	}
	switch str {
	case "BRANDNAME":
		*f = *UserSellerOrderFieldBrandName
	default:
		return fmt.Errorf("%s is not a valid UserSellerOrderField", str)
	}
	return nil
}

// UserSellerOrderField defines the ordering field of UserSeller.
type UserSellerOrderField struct {
	// Value extracts the ordering value from the given UserSeller.
	Value    func(*UserSeller) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userseller.OrderOption
	toCursor func(*UserSeller) Cursor
}

// UserSellerOrder defines the ordering of UserSeller.
type UserSellerOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *UserSellerOrderField `json:"field"`
}

// DefaultUserSellerOrder is the default ordering of UserSeller.
var DefaultUserSellerOrder = &UserSellerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSellerOrderField{
		Value: func(us *UserSeller) (ent.Value, error) {
			return us.ID, nil
		},
		column: userseller.FieldID,
		toTerm: userseller.ByID,
		toCursor: func(us *UserSeller) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSeller into UserSellerEdge.
func (us *UserSeller) ToEdge(order *UserSellerOrder) *UserSellerEdge {
	if order == nil {
		order = DefaultUserSellerOrder
	}
	return &UserSellerEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// ViewAnalyticsEdge is the edge representation of ViewAnalytics.
type ViewAnalyticsEdge struct {
	Node   *ViewAnalytics `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ViewAnalyticsConnection is the connection containing edges to ViewAnalytics.
type ViewAnalyticsConnection struct {
	Edges      []*ViewAnalyticsEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ViewAnalyticsConnection) build(nodes []*ViewAnalytics, pager *viewanalyticsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ViewAnalytics
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ViewAnalytics {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ViewAnalytics {
			return nodes[i]
		}
	}
	c.Edges = make([]*ViewAnalyticsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ViewAnalyticsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ViewAnalyticsPaginateOption enables pagination customization.
type ViewAnalyticsPaginateOption func(*viewanalyticsPager) error

// WithViewAnalyticsOrder configures pagination ordering.
func WithViewAnalyticsOrder(order []*ViewAnalyticsOrder) ViewAnalyticsPaginateOption {
	return func(pager *viewanalyticsPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithViewAnalyticsFilter configures pagination filter.
func WithViewAnalyticsFilter(filter func(*ViewAnalyticsQuery) (*ViewAnalyticsQuery, error)) ViewAnalyticsPaginateOption {
	return func(pager *viewanalyticsPager) error {
		if filter == nil {
			return errors.New("ViewAnalyticsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type viewanalyticsPager struct {
	reverse bool
	order   []*ViewAnalyticsOrder
	filter  func(*ViewAnalyticsQuery) (*ViewAnalyticsQuery, error)
}

func newViewAnalyticsPager(opts []ViewAnalyticsPaginateOption, reverse bool) (*viewanalyticsPager, error) {
	pager := &viewanalyticsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *viewanalyticsPager) applyFilter(query *ViewAnalyticsQuery) (*ViewAnalyticsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *viewanalyticsPager) toCursor(va *ViewAnalytics) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(va).Value)
	}
	return Cursor{ID: va.ID, Value: cs}
}

func (p *viewanalyticsPager) applyCursors(query *ViewAnalyticsQuery, after, before *Cursor) (*ViewAnalyticsQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultViewAnalyticsOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *viewanalyticsPager) applyOrder(query *ViewAnalyticsQuery) *ViewAnalyticsQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultViewAnalyticsOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultViewAnalyticsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *viewanalyticsPager) orderExpr(query *ViewAnalyticsQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultViewAnalyticsOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ViewAnalytics.
func (va *ViewAnalyticsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ViewAnalyticsPaginateOption,
) (*ViewAnalyticsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newViewAnalyticsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if va, err = pager.applyFilter(va); err != nil {
		return nil, err
	}
	conn := &ViewAnalyticsConnection{Edges: []*ViewAnalyticsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = va.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if va, err = pager.applyCursors(va, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		va.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := va.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	va = pager.applyOrder(va)
	nodes, err := va.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ViewAnalyticsOrderFieldViews orders ViewAnalytics by views.
	ViewAnalyticsOrderFieldViews = &ViewAnalyticsOrderField{
		Value: func(va *ViewAnalytics) (ent.Value, error) {
			return va.Views, nil
		},
		column: viewanalytics.FieldViews,
		toTerm: viewanalytics.ByViews,
		toCursor: func(va *ViewAnalytics) Cursor {
			return Cursor{
				ID:    va.ID,
				Value: va.Views,
			}
		},
	}
	// ViewAnalyticsOrderFieldScrolls orders ViewAnalytics by scrolls.
	ViewAnalyticsOrderFieldScrolls = &ViewAnalyticsOrderField{
		Value: func(va *ViewAnalytics) (ent.Value, error) {
			return va.Scrolls, nil
		},
		column: viewanalytics.FieldScrolls,
		toTerm: viewanalytics.ByScrolls,
		toCursor: func(va *ViewAnalytics) Cursor {
			return Cursor{
				ID:    va.ID,
				Value: va.Scrolls,
			}
		},
	}
	// ViewAnalyticsOrderFieldExits orders ViewAnalytics by exits.
	ViewAnalyticsOrderFieldExits = &ViewAnalyticsOrderField{
		Value: func(va *ViewAnalytics) (ent.Value, error) {
			return va.Exits, nil
		},
		column: viewanalytics.FieldExits,
		toTerm: viewanalytics.ByExits,
		toCursor: func(va *ViewAnalytics) Cursor {
			return Cursor{
				ID:    va.ID,
				Value: va.Exits,
			}
		},
	}
	// ViewAnalyticsOrderFieldDateCreated orders ViewAnalytics by dateCreated.
	ViewAnalyticsOrderFieldDateCreated = &ViewAnalyticsOrderField{
		Value: func(va *ViewAnalytics) (ent.Value, error) {
			return va.DateCreated, nil
		},
		column: viewanalytics.FieldDateCreated,
		toTerm: viewanalytics.ByDateCreated,
		toCursor: func(va *ViewAnalytics) Cursor {
			return Cursor{
				ID:    va.ID,
				Value: va.DateCreated,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ViewAnalyticsOrderField) String() string {
	var str string
	switch f.column {
	case ViewAnalyticsOrderFieldViews.column:
		str = "VIEWS"
	case ViewAnalyticsOrderFieldScrolls.column:
		str = "SCROLLS"
	case ViewAnalyticsOrderFieldExits.column:
		str = "EXITS"
	case ViewAnalyticsOrderFieldDateCreated.column:
		str = "DATECREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ViewAnalyticsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ViewAnalyticsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ViewAnalyticsOrderField %T must be a string", v)
	}
	switch str {
	case "VIEWS":
		*f = *ViewAnalyticsOrderFieldViews
	case "SCROLLS":
		*f = *ViewAnalyticsOrderFieldScrolls
	case "EXITS":
		*f = *ViewAnalyticsOrderFieldExits
	case "DATECREATED":
		*f = *ViewAnalyticsOrderFieldDateCreated
	default:
		return fmt.Errorf("%s is not a valid ViewAnalyticsOrderField", str)
	}
	return nil
}

// ViewAnalyticsOrderField defines the ordering field of ViewAnalytics.
type ViewAnalyticsOrderField struct {
	// Value extracts the ordering value from the given ViewAnalytics.
	Value    func(*ViewAnalytics) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) viewanalytics.OrderOption
	toCursor func(*ViewAnalytics) Cursor
}

// ViewAnalyticsOrder defines the ordering of ViewAnalytics.
type ViewAnalyticsOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ViewAnalyticsOrderField `json:"field"`
}

// DefaultViewAnalyticsOrder is the default ordering of ViewAnalytics.
var DefaultViewAnalyticsOrder = &ViewAnalyticsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ViewAnalyticsOrderField{
		Value: func(va *ViewAnalytics) (ent.Value, error) {
			return va.ID, nil
		},
		column: viewanalytics.FieldID,
		toTerm: viewanalytics.ByID,
		toCursor: func(va *ViewAnalytics) Cursor {
			return Cursor{ID: va.ID}
		},
	},
}

// ToEdge converts ViewAnalytics into ViewAnalyticsEdge.
func (va *ViewAnalytics) ToEdge(order *ViewAnalyticsOrder) *ViewAnalyticsEdge {
	if order == nil {
		order = DefaultViewAnalyticsOrder
	}
	return &ViewAnalyticsEdge{
		Node:   va,
		Cursor: order.Field.toCursor(va),
	}
}
